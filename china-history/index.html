<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="imcm">
<meta name="description" content="&lt;span id=&#34;jinrishici-sentence&#34;&gt;正在加载今日诗词....&lt;/span&gt;
&lt;script src=&#34;https://sdk.jinrishici.com/v2/browser/jinrishici.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;">
<meta name="theme-color" content="#000">
<title> 中国大事记 | IMCM</title>
<link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/firstisan/firstisan.github.io@master/favicon.ico?v=1614073159314">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/firstisan/firstisan.github.io@master/media/css/gemini.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/firstisan/firstisan.github.io@master/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="https://cdn.jsdelivr.net/gh/firstisan/firstisan.github.io@master/media/hljs/styles/atom-one-light.css"
  rel="stylesheet">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/firstisan/firstisan.github.io@master/styles/main.css">

<script src="https://cdn.jsdelivr.net/gh/firstisan/firstisan.github.io@master/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>





  <meta name="description" content=" 中国大事记" />
  <meta name="keywords" content="History" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>IMCM</span>
            </a>  
          
        </div>
        
          <p class="subtitle">静于心 简于形</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/about/" target="_self">
                  <i class="fa fa-globe"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="https://cdn.jsdelivr.net/gh/firstisan/firstisan.github.io@master/images/avatar.png"/>
    <p class="site-author-name">imcm</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">33</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">30</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">30</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="https://imcm.xyz/atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  
    <div class="sidebar-item sidebar-item-social">
      <div class="social-item">
        
        
          
            <a class="social-img" href="#">
              <img src="https://cdn.jsdelivr.net/gh/firstisan/firstisan.github.io@master" />
              <i class="fa fa-globe" title="" ></i>
            </a>
          
        
      </div>
    </div>
  



  <div style="width: 100%; position: relative;">
    <canvas id="canvasDiyBlock" style="width:100%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
    <script src="https://cdn.jsdelivr.net/gh/firstisan/firstisan.github.io@master/media/js/magic/clock.js"></script>
  </div>

</div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://imcm.xyz/china-history/">
       中国大事记
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2020-07-17 18:25:10">2020-07-17</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
      
      
      <a href="https://imcm.xyz/history/">
        <span>History</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>15<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>4184<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
    
    
    <span id="/china-history/" data-flag-title=" 中国大事记" class="meta-item pc-show leancloud_visitors">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-eye"></i>
      <span><span class="language" data-lan="view">浏览量</span>：<span class="leancloud-visitors-count"></span></span>
    </span>
    
  </div>
</section>
            <div class="post-body next-md-body" id="post_body">
              <p>公元前4300前——2500年：大汶口文化中晚期，处于父系氏族公社时期。</p>
<!-- more -->
<p>约4000多年前：传说中的黄帝、尧、舜、禹时期。</p>
<p>帝尧时期：尧命羲和观测天象，制定历法，以366日为一年。</p>
<p>约公元前21世纪：禹将部落联盟首领之位传子启，夏朝建立。</p>
<p>约公元前21前17世纪：二里头文化繁荣时期，二里头文化与我国历史记载中的夏朝时间基本相吻合。</p>
<p>公元前2000年：中国约在此时已有凿井取水的技术。</p>
<p>约公元前1600年：汤伐夏桀，战于鸣条，夏朝灭亡。</p>
<p>约公元前16世纪：商汤制定刑法，后来称为《汤刑》。</p>
<p>约公元前14世纪：盘庚即位，迁都于殷，商朝中兴。</p>
<p>约公元前13世纪：商王武丁任命傅说为相，使商朝政治局面大有改善。</p>
<p>约公元前12世纪：商朝进入青铜器全盛时代。</p>
<p>公元前12世纪：周人首领古公亶父迁周人于岐山，周朝王业自此开始。</p>
<p>公元前1046年：周武王率军伐商，在牧野之战中大败商军，灭亡商朝。</p>
<p>公元前10世纪：周穆王西巡，会见西王母，在《穆天子传》中有记载。</p>
<p>公元前9世纪：周厉王实行“专利”，引起国人不满。</p>
<p>公元前841年：国人暴动，厉王出奔，召公、周公二相行政，号曰“共和”看，自此，中国历史始有准确年代。</p>
<p>公元前828年：厉王死于彘，召公、周公立太子静为王，是为周宣王。</p>
<p>公元前771年：申侯与缯、西夷犬戎攻周幽王，杀之于骊山，西周亡。</p>
<p>公元前770年：周平王自镐京东迁洛邑，自是年起史称东周。</p>
<p>公元前750年：秦文公伐戎，戎败，文公收其民。</p>
<p>公元前722年：史书《春秋》记事从本年开始。</p>
<p>公元前685年：齐桓公即位，以管仲为相，齐国实力大增，成为霸主。</p>
<p>公元前684年：齐鲁长勺之战，齐师败绩。</p>
<p>公元前632年：晋国联合齐、宋、秦之师破楚师于城濮，晋文公盟诸侯于践土。</p>
<p>公元前594年：鲁国实行“初税亩”，标志井田制开始瓦解。</p>
<p>公元前536年：郑国子产铸刑书。</p>
<p>公元前514年：吴王阖闾召伍员为行人（外交官），与其共谋国事。</p>
<p>公元前479年：孔子去世，孔子是我国古代著名思想家、教育家，为儒家学派创始人。</p>
<p>公元前473年：越王勾践灭吴，后会齐、晋诸侯于徐州，成为诸侯霸主。</p>
<p>公元前453年：晋国赵、韩、魏三家共灭智氏，三分其领地。</p>
<p>公元前445年：魏文侯即位。他在位期间，任用李悝在魏国实行变法。</p>
<p>公元前403年：周威烈王命赵、韩、魏列为诸侯。</p>
<p>公元前391年：齐国田和迁齐康公于海上，田氏遂有齐国。</p>
<p>公元前381年：楚悼王卒，他在位期间任用吴起在楚国变法。</p>
<p>公元前356年：秦孝公任用商鞅，实行变法。</p>
<p>公元前221年：战国时期结束，秦王嬴政建立起中国封建社会历史上第一个统一王朝——秦朝。</p>
<p>公元前202年：刘邦称帝，是为汉高祖刘邦，建立汉朝，定都长安。</p>
<p>公元前141年：汉景帝死，皇太子彻嗣位，是为汉武帝。文帝、景帝统治时期，汉朝社会经济逐渐发展，史称“文景之治”。</p>
<p>公元前119年：卫青、霍去病分道出击匈奴，其后匈奴远徙，漠南无王庭。</p>
<p>公元前51年：汉宣帝召集石渠阁会议，讲论五经异同。</p>
<p>公元8年：王莽即真天子位，定国号曰“新”，西汉灭亡。</p>
<p>公元25年：刘秀称帝，建元建武，是为东汉光武帝。</p>
<p>公元92年：汉和帝与宦官郑众定议，诛大将军窦宪，郑众以功封侯，是为东汉宦官用权之始。</p>
<p>公元166年：第一次党锢之祸，司隶校尉李膺等200余人被称为党人，逮捕下狱。</p>
<p>公元184年：张角率众起义，因起义军皆戴黄巾，故称黄巾起义。</p>
<p>公元265年：司马炎废魏主，称帝，是为晋武帝，定都洛阳。</p>
<p>公元357年：前秦苻坚即位，称大秦天王，汉人王猛辅政。</p>
<p>公元383年：晋秦淝水之战，前秦大败，内部分崩。</p>
<p>公元399～412年：高僧法显前往天竺求佛，著有《佛国记》。</p>
<p>公元420年：刘裕废晋恭帝自立，国号宋，史称刘宋，是为宋武帝。南朝开始。</p>
<p>公元500年：祖冲之去世，生前首次把圆周率准确数值推算到小数点后七位数。</p>
<p>公元581年：杨坚称帝，国号隋，是为隋文帝，建都长安。</p>
<p>公元618年：李渊称帝，国号唐，是为唐高祖，隋朝亡。</p>
<p>公元645年：玄奘取经而还，抵达长安，《大唐西域记》成书。</p>
<p>公元690年：武则天废睿宗，称帝，改国号为周。</p>
<p>公元705年：张柬之等人发动政变，逼武则天退位，复立中宗李显，复国号唐。</p>
<p>公元713年：唐朝封靺鞨首领大祚荣为都督、渤海郡王。</p>
<p>公元738年：《唐六典》成书。</p>
<p>公元745年：唐玄宗敕改波斯（景教）寺为大秦寺。</p>
<p>公元755年：唐朝爆发安史之乱，由盛转衰。</p>
<p>公元813年：唐宪宗元和八年，李吉甫撰成《元和郡县图志》。</p>
<p>公元907年：朱温逼唐哀帝禅让，即帝位，改名朱晃，是为后梁太祖，史称后梁，唐朝亡。</p>
<p>公元916年：契丹首领耶律阿保机称帝，是为辽太祖，建契丹。</p>
<p>公元960年：陈桥兵变，赵匡胤即位，是为宋太祖，国号宋，后周亡。</p>
<p>公元993年：王小波、李顺起义。</p>
<p>1038年：党项首领元昊称帝，国号大夏，史称西夏，是为西夏景宗，建都兴庆府。</p>
<p>1127年：金军俘宋徽、钦二帝北还，北宋灭亡。康王赵构于南京应天府即位，是为宋高宗，建立南宋。</p>
<p>1141年：宋金议和，史称绍兴和议。</p>
<p>1164年：隆兴和议，宋金重订和约。</p>
<p>1279年：元军攻破崖山，宋帝溺死，宋亡。</p>
<p>1286年：《农桑辑要》颁行，为中国现存最古的官修农书。</p>
<p>1345年：元朝修成《辽史》《金史》《宋史》。</p>
<p>1355年：刘福通迎韩山童之子韩林儿为帝，建国号宋，改元龙凤，韩林儿号小明王。</p>
<p>1368年：朱元璋在应天府即帝位，国号明，是为明太祖。</p>
<p>1399～1402年：燕王朱棣发动靖难之役，攻占南京，即位称帝，是为明成祖。</p>
<p>1405年：明成祖命宦官郑和与王景弘等使南洋各地，郑和下西洋自此始。</p>
<p>1407年：明成祖永乐五年，《永乐大典》成书。</p>
<p>1421年：明成祖迁都北京，以南京为留都。</p>
<p>1429年：明朝设钞关，以船只大小收税，称“船料”。</p>
<p>1449年：瓦剌也先犯大同，英宗率军亲征，在土木堡被瓦剌军所破，英宗被俘，史称“土木之变”。</p>
<p>1457年：宦官曹吉祥及其党羽石亨等乘景帝病危，迎太上皇英宗复位，史称“夺门之变”。</p>
<p>1521～1524年：大礼议之争，群臣力争，下狱者100多人。</p>
<p>1542年：宫婢杨金英等谋杀世宗未遂，史称嘉靖“宫婢之变”。</p>
<p>1563年：巡抚谭纶率戚继光、俞大猷、刘显三将大破倭寇，收复兴化，浙、闽倭寇渐平。</p>
<p>1571年：明朝封俺答为顺义王，开互市。</p>
<p>1581年：张居正进行赋役制度改革，全面推行一条鞭法。</p>
<p>1587年：海瑞死于南京右都御史任上，百姓为之罢市致哀。</p>
<p>1588年：努尔哈赤统一建州女真。</p>
<p>1594年：顾宪成被责革职，遂回无锡修东林书院讲学，讽议朝政评论人物，东林党议始于此。</p>
<p>1599年：明神宗遣宦官至各地征税、办矿，激起临清、沙市、武昌、汉阳等地民变。</p>
<p>1600年：耶稣会教士利玛窦到达北京，明神宗允许在京师建教堂传教。</p>
<p>1615年：努尔哈赤正式建立八旗制度。</p>
<p>1616年：努尔哈赤在赫图阿拉称汗，国号金，史称后金。</p>
<p>1618年：后金汗努尔哈赤以“七大恨”誓师伐明。</p>
<p>1619年：萨尔浒之战，明军大败。</p>
<p>1621年：后金攻陷沈阳，又陷辽阳，并迁都辽阳。</p>
<p>1625年：后金迁都沈阳，改称盛京。</p>
<p>1633年：高迎祥、李自成、张献忠等起义军渡黄河南下，进入豫西。</p>
<p>1636年：皇太极即帝位，改国号为清。</p>
<p>1637年：宋应星所著《天工开物》刊行。</p>
<p>1641年：李自成起义军攻入洛阳，杀明福王朱常洵。</p>
<p>1644年：李自成率大顺军攻占北京，明崇祯帝自缢，明亡。</p>
<p>1655年：清世祖顺治帝于内十三衙门立铁牌，严禁太监干政。</p>
<p>1661年：郑成功率军驱逐荷兰殖民者，收复台湾。</p>
<p>1729年：因西北用兵，设军机房，后改为军机处。</p>
<p>1735年：清世宗雍正帝去世，子弘历继位，是为清高宗，改元乾隆。</p>
<p>1747年：大金川土司沙罗奔举兵反，清廷派重兵平叛，两年后平定。</p>
<p>1762年：清廷设伊犁将军，总统新疆南北两路事务。</p>
<p>1771年：土尔扈特部在首领渥巴锡率领下，长途跋涉，从沙俄重返祖国。</p>
<p>1776年：大金川索诺木出降，大小金川之役结束。</p>
<p>1782年：第一部《四库全书》修成。</p>
<p>1784年：美国商船“中国皇后”号从纽约出发，绕道非洲好望角，驶抵广州。</p>
<p>1785年：乾隆帝于乾清宫设“千叟宴”，60岁以上老人入宴者达3000人。</p>
<p>1793年：乾隆帝在热河行宫接见英国马戛尔尼使团。</p>
<p>1795年：乾隆帝立皇十五子颙琰为皇太子，定明年继承皇位，改元嘉庆。</p>
<p>1813年：林清率领的起义军攻入紫禁城，旋即失败。</p>
<p>1814年：纂辑《全唐文》告成，全书1000卷，收入作家3000多人，作品18000多篇。</p>
<p>1814年：史学家赵翼去世，著有《廿二史札记》《皇朝武功纪盛》等。</p>
<p>1821年：清廷重申禁烟令，严禁在澳门、黄埔囤放和售卖鸦片。</p>
<p>1822年：清廷定例禁止银两出洋。</p>
<p>1823年：医学家陈念祖去世，著作颇丰，以《医学三字经》广为流传。</p>
<p>1824年：林则徐综办江浙水利。</p>
<p>1825年：《西夏书事》刊行，吴广成辑唐以来诸史、文集和野史有关西夏史事，以编年体成书。</p>
<p>1826年：贺长龄、魏源等编《皇朝经世文编》成书，120卷，搜录重要史料。</p>
<p>1829年：洋钱、鸦片为害日甚，道光帝命严行查禁。</p>
<p>1830年：小说家李汝珍约于此年去世，著有长篇小说《镜花缘》。</p>
<p>1833年：清廷定洋银与纹银使用条例。</p>
<p>1839年：林则徐在虎门海滩销毁收缴的鸦片。</p>
<p>1840年：鸦片战争爆发。清廷命琦善为钦差大臣，赴广州与英谈判，林则徐被革职。</p>
<p>1842年：清廷被迫与英国签订《南京条约》。</p>
<p>1844年：清廷被迫先后签订中美《望厦条约》、中法《黄埔条约》。</p>
<p>1845年：英国驻沪领事与上海道台订立《上海租地章程》，是为外国侵略者在中国设立租界的开始。</p>
<p>1851年：太平天国起义爆发。</p>
<p>1853年：太平军沿长江东下，占领南京，定为首都，改称天京。</p>
<p>1853年：太平天国颁布《天朝田亩制度》。</p>
<p>1855年：太平军北伐失败，主将林凤祥、李开芳牺牲。</p>
<p>1856年：太平天国发生天京事变。</p>
<p>1856年：英国借口“亚罗号事件”，挑起第二次鸦片战争。</p>
<p>1857年：石达开受洪秀全猜忌，率众自天京出走。</p>
<p>1858年：俄、美、英、法逼迫清廷相继签订《天津条约》。</p>
<p>1859年：太平天国颁布《资政新篇》。</p>
<p>1860年：美国人华尔组成“洋枪队”，协助清廷镇压太平军。</p>
<p>1860年：英法联军攻陷北京，恭亲王与英、法、俄分别签订《北京条约》。</p>
<p>1861年：咸丰卒，慈禧发动政变，慈禧、慈安两太后垂帘听政，史称“辛酉政变”。</p>
<p>1864年：天京为清军攻陷，太平天国起义失败。</p>
<p>1872年：李鸿章在上海创办轮船招商局，侨商陈启源在广东南海创办继昌隆缫丝局，中国民族资本主义近代工业开始出现。</p>
<p>1875年：清廷以兵部侍郎郭嵩焘任出使英国钦差大臣，为中国正式派遣驻外使节的开始。</p>
<p>1885年：清军取得谅山大捷，此后李鸿章和法国公使巴德诺在天津签订《中法新约》，中法战争结束。</p>
<p>1888年：北洋海军建成，以丁汝昌为提督，林泰曾、刘步蟾为左、右翼总兵。</p>
<p>1894年：中日甲午战争爆发。</p>
<p>1898年：光绪帝下“明定国是”诏书，戊戌变法开始。八月初六（9月21日），慈禧幽禁光绪帝于瀛台，百日维新失败。</p>
<p>1900年：由英国海军上将西摩尔统率的八国联军进犯北京。</p>
<p>1901年：清廷与俄、英、美、日、德、法、意、奥、比、西、荷等十一国签订《辛丑条约》。</p>
<p>1905年：清廷废除科举考试制度。</p>
<p>1911年：四川保路运动爆发。</p>
<p>1911年：辛亥革命。</p>
<p>1912年：南京临时政府成立，孙中山就任临时大总统，定国号为中华民国。</p>
<p>1913年：“二次革命”爆发，以失败告终。</p>
<p>1914年：袁世凯废除《中华民国临时约法》，公布《中华民国约法》。</p>
<p>1915年：日本提出灭亡中国的“二十一条”。</p>
<p>1917年：张勋复辟，旋即失败。</p>
<p>1919年：“五四”运动爆发。</p>
<p>1919年：中华革命党改组为中国国民党。</p>
<p>1921年：中国共产党成立。</p>
<p>1922年：第一次直奉战争爆发。</p>
<p>1923年：京汉铁路工人大罢工。</p>
<p>1924年：黄埔军校建立。</p>
<p>1925年：3月12日，孙中山在北京逝世。</p>
<p>1927年：《现代评论》创刊于北京，形成现代评论派。</p>
<p>1927年：汉口、九江民众收回英租界。</p>
<p>1928年：皇姑屯事件，张作霖死。</p>
<p>1930年：蒋阎冯中原大战。</p>
<p>1931年：日本帝国主义在沈阳制造“九一八”事变。</p>
<p>1935年：聂耳为电影《风云儿女》主题歌谱曲《义勇军进行曲》。</p>
<p>1935年：曾朴于本年去世，著有长篇小说《孽海花》。</p>
<p>1935年：“一二·九”运动爆发。</p>
<p>1936年：12月12日，张学良、杨虎城发动西安事变。</p>
<p>1937年：卢沟桥事变发生，全面抗日战争开始。</p>
<p>1937年：12月，南京陷落，日军入城大肆杀戮。</p>
<p>1940年：八路军发动百团大战。</p>
<p>1941年：陈纳德飞虎队来中国协助抗战。</p>
<p>1945年：中、美、英三国发表《波茨坦公告》，促令日本无条件投降。</p>
<p>1945年：中印公路全线贯通。</p>
<p>1945年：抗日战争胜利。</p>
<p>1945年：孙犁创作短篇小说《荷花淀》。</p>
<p>1946年：巴金写成中篇小说《寒夜》。</p>
<p>1947年：土地改革运动在解放区全面展开。</p>
<p>1949年：10月1日，中华人民共和国成立。</p>
<p>1953年：开始执行发展国民经济的第一个五年计划。</p>
<p>1955年：成（都）——阿（坝）公路全线通车，全长507千米。</p>
<p>1957年：第一届中国出口商品交易会在广州举行（简称“广交会”）。</p>
<p>1965年：中国人工合成结晶牛胰岛素，是世界上首次人工合成蛋白质。</p>
<p>1980年：中国向太平洋预定海域发射的第一枚运载火箭获得圆满成功。</p>
<p>1984年：中国体育代表团在美国洛杉矶举行的第23届奥运会上获得15枚金牌，实现了中国在奥运会金牌榜上零的突破。</p>
<p>1987年：中葡两国政府在北京签署关于澳门问题的联合声明，确认中国政府于1999年12月20日对澳门恢复行使主权。</p>
<p>1988年：北京正负电子对撞机首次对撞成功。</p>
<p>1990年：第11届亚洲运动会在北京举行，这是中国第一次承办综合性国际体育大赛。</p>
<p>1997年：7月1日，中国政府对香港恢复行使主权。</p>
<p>1999年：12月20日，中国政府对澳门恢复行使主权。</p>

            </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      imcm
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://imcm.xyz/china-history/" title=" 中国大事记">https://imcm.xyz/china-history/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://imcm.xyz/history/"># History</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="Facade 类参考" href="https://imcm.xyz/laravel-facades/">Facade 类参考</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="Facade 类参考" href="https://imcm.xyz/laravel-facades/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="Linux 下使用 systemd 设置开机启动项" href="https://imcm.xyz/linux-systemd-start/">Linux 下使用 systemd 设置开机启动项</a>
        <a class="nav-mobile-next" title="Linux 下使用 systemd 设置开机启动项" href="https://imcm.xyz/linux-systemd-start/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a
        href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      Copyright 2020 imcm.xyz. All Rights Reserved.
|
<a href="http://beian.miit.gov.cn" target="_blank">粤ICP备16038460号
</a>
|
<span id="jinrishici-sentence">正在加载今日诗词....</span>
<script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.onresize = function () {
    calcuHeight();
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, transitionDir, {});
          }
        })
        window.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'true'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();
  
  // 离开当前页title变化
  var leaveTitle = "";
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script>
  let images = document.querySelectorAll('.section img');
  console.log(images);
  images.forEach(image => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement('a');
    aelem.href = image.src;
    aelem.dataset['fancybox'] = 'images';
    aelem.dataset['rel'] = 'fancybox-button';
    aelem.classList.add('fancybox');
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  })
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip">打开微信扫一扫，即可进行扫码打赏哦</p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        window.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        window.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        window.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        window.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      window.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      window.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

<div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/docker-portainer/"" data-c="
          &lt;p&gt;今天，我们将研究如何在Raspberry Pi上安装Docker和Portainer。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;这个过程非常简单，但是在以后的教程中我们将使用Portainer来设置不同的docker容器，因此这是我们要研究的第一件事。该树莓派4用以作为小，因为它是非常强大的。结合大量的大型Docker容器不需要强大的CPU的事实，在Raspberry Pi上运行某些Docker容器对于许多人来说是一个不错的选择。&lt;/p&gt;
&lt;p&gt;以下步骤将利用Raspberry Pi OS的全新安装。如果您不确定如何执行此操作，请在此处进行说明。&lt;/p&gt;
&lt;h3 id=&#34;所需的硬件&#34;&gt;所需的硬件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Raspbery Pi 4：Docker和Portainer可以安装在较旧的Raspberry Pi设备上，但是Raspberry Pi 4比较旧的设备具有更大的处理能力，这将带来更好的性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微型SD卡：这里不需要任何疯狂的东西，只需一个具有足够存储空间的优质微型SD卡即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Raspberry Pi 4保护套：这是我最喜欢的Raspberry Pi 4保护套之一，但是任何情况下都可以。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;电源：为Raspberry Pi供电。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HDMI电缆：我通常通过SSH连接到Raspberry Pi设备，因此仅当您打算将Raspberry Pi连接到显示器时才需要。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;说明-在raspberry-pi上安装docker和portainer&#34;&gt;说明-在Raspberry Pi上安装Docker和Portainer&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;通过运行以下命令，确保您的Raspberry Pi是最新的。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt update
sudo apt upgrade -y
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1613976193237.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;接下来要运行的脚本是在Raspberry Pi上安装Docker的脚本。Portainer是用于管理Docker容器的GUI，因此我们需要确保已安装Docker。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -sSL https://get.docker.com |  sh
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1613976202912.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;脚本完成后，我们需要为Pi用户帐户授予Docker访问权限。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo usermod -aG docker pi
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1613976214762.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;添加用户后，我们将运行命令以下载用于ARM处理器的最新Portainer映像（Raspberry Pi使用的映像）。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo docker pull portainer/portainer-ce:alpine
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1613976221298.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;我们的最后一步是创建一个将运行Portainer的新容器。如果您已经将Raspberry Pi上的端口9000用于其他用途（这不太可能），则需要更改以下端口。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo docker run --restart always -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:alpine
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1613976234190.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;现在，您应该能够导航到Raspberry Pi的IP地址和端口9000来访问Portainer。当您到达那里时，请创建一个用户名和密码。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;http://[RASPBERRY_PI_IP_ADDRESS]:9000
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1613976243565.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;
&lt;p&gt;选择本地并连接。&lt;br&gt;
&lt;img src=&#34;https://imcm.xyz/post-images/1613976251702.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;现在，您应该已连接到Portainer！&lt;br&gt;
&lt;img src=&#34;https://imcm.xyz/post-images/1613976256721.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;结论&#34;&gt;结论&lt;/h3&gt;
&lt;p&gt;这是一个非常简单的过程，但是我们将在以后的教程中使用它。我认为最好为此创建一个特定的教程，而不是在以后的所有教程中都安装Docker / Portainer。如有任何疑问，请在评论中保留。谢谢阅读！&lt;/p&gt;
">如何在Raspberry Pi上安装Docker和Portainer！</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/raspberry-smartfan/"" data-c="
          &lt;p&gt;树莓派风扇声音太大了, 非常影响睡觉， 不开风扇cpu温度又很容易太高了&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;准备&#34;&gt;准备&lt;/h3&gt;
&lt;p&gt;杜邦线母对母2根, 公对母2根, 直接淘宝买40pin的2排&lt;br&gt;
三极管S85501个，淘宝买2块钱50个包邮&lt;br&gt;
S8550为PNP型三极管，基极施加低电平时才导通电路，如果是用的NPN型三极管则与之相反&lt;br&gt;
树莓派小风扇1个&lt;br&gt;
树莓派引脚:&lt;br&gt;
&lt;img src=&#34;https://imcm.xyz/post-images/1612941425828.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;三极管引脚:&lt;br&gt;
&lt;img src=&#34;https://imcm.xyz/post-images/1612941453685.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;E: 发射机&lt;br&gt;
正级(接电源正极, 5V)&lt;br&gt;
可接树莓派4号引脚&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;B: 基级&lt;br&gt;
信号极控制是否通电(GPIO)&lt;br&gt;
可以接树莓派8号引脚&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C：集电极&lt;br&gt;
负极 (接电源负极, Ground)&lt;br&gt;
可以接树莓派6号引脚&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;接线&#34;&gt;接线&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;风扇红线(正极)接树莓派5V，如4号引脚&lt;/li&gt;
&lt;li&gt;风扇黑线(负极)接三极管C(集电集)&lt;/li&gt;
&lt;li&gt;三极管E(发射极)接树莓派Ground, 如6号引脚&lt;/li&gt;
&lt;li&gt;三极管B级, 接树莓派GPIO，如8号引脚&lt;br&gt;
如图:&lt;br&gt;
&lt;img src=&#34;https://imcm.xyz/post-images/1612941492479.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;python程序风扇&#34;&gt;Python程序风扇&lt;/h3&gt;
&lt;p&gt;在python交互式命令行下测试下是否可行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pi@raspberrypi:~/script $ python
Python 2.7.16 (default, Apr  6 2019, 01:42:57) 
[GCC 8.2.0] on linux2
Type &amp;quot;help&amp;quot;, &amp;quot;copyright&amp;quot;, &amp;quot;credits&amp;quot; or &amp;quot;license&amp;quot; for more information.
&amp;gt;&amp;gt;&amp;gt; import RPi.GPIO as GPIO
&amp;gt;&amp;gt;&amp;gt; GPIO_OUT = 14
&amp;gt;&amp;gt;&amp;gt; GPIO.setmode(GPIO.BCM)
&amp;gt;&amp;gt;&amp;gt; GPIO.setwarnings(False)
&amp;gt;&amp;gt;&amp;gt; GPIO.setup(GPIO_OUT, GPIO.OUT, initial=GPIO.HIGH)
&amp;gt;&amp;gt;&amp;gt; GPIO.output(GPIO_OUT, GPIO.LOW)  # 风扇开
&amp;gt;&amp;gt;&amp;gt; GPIO.output(GPIO_OUT, GPIO.HIGH) # 风扇关闭
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注：PNP型三极管GPIO.LOW是开, HIGH是关， NPN型相反&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;完整程序&#34;&gt;完整程序:&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lovehhf/raspi_script/master/smartfan.py&#34;&gt;smartfan.py&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;主要逻辑&#34;&gt;主要逻辑:&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;读取/sys/class/thermal/thermal_zone0/temp内容, 除1000获取CPU温度&lt;/li&gt;
&lt;li&gt;风扇初始状态设置为关闭状态&lt;/li&gt;
&lt;li&gt;温度低于55度且当前处于关闭状态开机风扇&lt;/li&gt;
&lt;li&gt;温度低于45度且当前处于开启状态关闭风扇&lt;/li&gt;
&lt;li&gt;每隔15秒查一下温度并更新状态&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir -p /home/pi/script &amp;amp;&amp;amp; cd /home/pi/script
wget https://raw.githubusercontent.com/lovehhf/raspi_script/master/smartfan.py
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;supervisor管理python进程&#34;&gt;supervisor管理python进程&lt;/h3&gt;
&lt;p&gt;添加配置文件: vim /etc/supervisor/conf.d/fan.conf:&lt;br&gt;
内容如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[program:fan]
command=/usr/bin/python3 /home/pi/script/smartfan.py
user=root
directory=/home/pi/script
stdout_logfile=/var/log/supervisor/%(program_name)s-stdout.log
stderr_logfile=/var/log/supervisor/%(program_name)s-stderr.log
autorestart=true
autostart=true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重启supervisor并查看状态:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pi@raspberrypi:/var/log $ sudo systemctl restart supervisor
pi@raspberrypi:/var/log $ sudo supervisorctl status fan
fan                              RUNNING   pid 3903, uptime 0:01:26
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;测试&#34;&gt;测试&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt install stress
stress -c 50   # cpu压力测试, 开50个进程不停地sqrt, 一下子风扇就转起来了
tail -f /var/log/fan_control.log  # 查看日志
&lt;/code&gt;&lt;/pre&gt;
">树莓派实现温控风扇</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/git-fork/"" data-c="
          &lt;h1 id=&#34;如何从主项目更新fork的项目&#34;&gt;如何从主项目更新fork的项目？&lt;/h1&gt;
&lt;p&gt;当我们从项目A fork了一份到自己的仓库后，项目A的作者还是继续更新。我们该怎么在不重复fork的情况下，更新项目A的内容到自己的仓库呢？&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;可以按照下面的操作进行。&lt;/p&gt;
&lt;h4 id=&#34;step-1&#34;&gt;step 1&lt;/h4&gt;
&lt;p&gt;打开：terminal，cd到自己fork后git clone的project下&lt;/p&gt;
&lt;p&gt;首先需要打开terminal终端，进入到从github上fork的项目，并且该项目被git clone的你自己的本地目录下。&lt;/p&gt;
&lt;h4 id=&#34;step-2&#34;&gt;step 2&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt; git remote add upstream https://github.com/xxxx/xxxx.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与上游仓库同步代码之前，必须配置 remote，“xxxx”代表你需要与之保持同步的数据源，本次lunnlew的AutoSignMachine为例，git项目地址&lt;br&gt;
&lt;img src=&#34;https://imcm.xyz/post-images/1612145554103.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;查看本地远程仓库&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt; git remote -v
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1612145638658.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;step-3&#34;&gt;step 3&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt; git fetch upstream
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从远程fork仓库更新同步代码&lt;br&gt;
&lt;img src=&#34;https://imcm.xyz/post-images/1612145759397.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;step-4&#34;&gt;step 4&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt; git merge upstream/main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;进行主节点和上游节点数据的合并&lt;br&gt;
&lt;img src=&#34;https://imcm.xyz/post-images/1612145867583.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;step-6&#34;&gt;step 6&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt; git push
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;合并后的文件进行push操作，将本地文件上传至github服务器上。&lt;br&gt;
&lt;img src=&#34;https://imcm.xyz/post-images/1612145911370.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;tips&#34;&gt;tips&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;你自己的文件在push到github之前一定要进行add和commit的操作，否则会有报错的提示&lt;/li&gt;
&lt;li&gt;操作完成后，去GitHub确认，自己项目文件内容与上游数据一致性，接下来再进行pull request操作&lt;/li&gt;
&lt;/ol&gt;
">如何从主项目更新fork的项目</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/git-course/"" data-c="
          &lt;h2 id=&#34;在网络上搜集到的全部git学习资料&#34;&gt;在网络上搜集到的全部Git学习资料&lt;/h2&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;1-实验楼&#34;&gt;1. 实验楼&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.shiyanlou.com/&#34; title=&#34;实验楼&#34;&gt;https://www.shiyanlou.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;实验楼是国内领先的IT技术实训平台，采用创新的“在线实验”学习模式，为学生及在职程序员提供编程、运维、测试、云计算、大数据、数据库等最新的IT技术实践课程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2-廖雪峰的官方网站&#34;&gt;2. 廖雪峰的官方网站&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&#34; title=&#34;廖雪峰的官方网站&#34;&gt;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://weibo.com/liaoxuefeng&#34;&gt;廖雪峰&lt;/a&gt;，十年软件开发经验，业余产品经理，精通Java/Python/Ruby/Visual Basic/Objective C等，对开源框架有深入研究，著有《Spring 2.0核心技术与最佳实践》一书，多个业余开源项目托管在GitHub&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;3-git-简明指南&#34;&gt;3. git - 简明指南&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://rogerdudler.github.io/git-guide/index.zh.html&#34;&gt;http://rogerdudler.github.io/git-guide/index.zh.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;超简洁图文介绍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;4-图解git&#34;&gt;4. 图解git&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://marklodato.github.io/visual-git-guide/index-zh-cn.html&#34;&gt;http://marklodato.github.io/visual-git-guide/index-zh-cn.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;5-阳志平的网站-如何高效利用github&#34;&gt;5. 阳志平的网站-《如何高效利用GitHub》&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://www.yangzhiping.com/tech/github.html&#34;&gt;http://www.yangzhiping.com/tech/github.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;正是Github，让社会化编程成为现实。本文尝试谈谈GitHub的文化、技巧与影响。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;6-pro-git&#34;&gt;6. Pro Git&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://iissnan.com/progit/&#34;&gt;http://iissnan.com/progit/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;7-易百教程&#34;&gt;7. 易百教程&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://www.yiibai.com/git&#34;&gt;http://www.yiibai.com/git&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
">收集的Git教程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/pi-aria2/"" data-c="
          &lt;p&gt;开着电脑下电影速度比较慢，而且还很费电，这时可以使用树莓派，利用Aria2这个工具，搭建一个远程离线下载机，想看的电影，推送到树莓派下载后，使用SMB就可以在电视上观看了。要下载大文件，同样推送到树莓派下载，完成后再拉到电脑上，非常方便，以下是具体的搭建过程。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;一-安装aria2&#34;&gt;一、安装Aria2&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;    sudo apt-get update
    sudo apt-get install aria2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;二-aria2配置&#34;&gt;二、Aria2配置&lt;/h2&gt;
&lt;h3 id=&#34;21创建配置文件&#34;&gt;2.1创建配置文件&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;    mkdir -p ~/.config/aria2/
    touch ~/.config/aria2/aria2.session
    nano ~/.config/aria2/aria2.config
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;22添加如下配置信息&#34;&gt;2.2添加如下配置信息&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;    # set your own path
    dir=[yourpath]
    disk-cache=32M
    file-allocation=trunc
    continue=true
    
    max-concurrent-downloads=10
    
    max-connection-per-server=16
    min-split-size=10M
    split=5
    max-overall-download-limit=0
    #max-download-limit=0
    #max-overall-upload-limit=0
    #max-upload-limit=0
    disable-ipv6=false
    
    save-session=~/.config/aria2/aria2.session
    input-file=~/.config/aria2/aria2.session
    save-session-interval=60
    
    
    enable-rpc=true
    rpc-allow-origin-all=true
    rpc-listen-all=true
    rpc-secret=secret
    #event-poll=select
    rpc-listen-port=6800
    
    
    # for PT user please set to false
    enable-dht=true
    enable-dht6=true
    enable-peer-exchange=true
    
    # for increasing BT speed
    listen-port=51413
    #follow-torrent=true
    #bt-max-peers=55
    #dht-listen-port=6881-6999
    #bt-enable-lpd=false
    #bt-request-peer-speed-limit=50K
    peer-id-prefix=-TR2770-
    user-agent=Transmission/2.77
    seed-ratio=0
    #force-save=false
    #bt-hash-check-seed=true
    bt-seed-unverified=true
    bt-save-metadata=true
    bt-tracker=http://93.158.213.92:1337/announce,udp://151.80.120.114:2710/announce,udp://62.210.97.59:1337/announce,udp://188.241.58.209:6969/announce,udp://80.209.252.132:1337/announce,udp://208.83.20.20:6969/announce,udp://185.181.60.67:80/announce,udp://194.182.165.153:6969/announce,udp://37.235.174.46:2710/announce,udp://5.206.3.65:6969/announce,udp://89.234.156.205:451/announce,udp://92.223.105.178:6969/announce,udp://51.15.40.114:80/announce,udp://207.241.226.111:6969/announce,udp://176.113.71.60:6961/announce,udp://207.241.231.226:6969/announce
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后启动aria2：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ sudo aria2c --conf-path=/home/pi/.config/aria2/aria2.config
Exception caught
Exception: \[download\_helper.cc:563\] errorCode=1 Failed to open the file ~/.config/aria2/aria2.session, cause: File not found or it is a directory
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果出现错误，这是因为找不到aria2.session文件导致的，应该是无法识别“～”目录造成的，所以解决办法也很简单，将配置文件中的**“～”修改为“/home/pi”**即可。&lt;/p&gt;
&lt;p&gt;修改后再次启动aria2：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ sudo aria2c --conf-path=/home/pi/.config/aria2/aria2.config
03/19 13:35:47 \[NOTICE\] IPv4 RPC: listening on TCP port 6800
03/19 13:35:47 \[NOTICE\] IPv6 RPC: listening on TCP port 6800
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到aria2已经成功启动了！&lt;/p&gt;
&lt;h2 id=&#34;三-配置aria2开机启动&#34;&gt;三、配置aria2开机启动&lt;/h2&gt;
&lt;p&gt;创建systemctl service文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;    sudo nano /lib/systemd/system/aria2.service
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;User,conf-path下换成自己的username&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[Unit]
Description=Aria2 Service
After=network.target

[Service]
User=pi    
ExecStart=/usr/bin/aria2c --conf-path=/home/pi/.config/aria2/aria2.config

[Install]
WantedBy=default.target
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重载服务并设置开机启动&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;    sudo systemctl daemon-reload
    sudo systemctl enable aria2
    sudo systemctl start aria2
    sudo systemctl status aria2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看到如下文字证明启动成功(记住TCP port，AiraNg配置以及公网端口映射需要)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ sudo systemctl status aria2
● aria2.service - Aria2 Service
   Loaded: loaded (/lib/systemd/system/aria2.service; enabled; vendor preset: enabled)
   Active: active (running) since Thu 2020-03-19 13:44:39 CST; 5s ago
 Main PID: 6798 (aria2c)
    Tasks: 1 (limit: 2200)
   Memory: 3.4M
   CGroup: /system.slice/aria2.service
           └─6798 /usr/bin/aria2c --conf-path=/home/pi/.config/aria2/aria2.config

Mar 19 13:44:39 raspberrypi systemd\[1\]: Started Aria2 Service.
Mar 19 13:44:39 raspberrypi aria2c\[6798\]: 03/19 13:44:39 \[NOTICE\] IPv4 RPC: listening on TCP port 6800
Mar 19 13:44:39 raspberrypi aria2c\[6798\]: 03/19 13:44:39 \[NOTICE\] IPv6 RPC: listening on TCP port 6800
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;四-安装ariang以在网页上进行下载管理&#34;&gt;四、安装AriaNg以在网页上进行下载管理&lt;/h2&gt;
&lt;p&gt;AriaNg 是一个让 aria2 更容易使用的现代 Web 前端. AriaNg 使用纯 html &amp;amp; javascript 开发, 所以其不需要任何编译器或运行环境. 只要将 AriaNg 放在 Web 服务器里并在浏览器中打开即可使用. AriaNg 使用响应式布局, 支持各种计算机或移动设备.&lt;/p&gt;
&lt;p&gt;安装AriaNg的前提是树莓派上已经配置好了web环境，如果没有，按照&lt;a href=&#34;http://www.lxx1.com/3696&#34;&gt;树莓派安装 lnmp 套件搭建个人博客网站服务器&lt;/a&gt; 的教程，在树莓派上安装nginx软件（⚠️注意：只需要安装nginx即可）。&lt;/p&gt;
&lt;h4 id=&#34;安装ariang&#34;&gt;安装AriaNg&lt;/h4&gt;
&lt;p&gt;在&lt;a href=&#34;https://github.com/mayswind/AriaNg/releases&#34;&gt;这里&lt;/a&gt;选择最新版本的AriaNg.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd /var/www/html
wget https://github.com/mayswind/AriaNg/releases/download/1.0.0/AriaNg-1.0.0.zip
unzip AriaNg-1.0.0.zip -d aira
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在浏览器中访问&lt;code&gt;http://your-ip/aira&lt;/code&gt;即可打开AriaNg了。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1610013315460.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这时AriaNg显示未连接，在“系统设置-（PRC192.168.0.108）-Aria2 PRC 密钥 ”中，输入“&lt;strong&gt;secret&lt;/strong&gt;” 即可连接！&lt;/p&gt;
&lt;p&gt;之后，就可以愉快的用树莓派下载电影或者文件了～&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1610013229922.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;转载自&lt;a href=&#34;https://www.lxx1.com/&#34;&gt;科技爱好者博客&lt;/a&gt;&lt;/p&gt;
"><转>树莓派使用Aria2搭建BT远程下载机</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/one-vue/"" data-c="
          &lt;h2 id=&#34;vue&#34;&gt;Vue&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;官网介绍它是一个构建用户界面的渐进式框架 ;&lt;/p&gt;
&lt;p&gt;渐进式框架 : 主张最少 , 每个框架都不可避免会有自己的一些特点 , 从而对使用者有一定的要求 , 这些要求就是主张 , 主张有强有弱，它的强势程度会影响在业务开发中的使用方式 ; 而 Vue 虽然有全家桶套餐 , 但是你可以只用它的一部分 , 而不是用了它的 核心库 就必须用它的全部 .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;声明式渲染&#34;&gt;声明式渲染&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Vue.js 提供了简洁的模板语法声明式的将数据渲染至 DOM 中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;
	{{ message }}
&amp;lt;/div&amp;gt;
复制代码

const vm = new Vue({
	el: &#39;#app&#39;,
	data: {
		message: &#39;hello vue&#39;
	}
})
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;el&lt;/code&gt; : 　元素挂载点；只有在 new 创建实例的时候生效 ; 实例挂载之后可以使用 &lt;code&gt;vm.$el&lt;/code&gt; 访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt; : Vue 实例的数据对象 , Vue 会递归的将 data 的 property 转换为 getter 和 setter , 从而让 data 的 property 能够响应数据变化 ; 对象必须是纯粹的对象 (含有 0 个或者 多个 键值对) 浏览器 API 创建的对象 , 原型上的 property 会被忽略 , 大概来说 data 只能存在数据 , 不推荐观察拥有状态行为的对象 ;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{}}&lt;/code&gt; : 插值表达式 ; 官网也称为 &lt;code&gt;Mustache&lt;/code&gt; 语法&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;为什么组件中-data-是方法&#34;&gt;为什么组件中 data 是方法&lt;/h3&gt;
&lt;p&gt;当一个组件被定义时 (非根组件) &lt;code&gt;data&lt;/code&gt; 必须声明为一个返回对象的函数 , 因为组件可能被用来创建多个实例, 如果 data 仍然是一个对象 , 这样所有实例讲共享引用同一个数据对象 , 通过提供 data 函数 , 每次创建一个实例的时候 , 我们能够调用 data 函数 , 从而返回初始数据的一个全新数据对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 错误 示例
let options = {
  data: {
    uname: &#39;zs&#39;
  }
}
function Component(options) {
  this.data = options.data
}

let user1 = new Component(options)
let user2 = new Component(options)

user1.data.uname = &#39;ls&#39; // 修改 user1  触发了所有
console.log(user2.data.uname) // ls
复制代码

// 正确示例
let options = {
  data() {
    return {
      uname: &#39;zs&#39;
    }
  }
}
function Component(options) {
  this.data = options.data()
}

let user1 = new Component(options)
let user2 = new Component(options)

user1.data.uname = &#39;ls&#39; 
console.log(user2.data.uname) // zs
console.log(user1.data.uname) // ls
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于组件是可以多次复用的 , 如果不使用 &lt;code&gt;function return&lt;/code&gt; 每个组件的 data 在内存中都是指向同一个地址的 , 由于 JavaScript 复杂数据类型的特性 , 那一个数据改变其他的也改变了 , 但是如果用了 &lt;code&gt;function return&lt;/code&gt; 其实就相当于申明了新变量 , 相互独立 , 自然就不存在以上例子中存在的问题 ; JavaScript 在赋值 &lt;code&gt;Object&lt;/code&gt; 时 , 是直接一个相同的内存地址 , 所以为了每个组件的独立 , 采用了这种方式 ; 但由于根组件只有一个 , 不存在数据污染的情况 , 所以就可以是一个对象 ;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料 :&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000021680253&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000021680253&#34;&gt;segmentfault.com/a/119000002…&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://axiu.me/coding/why-vue-component-data-must-be-function/&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://axiu.me/coding/why-vue-component-data-must-be-function/&#34;&gt;axiu.me/coding/why-…&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/shaleilei/article/details/78084171&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://blog.csdn.net/shaleilei/article/details/78084171&#34;&gt;blog.csdn.net/shaleilei/a…&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;指令&#34;&gt;指令&lt;/h2&gt;
&lt;h3 id=&#34;v-cloak&#34;&gt;&lt;code&gt;v-cloak&lt;/code&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;这个指令可以配合着 &lt;code&gt;CSS&lt;/code&gt; 隐藏未编译的 &lt;code&gt;Mustache&lt;/code&gt; 标签 , 直到实例准备完毕&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;问题展示 :&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2020/7/24/1737f87f3b1db6fe?imageslim&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;/* css */
[v-cloak] { display: none; }
复制代码

&amp;lt;div v-cloak&amp;gt;{{ root }}&amp;lt;/div&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;v-text&#34;&gt;&lt;code&gt;v-text&lt;/code&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;更新某个元素节点下的值 ; 注意 : 会更新全部内容 , 如果想要局部更新 , 可以使用 &lt;code&gt;Mustache&lt;/code&gt; 语法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div v-text=&amp;quot;root&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;v-html&#34;&gt;&lt;code&gt;v-html&lt;/code&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;更新元素的 &lt;code&gt;innerHTML&lt;/code&gt; 注意 : 普通 html 内容&lt;/p&gt;
&lt;p&gt;在网站上使用 HTML 是非常危险的 , 容易导致 XSS 工具 , 用户提交内容时 切记勿要使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div v-html=&amp;quot;html&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
复制代码

new Vue({
  el: &#39;#app&#39;,
  data: {
    html: &#39;&amp;lt;p&amp;gt;hello vue&amp;lt;/p&amp;gt;&#39;
  }
})
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;v-pre&#34;&gt;&lt;code&gt;v-pre&lt;/code&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;原文输出 , 不会参与编译 , 输入什么内容就展示什么内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div v-pre&amp;gt;{{ will not compile }}&amp;lt;/div&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;v-once&#34;&gt;&lt;code&gt;v-once&lt;/code&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;被定义了 &lt;code&gt;v-once&lt;/code&gt; 指令的元素或者组件 (包括元素或组件内的子孙节点) 只能被渲染一次 , 首次渲染收 , 即时数据发生变化 , 也不会被重新渲染 , 一般用于静态内容展示 ;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div v-once&amp;gt;{{ content }}&amp;lt;/div&amp;gt;
复制代码

const vm = new Vue({
  el: &#39;#app&#39;,
  data: {
    content: &#39;this is init data&#39;
  }
})
vm.content = &#39;update data&#39;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;v-show-与-v-if&#34;&gt;&lt;code&gt;v-show&lt;/code&gt; 与 &lt;code&gt;v-if&lt;/code&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;这里的 &lt;code&gt;v-if&lt;/code&gt; 不单单是这一个指令 , 它包含 &lt;code&gt;v-else-if&lt;/code&gt; &lt;code&gt;v-else&lt;/code&gt; 功能差不多 , 这里就统一解释了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;v-show&lt;/code&gt;&lt;/strong&gt; : 根据表达式的真假值 , 判断元素是否隐藏 ( 切换元素的 display : block/none )&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;v-if&lt;/code&gt;&lt;/strong&gt; : 根据表达式的值来有条件的渲染数据 , 在切换时元素以及它的数据绑定 / 组件被销毁并重建&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;差异 :&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2020/7/24/1737f8831ff7a2be?imageslim&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div v-if=&amp;quot;isShow&amp;quot;&amp;gt; v-if &amp;lt;/div&amp;gt;
&amp;lt;div v-show=&amp;quot;isShow&amp;quot;&amp;gt; v-show &amp;lt;/div&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;分支判断代码演示&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 最终一会展示一个 p 标签中的内容  --&amp;gt;
&amp;lt;div&amp;gt;
  &amp;lt;p v-if=&amp;quot;score &amp;gt; 90&amp;quot;&amp;gt; 
  	&amp;lt;span&amp;gt;成绩优异 : {{ score }}&amp;lt;/span&amp;gt;
  &amp;lt;/p&amp;gt;
  &amp;lt;p v-else-if=&amp;quot;score &amp;gt; 70&amp;quot;&amp;gt; 
  	&amp;lt;span&amp;gt;成绩及格 : {{ score }}&amp;lt;/span&amp;gt;
  &amp;lt;/p&amp;gt;
  &amp;lt;p v-else&amp;gt; 
  	&amp;lt;span&amp;gt;不及格 : {{ score }}&amp;lt;/span&amp;gt;
  &amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;v-for&#34;&gt;&lt;code&gt;v-for&lt;/code&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;在 &lt;code&gt;v-for&lt;/code&gt; 中被循环的对象 , 必须是一个可迭代对象 &lt;code&gt;iterable&lt;/code&gt; ( Array | Number | Object | String ... )&lt;/p&gt;
&lt;p&gt;语法格式为 &lt;code&gt;alias in expression&lt;/code&gt; 其中的 in 也可以使用 of 替代&lt;/p&gt;
&lt;p&gt;可以为数组或者对象增加索引值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 数组循环 --&amp;gt;
&amp;lt;div v-for=&amp;quot;(item, index) in items&amp;quot;&amp;gt;
  {{ item.text }}
&amp;lt;/div&amp;gt;
复制代码

&amp;lt;!-- 对象循环 --&amp;gt;
&amp;lt;div v-for=&amp;quot;(val, key, index) in object&amp;quot;&amp;gt;
  {{ val }} {{ key }} {{ index }}
&amp;lt;/div&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;为什么-v-for-必须添加唯一-key&#34;&gt;为什么 &lt;code&gt;v-for&lt;/code&gt; 必须添加唯一 &lt;code&gt;key&lt;/code&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;当 Vue 正在更新使用 v-for 渲染的数据列表时 , 它默认使用 就地更新 策略 , 如果数据项的顺序被改变 , Vue 将不会移动 DOM 来匹配数据项的数据 , 而是就地更新每个元素 , 保证它们在每个索引位置的正确渲染 ;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;为什么要加-key&#34;&gt;为什么要加 &lt;code&gt;key&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;为了给 Vue 一个提示 , 以便它跟踪每个节点的身份 , 从而重用 和 重新排序现有元素 需要为每一项提供一个唯一 key&lt;/li&gt;
&lt;li&gt;key 主要用在 Vue 的 虚拟 DOM 算法 , 在新旧节点对比时 , 辨识虚拟DOM , 如果不使用 &lt;code&gt;key&lt;/code&gt; 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法 , 而如果使用了&lt;code&gt;key&lt;/code&gt; 它会基于 &lt;code&gt;key&lt;/code&gt; 的变化重新排列元素顺序 , 并且会移除 &lt;code&gt;key&lt;/code&gt; 不存在的元素&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;为什么不能用-index-做-key&#34;&gt;为什么不能用 &lt;code&gt;index&lt;/code&gt; 做 &lt;code&gt;key&lt;/code&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// 组件数据定义
const vm = new Vue({
  el: &#39;#app&#39;,
  data: {
    users: [
      { id: 1, uname: &#39;zs&#39;, age: 23 },
	     { id: 2, uname: &#39;ls&#39;, age: 24 },
	     { id: 3, uname: &#39;we&#39;, age: 25 },
	     { id: 4, uname: &#39;mz&#39;, age: 26 },
	  ]
  }
})
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;index&lt;/code&gt; 错误示例&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;重点在于上面我们所说的会基于 Key 的变化重新排列元素顺序 , 可以看出如果我们用 index 作为 key 数组翻转的时候 , 其实 Key 的顺序是没有变的 , 但是传入的值完全变了 , 这时候原本不一样的数据 , 被误以为一样了 , 所以就造成以下问题 ;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2020/7/24/1737f886ba386ae0?imageslim&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 具体语法稍后介绍; 意思为点击翻转数组 --&amp;gt;
&amp;lt;button @click=&amp;quot;users.reverse()&amp;quot;&amp;gt;年龄排序&amp;lt;/button&amp;gt;
&amp;lt;ul&amp;gt;
  &amp;lt;!-- 循环这个 users 生成一个数据列表 并且里面带有 多选框 以供我们测试 --&amp;gt;
  &amp;lt;li v-for=&amp;quot;(user, index) of users&amp;quot; :key=&amp;quot;index&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;checkbox&amp;quot; /&amp;gt;
    &amp;lt;span&amp;gt;{{ user.uname }}&amp;lt;/span&amp;gt;
  &amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;唯一 Id 正确示例&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;此时的 key 和数据做绑定 , 当你翻转数组的时候 , 绑定的其实是这一条数据 , 而不是索引 , 就不会造成以上问题了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2020/7/24/1737f8894e82c1c8?imageslim&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;li v-for=&amp;quot;(user, index) of users&amp;quot; :key=&amp;quot;user.id&amp;quot;&amp;gt;
  ......
&amp;lt;/li&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt; :&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.im/post/6844904113587634184&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://juejin.im/post/6844904113587634184&#34;&gt;juejin.im/post/684490…&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;v-bind&#34;&gt;&lt;code&gt;v-bind&lt;/code&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;属性绑定 ; 可缩写为 &lt;code&gt;:&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;// 绑定 attrbute
&amp;lt;div v-bind:content=&amp;quot;message&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;

// 绑定 class 
&amp;lt;div :class=&amp;quot;{box: isBox}&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div :class=&amp;quot;[&#39;box&#39;, &#39;box1&#39;]&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div :class=&amp;quot;[&#39;box&#39;, {box1: isBox}]&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;

// 绑定 style
&amp;lt;div :style=&amp;quot;{fontSize: &#39;20px&#39;, color: &#39;white&#39;}&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div :style=&amp;quot;[{fontSize: &#39;20px&#39;}, {color: &#39;white&#39;}]&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;v-on&#34;&gt;&lt;code&gt;v-on&lt;/code&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;事件绑定 ; 可缩写 &lt;code&gt;@&lt;/code&gt; 监听DOM事件 , 并在触发时运行一些 js 代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;button v-on:click=&amp;quot;count += 1&amp;quot;&amp;gt;&amp;lt;/button&amp;gt;
{{ count }}
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;可以接收一个方法名称 ;&lt;/p&gt;
&lt;p&gt;注意 : 当只是一个方法名称时, 默认第一个参数为事件对象 e&lt;/p&gt;
&lt;p&gt;当需要传入参数时 , 那么事件对象就需要手动的传入, 最后一个 并且强制写成 &lt;code&gt;$event&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;button @click=&amp;quot;handle&amp;quot;&amp;gt;点击1&amp;lt;/button&amp;gt;
&amp;lt;button @click=&amp;quot;handle1(&#39;content&#39;, $event)&amp;quot;&amp;gt;点击2&amp;lt;/button&amp;gt;
复制代码

methods: {
  handle(e) {
    console.log(e.target)
  },
  handle1(ct, e) {
  	console.log(ct)
    console.log(e.target)
  }
}
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;事件修饰符&#34;&gt;事件修饰符&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.prevent&lt;/code&gt; : 阻止默认事件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.stop&lt;/code&gt; : 阻止冒泡&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.self&lt;/code&gt; : 只有当前元素触发事件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.once&lt;/code&gt; : 只触发一次该事件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.native&lt;/code&gt; : 监听组件根元素的原生事件&lt;/p&gt;
&lt;p&gt;// 定义子组件&lt;br&gt;
Vue.component(&#39;my-component&#39;, {&lt;br&gt;
template: &lt;code&gt;&amp;lt;button @mousedown=&amp;quot;handle&amp;quot; :style=&amp;quot;{color: &#39;white&#39;, lineHeight: &#39;20px&#39;, backgroundColor: &#39;black&#39;}&amp;quot;&amp;gt;组件&amp;lt;/button&amp;gt;&lt;/code&gt;,&lt;br&gt;
methods: {&lt;br&gt;
handle() {&lt;br&gt;
console.log(&#39;///&#39;)&lt;br&gt;
}&lt;br&gt;
}&lt;br&gt;
})&lt;br&gt;
复制代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;加了 &lt;code&gt;native&lt;/code&gt; 相当于把自定义组件看成了 html 可以直接在上面监听原生事件, 否则自定义组件上面绑定的就是自定义事件 , 而你在自定义事件上没有定义这个事件 , 所以不加 &lt;code&gt;native&lt;/code&gt; 不会执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 父组件中引用
&amp;lt;my-component @click.native=&amp;quot;handle(&#39;父组件&#39;)&amp;quot;&amp;gt;&amp;lt;/my-component&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt; :&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/q/1010000011186651&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://segmentfault.com/q/1010000011186651&#34;&gt;segmentfault.com/q/101000001…&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.capture&lt;/code&gt; : 添加事件监听时 , 使用 捕获模式&lt;/p&gt;
&lt;p&gt;// 此时会优先捕获 box1&lt;/p&gt;
&lt;div class=&#34;box&#34; style=&#34;background: skyblue;  width: 180px;&#34; @click.capture=&#34;handle(&#39;box1&#39;)&#34;&gt;
  &lt;div class=&#34;box1 box&#34; style=&#34;background: slateblue; width: 140px;&#34; @click=&#34;handle(&#39;box2&#39;)&#34;&gt;
    &lt;div class=&#34;box2 box&#34; style=&#34;background: red;&#34; @click=&#34;handle(&#39;box3&#39;)&#34;&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
复制代码
&lt;p&gt;// 允许只有修饰符 prevent 阻止默认事件&lt;br&gt;
&amp;lt;a href=&amp;quot;http://www.baidu.com&amp;quot; @click.prevent &amp;gt;百度&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;// 多个事件修饰符可以连用触发时机也是相同的&lt;br&gt;
&amp;lt;a href=&amp;quot;http://www.baidu.com&amp;quot; @click.prevent.stop=&amp;quot;handle(&#39;a&#39;)&amp;quot;&amp;gt;baidu&lt;/a&gt;&lt;br&gt;
复制代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;按键修饰符&#34;&gt;按键修饰符&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;Vue 中允许为 &lt;code&gt;v-on&lt;/code&gt; 监听键盘事件时添加键盘修饰符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input v-on:keyup.enter=&amp;quot;submit&amp;quot;&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然提供了大多数的按键码别名 按键码&lt;/p&gt;
&lt;p&gt;还可以通过全局 &lt;code&gt;Vue.config.keyCodes&lt;/code&gt; 自定义修饰符别名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Vue.config.keyCodes.f1 = 112
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;v-model&#34;&gt;&lt;code&gt;v-model&lt;/code&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;在表单元素上创建数据双向绑定 , 它会根据控件类型自动选取正确的值来更新元素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;// 文本
&amp;lt;input type=&amp;quot;text&amp;quot; v-model=&amp;quot;message&amp;quot;&amp;gt;
&amp;lt;p&amp;gt;{{ message }}&amp;lt;/p&amp;gt;
复制代码

// 多行文本
&amp;lt;textarea cols=&amp;quot;30&amp;quot; rows=&amp;quot;10&amp;quot; v-model=&amp;quot;message&amp;quot;&amp;gt;&amp;lt;/textarea&amp;gt;
&amp;lt;p&amp;gt;{{ message }}&amp;lt;/p&amp;gt;
复制代码

// 单选框
&amp;lt;input type=&amp;quot;radio&amp;quot; value=&amp;quot;男&amp;quot; v-model=&amp;quot;sex&amp;quot;&amp;gt;男
&amp;lt;input type=&amp;quot;radio&amp;quot; value=&amp;quot;女&amp;quot; v-model=&amp;quot;sex&amp;quot;&amp;gt;女
&amp;lt;p&amp;gt;{{ sex }}&amp;lt;/p&amp;gt;
复制代码

// 单个复选框
&amp;lt;input type=&amp;quot;checkbox&amp;quot; v-model=&amp;quot;checked&amp;quot;&amp;gt;
&amp;lt;p&amp;gt;{{ checked }}&amp;lt;/p&amp;gt;
复制代码

// 多个复选框
&amp;lt;input type=&amp;quot;checkbox&amp;quot; value=&amp;quot;打篮球&amp;quot; v-model=&amp;quot;hobby&amp;quot;/&amp;gt;打篮球
&amp;lt;input type=&amp;quot;checkbox&amp;quot; value=&amp;quot;打皮球&amp;quot; v-model=&amp;quot;hobby&amp;quot;/&amp;gt;打皮球
&amp;lt;input type=&amp;quot;checkbox&amp;quot; value=&amp;quot;打气球&amp;quot; v-model=&amp;quot;hobby&amp;quot;/&amp;gt;打气球
&amp;lt;input type=&amp;quot;checkbox&amp;quot; value=&amp;quot;打棒球&amp;quot; v-model=&amp;quot;hobby&amp;quot;/&amp;gt;打棒球
&amp;lt;p&amp;gt;{{ hobby }}&amp;lt;/p&amp;gt;
复制代码

// 选择框 -&amp;gt; 单选
&amp;lt;select v-model=&amp;quot;selected&amp;quot;&amp;gt;
  &amp;lt;option&amp;gt;javascript&amp;lt;/option&amp;gt;
  &amp;lt;option&amp;gt;html&amp;lt;/option&amp;gt;
  &amp;lt;option&amp;gt;css&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;
&amp;lt;p&amp;gt;{{ selected }}&amp;lt;/p&amp;gt;
复制代码

// 选择框 -&amp;gt; 多选
&amp;lt;select v-model=&amp;quot;selectList&amp;quot; multiple&amp;gt;
  &amp;lt;option&amp;gt;javascript&amp;lt;/option&amp;gt;
  &amp;lt;option&amp;gt;html&amp;lt;/option&amp;gt;
  &amp;lt;option&amp;gt;css&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;
&amp;lt;p&amp;gt;{{ selectList }}&amp;lt;/p&amp;gt;
复制代码

// 实例对象
new Vue({
  el: &#39;#app&#39;,
  data: {
    message: &#39;&#39;, // 多行, 单行文本
    sex: &#39;&#39;, // 单选框
    checked: false, // 复选框单个
    hobby: [], // 复选框多个
    selected: &#39;&#39;, // 选择框 -&amp;gt; 单个
    selectList: [] // 选择框 -&amp;gt; 多个
  }
})
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;修饰符&#34;&gt;修饰符&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.lazy&lt;/code&gt; : 默认情况下 &lt;code&gt;v-model&lt;/code&gt; 在每次的 input 事件触发后将输入框内容进行同步 , 添加 &lt;code&gt;lazy&lt;/code&gt; 修饰符后 , 会变成 change 事件后同步数据&lt;/p&gt;
&lt;input v-model.lazy=&#34;message&#34;&gt;
复制代码
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.number&lt;/code&gt; : 用户输入的值转为数值类型&lt;/p&gt;
&lt;input v-model.number=&#34;age&#34;&gt;
复制代码
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.trim&lt;/code&gt; : 过滤输入框中的左右空白&lt;/p&gt;
&lt;input v-model.trim=&#34;message&#34;&gt;
复制代码
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;vueset&#34;&gt;&lt;code&gt;Vue.set&lt;/code&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;如果在实例创建之后添加新的属性到实例上 , 它不会触发更新视图 怎么理解呢 ?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;data() {
  return {
    info: {
      uname: &#39;zs&#39;
    }
  }
}
mounted() {
  // 此时是不会生效的 , 如果再模块化的开发中还会报错
  this.info.age = 23
}
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;受 ES5 的限制 , Vue 不能检测到对象属性的添加或者删除 , 因为 Vue 在初始化的时候将属性转换为&lt;code&gt;getter&lt;/code&gt; &lt;code&gt;setter&lt;/code&gt; 所以属性必须要在 data 对象上才能让 Vue 转换 , 只有在 data 对象上 才是响应式的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mounted() {
  // 正确写法
  this.$set(this.info, &#39;age&#39;, 23)
}
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Vue.set()&lt;/strong&gt; : 与 &lt;code&gt;this.$set&lt;/code&gt; 没有区别, 一个全局 一个局部 官网说 &lt;code&gt;this.$set&lt;/code&gt; 是 &lt;code&gt;Vue.set&lt;/code&gt; 的一个别名&lt;/p&gt;
&lt;h2 id=&#34;methods&#34;&gt;&lt;code&gt;methods&lt;/code&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;methods 将会被混入到Vue 实例中 , 可以直接通过 vm 实例访问这些方法 , 或者在指令表达式中使用 , 方法中的 &lt;code&gt;this&lt;/code&gt; 自动绑定 Vue 实例&lt;/p&gt;
&lt;p&gt;注意 : methods 中的 方法 不要使用 箭头函数 , 箭头函数中的 &lt;code&gt;this&lt;/code&gt; 指向父级作用域的上下文 , 所以 &lt;code&gt;this&lt;/code&gt; 将不会指向 Vue 实例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;new Vue({
  methods: {
    handle() {
      console.log(this)
    }
  }
})
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;计算属性-computed&#34;&gt;计算属性 &lt;code&gt;computed&lt;/code&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;模板内写表达式固然是很方便的 , 但是你应该明白 , 表达式的初衷是用来计算的 , 比如处理一些字符串 , 时间格式等等 , 如果我们写成方法吧 ! 每次都要去调用 , 那就太麻烦了 , 为此 Vue 提供了 计算属性 computed&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看出每次我们都去调用这个参数 , 感觉很不方便&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;text&amp;quot; v-model.number=&amp;quot;input1&amp;quot;/&amp;gt; + 
&amp;lt;input type=&amp;quot;text&amp;quot; v-model.number=&amp;quot;input2&amp;quot;/&amp;gt; =
&amp;lt;span&amp;gt;{{ getSum() }}&amp;lt;/span&amp;gt;
复制代码

data() {
  return {
    sum: &#39;&#39;,
    input1: &#39;&#39;,
    input2: &#39;&#39;
  }
},
methods: {
  getSum() {
    return this.sum = this.input1 + this.input2
  }
}
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面我们使用计算属性解决 ; 可以看出我们去除了 data 中的 sum 属性 在 computed 中新增了 getSum 函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;text&amp;quot; v-model.number=&amp;quot;input1&amp;quot;/&amp;gt; + 
&amp;lt;input type=&amp;quot;text&amp;quot; v-model.number=&amp;quot;input2&amp;quot;/&amp;gt; =
&amp;lt;span&amp;gt;{{ getSum }}&amp;lt;/span&amp;gt;
复制代码

data() {
  return {
    input1: &#39;&#39;,
    input2: &#39;&#39;
  }
},
computed: {
  getSum() {
    return this.input1 + this.input2
  }
},
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么问题来了 为什么定义了一个函数, 却当成属性执行 ? 其实这个只是简写而已 , 算是一个语法糖 , 每一个计算属性包含 get 和 set 当只有 get 时可以简写为 函数的格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export default {
  computed: {
    getSum: {
      get() {
       // 获取数据
      },
      set(val) {
        // val 是这个计算属性被修改之后的数据  设置数据
      }
    }
  }
}
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例 : 看完这个例子就明白了为什么叫 计算属性了吧&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;text&amp;quot; v-model.number=&amp;quot;input1&amp;quot;/&amp;gt; + 
&amp;lt;input type=&amp;quot;text&amp;quot; v-model.number=&amp;quot;input2&amp;quot;/&amp;gt; =
&amp;lt;span&amp;gt;{{ getSum }}&amp;lt;/span&amp;gt;
&amp;lt;!-- set 函数可以接收这里传递过来的值 --&amp;gt;
&amp;lt;button @click=&amp;quot;getSum = &#39;未知数&#39;&amp;quot;&amp;gt;修改 getSum&amp;lt;/button&amp;gt;
复制代码

computed: {
  getSum: {
    get() {
      return this.input1  + this.input2
    },
    // 接收 getSum 这个属性改变后的值
    set(val) {
      console.log(val)
      this.input1 = 20
      this.input2 = 30
    }
  }
},
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;侦听属性-watch&#34;&gt;侦听属性 &lt;code&gt;watch&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;虽然计算属性在大多数情况下都适用 , 但有时也需要一个自定义的侦听器 , 这个时候就需要 侦听属性 &lt;code&gt;watch&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;仍然是计算两数之和 ; 在 watch 监听了 input1 的属性 input1 触发时 求出 sum ; 仔细看已经出现了问题, 修改 input2 的时候就不会再触发了 ;&lt;/p&gt;
&lt;p&gt;总结 : 它监听 data 某一个属性的变化 , 并不会创造新的属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;text&amp;quot; v-model.number=&amp;quot;input1&amp;quot;/&amp;gt; + 
&amp;lt;input type=&amp;quot;text&amp;quot; v-model.number=&amp;quot;input2&amp;quot;/&amp;gt; =
&amp;lt;span&amp;gt;{{ getSum }}&amp;lt;/span&amp;gt;
复制代码

data() {
  return {
    input1: &#39;&#39;,
    input2: &#39;&#39;,
    getSum: &#39;&#39;
  }
},
watch: {
  // 这样写看着是一个函数, 和属性理解不一致, 当然还可以写成这样
  input1(newVal, oldVal) {
    console.log(newVal, oldVal)
    this.getSum = this.input1 + this.input2
  }
  input2: {
    // 回调函数监听 input2 的变化  函数名必须是 handler
    handler(newVal, oldVal) {
      console.log(newVal, oldVal)
      this.getSum = this.input1 + this.input2
    }
  }
}
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们需要侦听对象属性, 可以在选项参数中使用 &lt;code&gt;deep: true&lt;/code&gt; 注意监听数据的变更不需要这么做&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;watch: {
  obj: {
    handler() {
      // ....
    },
    deep: true 
  }
}
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;watch 使用时有一个特点 , 就是当值第一次绑定的时候 , 不会执行监听函数 , 只有值发生改变时才会执行 , 如果我们需要在最初绑定值的时候也执行函数 , 则需要用到 &lt;code&gt;immediate: true&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;watch: {
  apiData: {
    handler(newVal, oldVal) { },
    deep: true,
    immediate: true
  }
}
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;methods-computed-watch-区别&#34;&gt;methods computed watch 区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;watch&lt;/code&gt; 就是单纯的监听某个数据的变化 , 支持深度监听 , 接收两个参数一个最新值, 一个变化前的旧值 , 结果不会被缓存 , 并且 watch 可以处理异步任务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;computed&lt;/code&gt; 是计算属性, 依赖于某个或者某些属性值 , 计算出来的结果会出现缓存 , 只有当数据的依赖项变化时才会发生变化 , 会创建一个新的属性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;methods&lt;/code&gt; 是函数调用 , 没有缓存 , 主要处理一些业务逻辑, 而不是监听或者计算一些属性&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;过滤器-filter&#34;&gt;过滤器 &lt;code&gt;filter&lt;/code&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;可以被用于一些常见的文本格式化 , 允许被应用在两个地方 &lt;code&gt;{{}}&lt;/code&gt; &lt;code&gt;v-bind&lt;/code&gt; 中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;{{ msg | formatMsg }}
&amp;lt;div v-bind:msg=&amp;quot;msg | formatMsg&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以在组件的选项中定义组件内私有的过滤器&lt;/p&gt;
&lt;p&gt;Vue.component(&#39;son-component&#39;, {&lt;br&gt;
template: &lt;code&gt;&amp;lt;div&amp;gt;{{ msg | formatMsg }}&amp;lt;/div&amp;gt;&lt;/code&gt;,&lt;br&gt;
data() {&lt;br&gt;
return {&lt;br&gt;
msg: &#39;this is message&#39;&lt;br&gt;
}&lt;br&gt;
},&lt;br&gt;
filters: {&lt;br&gt;
formatMsg(msg) {&lt;br&gt;
return msg.toString().toUpperCase()&lt;br&gt;
}&lt;br&gt;
}&lt;br&gt;
})&lt;br&gt;
复制代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以在创建 Vue 实例之前定义全局过滤器&lt;/p&gt;
&lt;p&gt;Vue.filter(&#39;formatMsg&#39;, function(msg) {&lt;br&gt;
return msg.toString().toUpperCase()&lt;br&gt;
})&lt;br&gt;
复制代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;过滤器默认是以 &lt;code&gt;|&lt;/code&gt; 前面的的内容作为过滤器的第一个参数 , 还可以再次传入传输&lt;/p&gt;
&lt;div&gt;{{ msg | formatMsg(&#39;lower&#39;) }}&lt;/div&gt;
复制代码
&lt;p&gt;Vue.filter(&#39;formatMsg&#39;, function(msg, args) {&lt;br&gt;
console.log(msg) // lower&lt;br&gt;
if (args === &#39;lower&#39;) {&lt;br&gt;
return msg.toString().toLowerCase()&lt;br&gt;
}&lt;br&gt;
})&lt;br&gt;
复制代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;自定义指令-directive&#34;&gt;自定义指令 &lt;code&gt;directive&lt;/code&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;与上面提到的指令一致 , 如果那些指令不能满足使用要求 , 可以自己进行定制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自定获取焦点案例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;text&amp;quot; v-focus/&amp;gt;
复制代码

// 全局指令 定义时不需要 v-  调用时要加上 v- 前缀
Vue.directive(&#39;focus&#39;, {
  inserted(el) {
    el.focus()
  }
})
// 或者可以定义为局部
directives: {
  &#39;focus&#39;: {
    inserted(el) {
      el.focus()
    }
  }
}
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;钩子函数&#34;&gt;钩子函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bind&lt;/code&gt; : 只调用一次 , 指令第一次绑定元素时调用 , 在这里可以进行一次性的初始化设置 ;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inserted&lt;/code&gt; : 被绑定元素插入父节点时调用 , 不一定渲染完成 , html 已经创建好了&lt;/li&gt;
&lt;li&gt;&lt;code&gt;update&lt;/code&gt; : 所在组件的 VNode 更新时调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;componentUpdated&lt;/code&gt; : 指令所在的组件的 VNode 全部更新完成后&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unbind&lt;/code&gt; : 指令与元素解绑时调用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;钩子函数参数&#34;&gt;钩子函数参数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;el&lt;/code&gt; : 指令所绑定的元素 , 可以直接操作 DOM&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;binding&lt;/code&gt; : 指令相关的配置对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;modifiers&lt;/code&gt; : 一个包含修饰符的对象 示例 &lt;code&gt;v-drag.limit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt; : 指令名 , 不包含前缀&lt;/li&gt;
&lt;li&gt;&lt;code&gt;value&lt;/code&gt; : 指令绑定的值 &lt;code&gt;v-drag=&amp;quot;true&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div v-drag&gt;
复制代码
&lt;p&gt;// 拖拽方块案例&lt;br&gt;
Vue.directive(&#39;drag&#39;, {&lt;br&gt;
// 初始化样式&lt;br&gt;
bind(el) {&lt;br&gt;
el.style.position = &#39;absolute&#39;&lt;br&gt;
el.style.top = 0&lt;br&gt;
el.style.left = 0&lt;br&gt;
el.style.width = &#39;100px&#39;&lt;br&gt;
el.style.height = &#39;100px&#39;&lt;br&gt;
el.style.background = &#39;skyblue&#39;&lt;br&gt;
el.style.cursor = &#39;pointer&#39;&lt;br&gt;
},&lt;br&gt;
// 元素对象存在后, 开始写拖动逻辑&lt;br&gt;
inserted(el, binding) {&lt;br&gt;
let draging = false&lt;br&gt;
let elLeft = 0&lt;br&gt;
let elRight = 0&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;document.addEventListener(&#39;mousedown&#39;, function (e) {
  draging = true
  let move = el.getBoundingClientRect()
  elLeft = e.clientX - move.left
  elRight = e.clientY - move.top  
})
document.addEventListener(&#39;mousemove&#39;, function (e) {
  let moveX = e.clientX - elLeft
  let moveY = e.clientY - elRight
  
  if (draging) {
    el.style.left = moveX + &#39;px&#39;
    el.style.top = moveY + &#39;px&#39;
  }
})
document.addEventListener(&#39;mouseup&#39;, function () {
  draging = false
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;br&gt;
})&lt;br&gt;
复制代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;自定义指令修饰符&#34;&gt;自定义指令修饰符&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;相信大家仔细看上面的代码可能会发现这个方格拖拽还存在一些问题 ; 它还是可以拖拽到可视区域之外的 , 那么可不可以传递一个修饰符 , 来告诉他呢 ? 这时候就需要用到 binding 这个指令配置相关的对象了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;// 我们先传入修饰符 limit 为自己定义的修饰符
&amp;lt;div v-drag.limit&amp;gt;
复制代码

// 既然不想让他拖拽出视口, 那么就应该在鼠标移动的时候加入一些逻辑
document.addEventListener(&#39;mousemove&#39;, function (e) {
  let moveX = e.clientX - elLeft
  let moveY = e.clientY - elRight
  
  // 是否传入了修饰符 limit 为什么这样可以获取 下面就上截图
  if (binding.modifiers.limit) {
    moveX = moveX &amp;lt;= 0 ? moveX = 0 : moveX   
    moveY = moveY &amp;lt;= 0 ? moveY = 0 : moveY
  }
  if (draging) {
    el.style.left = moveX + &#39;px&#39;
    el.style.top = moveY + &#39;px&#39;
  }
  console.log(binding) // binding 对象
})
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;![](https://juejin.cn/post/data:image/svg+xml;utf8,&lt;?xml version=&#34;1.0&#34;?&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; version=&#34;1.1&#34; width=&#34;700&#34; height=&#34;234&#34;&gt;&lt;/svg&gt;)&lt;/p&gt;
&lt;h3 id=&#34;自定义指令传参&#34;&gt;自定义指令传参&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;上面我们已经解决了拖出视口的问题 , 只要传递一个修饰符就解决了 , 那么现在我们希望可以手动的暂停拖拽 , 当然也是可行的 ;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div v-drag.limit=&amp;quot;{isDrag: false}&amp;quot;&amp;gt;
复制代码

document.addEventListener(&#39;mousemove&#39;, function (e) {
  let moveX = e.clientX - elLeft
  let moveY = e.clientY - elRight
  
  // 是否传入了修饰符 limit
  if (binding.modifiers.limit) {
    moveX = moveX &amp;lt;= 0 ? moveX = 0 : moveX   
    moveY = moveY &amp;lt;= 0 ? moveY = 0 : moveY
  }
  // 是否传入 isDrag 判断是否可滑动
  if (!binding.value.isDrag) return
  if (draging) {
    el.style.left = moveX + &#39;px&#39;
    el.style.top = moveY + &#39;px&#39;
  }
})
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;![](https://juejin.cn/post/data:image/svg+xml;utf8,&lt;?xml version=&#34;1.0&#34;?&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; version=&#34;1.1&#34; width=&#34;784&#34; height=&#34;254&#34;&gt;&lt;/svg&gt;)&lt;/p&gt;
&lt;h2 id=&#34;组件&#34;&gt;组件&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;通常一个组件会以一棵嵌套的组件数的形式来组织 ; 为了能在模板中使用 , 这些组件必须先注册以便 vue 能够识别 ;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;![](https://juejin.cn/post/data:image/svg+xml;utf8,&lt;?xml version=&#34;1.0&#34;?&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; version=&#34;1.1&#34; width=&#34;1280&#34; height=&#34;495&#34;&gt;&lt;/svg&gt;)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;全局组件&lt;/p&gt;
&lt;p&gt;Vue.component(&#39;GlobalComponent&#39;, {&lt;br&gt;
template: &lt;code&gt;&amp;lt;div&amp;gt; hello component &amp;lt;/div&amp;gt;&lt;/code&gt;&lt;br&gt;
})&lt;br&gt;
复制代码&lt;/p&gt;
&lt;p&gt;// 命名时推荐驼峰 , 调用时推荐 - 链接, html 不识别大小写&lt;br&gt;
&lt;global-component&gt;&lt;/global-component&gt;&lt;br&gt;
复制代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;局部组件&lt;/p&gt;
&lt;p&gt;new Vue({&lt;br&gt;
el: &#39;#app&#39;,&lt;br&gt;
components: {&lt;br&gt;
SonComponent: {&lt;br&gt;
template: &lt;code&gt;&amp;lt;div&amp;gt;hello private component&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;br&gt;
}&lt;br&gt;
}&lt;br&gt;
})&lt;br&gt;
复制代码&lt;/p&gt;
&lt;p&gt;// 组件可以被复用多次&lt;br&gt;
&lt;private-component&gt;&lt;/private-component&gt;&lt;br&gt;
&lt;private-component&gt;&lt;/private-component&gt;&lt;br&gt;
&lt;private-component&gt;&lt;/private-component&gt;&lt;br&gt;
复制代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模块化开发中的组件&lt;/p&gt;
&lt;p&gt;import SonComponent from &#39;@/components/SonComponent.vue&#39;&lt;/p&gt;
&lt;p&gt;export default {&lt;br&gt;
components: {&lt;br&gt;
SonComponent&lt;br&gt;
}&lt;br&gt;
}&lt;br&gt;
复制代码&lt;/p&gt;
&lt;p&gt;&lt;son-component&gt;&lt;/son-component&gt;&lt;br&gt;
复制代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;通过-props-向子组件传递数据&#34;&gt;通过 &lt;code&gt;props&lt;/code&gt; 向子组件传递数据&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;prop 是组件上一些自定义的 attribute , 当一个值传递给一个 prop attribute 的时候 , 它就变成那个组件实例的 property ;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;// 父组件
&amp;lt;div&amp;gt;
  &amp;lt;son-component content=&amp;quot;传递给子组件的数据, 如果动态传值可以加 v-bind&amp;quot;&amp;gt;&amp;lt;/son-component&amp;gt;
&amp;lt;/div&amp;gt;
复制代码

// 子组件
Vue.component(&#39;SonComponent&#39;, {
   // 多个单词可以是驼峰式, 但是父组件传递时多个单词必须是 - 连接
   // props 中的值, 可以像 data 中的数据一样访问  this.content / {{ content }} 
   // props 是只读的 切记不要修改 会报错
   props: [&#39;content&#39;],
   template: `&amp;lt;div&amp;gt; {{ content }} &amp;lt;/div&amp;gt;`
})
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;props 可以是数组也可以是一个对象 , 用来接收来自父组件的数据 ;&lt;/p&gt;
&lt;p&gt;对象允许配置高级选项 , 如类型检测等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;type&lt;/code&gt; : 可以是 &lt;code&gt;Number&lt;/code&gt; &lt;code&gt;String&lt;/code&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;code&gt;Array&lt;/code&gt; &lt;code&gt;Object&lt;/code&gt; &lt;code&gt;Date&lt;/code&gt; &lt;code&gt;Function&lt;/code&gt; 任何自定义构造函数 , 或上述内容组成的数组 , 会检查一个 prop 是否是给定的类型 , 否则抛出异常&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;default&lt;/code&gt; : 默认值 , 对象或者数组的默认值必须从一个工厂函数中返回&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;required&lt;/code&gt; : boolean 是否为必填项&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;validator&lt;/code&gt; : Function 自定义验证函数会将 prop 的值作为唯一的参数传入&lt;/p&gt;
&lt;p&gt;props: {&lt;br&gt;
content: {&lt;br&gt;
type: String,&lt;br&gt;
// default: 0, 普通值可直接默认返还&lt;br&gt;
default: () =&amp;gt; [1, 2, 3],&lt;br&gt;
required: true,&lt;br&gt;
// 如果传进来的 content 长度大于 20 就会报错&lt;br&gt;
validator: (value) =&amp;gt; value.length &amp;gt;= 20&lt;br&gt;
}&lt;br&gt;
}&lt;br&gt;
复制代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;监听子组件事件-emit&#34;&gt;监听子组件事件 &lt;code&gt;$emit&lt;/code&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有些时候 , 父组件需要用的子组件中特定的值时 , 可以使用 &lt;code&gt;$emit&lt;/code&gt; 把这个值传递出去&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;行内模式传值&lt;/p&gt;
&lt;p&gt;// 子组件&lt;br&gt;
&lt;template&gt;&lt;/p&gt;
  &lt;div class=&#34;son&#34;&gt;
    // $emit 第一个参数自定义事件, 第二个及以后是传递的数据
    &lt;button @click=&#34;$emit(son-com, [1, 2, 3])&#34;&gt;&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
复制代码
&lt;p&gt;// 父组件&lt;br&gt;
// 监听子组件定义的自定义事件 , 通过 $event 访问第一个传递的参数&lt;br&gt;
&amp;lt;son-component @son-com=&amp;quot;msg = $event&amp;quot;&amp;gt;&lt;/son-component&gt;&lt;br&gt;
复制代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事件处理函数传值&lt;/p&gt;
&lt;p&gt;// 子组件&lt;br&gt;
&lt;template&gt;&lt;/p&gt;
  &lt;div class=&#34;son&#34;&gt;
    &lt;button @click=&#34;sonHandle&#34;&gt;&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  methods: {
    sonHandle() {
      this.$emit(&#39;son-com&#39;, &#39;需要传递的值&#39;)
    }
  }
}
&lt;/script&gt;
复制代码
&lt;p&gt;// 父组件&lt;br&gt;
&lt;template&gt;&lt;/p&gt;
  &lt;div class=&#34;parent&#34;&gt;
    &lt;son-component @son-com=&#34;parentHandle&#34;&gt;&lt;/son-component&gt;
    // 显示传入其他参数的话 必须使用 $event 接收子组件传递过来的值
    &lt;son-component @son-com=&#34;parent(&#39;显示传入参数&#39;, $event)&#34;&gt;&lt;/son-component&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  methods: {
    // 默认第一个值就是传递过来的参数
    parentHandle(arg) {
      	console.log(arg) // 需要传递的值
    },
    // 对应传入参数的位置
    parent(params, arg) {
      console.log(params) // 显示传入参数
      console.log(arg) // 需要传递的值
    }
  }
}
&lt;/script&gt;
复制代码
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事件处理函数传递多个值&lt;/p&gt;
&lt;p&gt;// 子组件&lt;br&gt;
&lt;template&gt;&lt;/p&gt;
  &lt;div class=&#34;son&#34;&gt;
    &lt;button @click=&#34;sonHandle&#34;&gt;&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  methods: {
    sonHandle(event) {
      // 事件对象可以在任意位置 , 放到前面相对比较好接收
      this.$emit(&#39;son-com&#39;, event, &#39;需要传递的值&#39;, &#39;需要传递的第二个值&#39;)
    }
  }
}
&lt;/script&gt;
复制代码
&lt;p&gt;// 父组件&lt;br&gt;
&lt;template&gt;&lt;/p&gt;
  &lt;div class=&#34;son&#34;&gt;
    &lt;button @son-com=&#34;parent&#34;&gt;&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  methods: {
    parent(event, ...args) {
      console.log(event)
      // 如果不想使用剩余参数, 也可以多传递参数逐个使用
      console.log(args)
    }
  }
}
&lt;/script&gt;
复制代码
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;组件上使用-v-model&#34;&gt;组件上使用 &lt;code&gt;v-model&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;在使用这个功能之前我们需要先了解一个东西 , &lt;code&gt;v-model&lt;/code&gt; 究竟是什么 ; 其实它从某种程度来说就是一个语法糖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;text&amp;quot; v-model=&amp;quot;msg&amp;quot;/&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;等价于&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input :value=&amp;quot;msg&amp;quot; @input=&amp;quot;msg = $event.target.value&amp;quot;/&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应用到组件中就是下面这样 为了不引起歧义, 我把自定义的事件以及属性加了test 前缀详情看[官网](https://cn.vuejs.org/v2/guide/components.html target=)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 父组件
&amp;lt;model-input 
  :test-value=&amp;quot;searchText&amp;quot; 
  @test-input=&amp;quot;searchText = $event&amp;quot;
  &amp;gt;
&amp;lt;/model-input&amp;gt; 
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;子组件的 result 必须绑定到 value 上面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在这个 input 触发的时候 通过 &lt;code&gt;$emit&lt;/code&gt; 将自定义的 test-input 在暴露出去&lt;/p&gt;
&lt;p&gt;// 子组件&lt;br&gt;
&amp;lt;input&lt;br&gt;
type=&amp;quot;text&amp;quot;&lt;br&gt;
v-bind:value=&amp;quot;testValue&amp;quot;&lt;br&gt;
@input=&amp;quot;$emit(&#39;test-input&#39;, $event.target.value)&amp;quot;&lt;/p&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;p&gt;// script&lt;br&gt;
props: [&#39;testValue&#39;] // 自定义属性传递过来的值&lt;br&gt;
复制代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此时我们再优化一下 , 使用 &lt;code&gt;v-model&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 父组件
&amp;lt;model-input v-model=&amp;quot;searchText&amp;quot;&amp;gt;&amp;lt;/model-input&amp;gt; 
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于我们组件中使用了 v-model 而前面我们也提到了 v-model 其实是 v-bind 和 v-on 的语法糖 , 所以只能用 value 属性和 input 事件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 子组件
&amp;lt;input
  type=&amp;quot;text&amp;quot;
  v-bind:value=&amp;quot;value&amp;quot;
  @input=&amp;quot;$emit(&#39;input&#39;, $event.target.value)&amp;quot;
&amp;gt;
// script
props: [&#39;value&#39;] 
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;那么问题来了 , 上面我们提过 v-model 默认是 value属性 和 input事件 , 但是像单选框 , 复选框等类型怎么处理 ? 对此 Vue 提供了 &lt;code&gt;model&lt;/code&gt; 选项来避免这样的冲突&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;单个复选框组件绑定&#34;&gt;单个复选框组件绑定&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// 父组件
&amp;lt;model-input v-model=&amp;quot;isChecked&amp;quot;&amp;gt;&amp;lt;/model-input&amp;gt;

// script
data() {
  return {
    isChecked: false
  }
},
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选中 和 未选中 返回 true / false&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 子组件
&amp;lt;input
  type=&amp;quot;checkbox&amp;quot;
  v-bind:checked=&amp;quot;checked&amp;quot;
  @change=&amp;quot;$emit(&#39;change&#39;, $event.target.checked)&amp;quot;
&amp;gt;
// script

export default {
  name: &#39;ModelInput&#39;,
  // v-model 拆分
  model: {
    prop: &#39;checked&#39;, // 将传进来的 isChecked 变成 checked 供后面的 props 使用
    event: &#39;change&#39; //  定义 emit 自定义的事件名字
  },
  props: {
    checked: {
      type: Boolean
    }
  }
}
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;组件插槽&#34;&gt;组件插槽&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在 2.6.0 中 为具名插槽和作用域插槽提供了新的统一语法 &lt;code&gt;v-slot&lt;/code&gt; 它取代了 &lt;code&gt;slot&lt;/code&gt; 和 &lt;code&gt;slot-scope&lt;/code&gt; 这两个目前已被废弃 , 但是还没有移除 (仍然可以使用)&lt;/p&gt;
&lt;p&gt;插槽 : 简单理解就是 占坑 在组件模板中占好位置 , 当使用该组件的标签时 , 组件标签的内容就会自动填坑 , ( 替换组件模板中的 &lt;code&gt;slot&lt;/code&gt; 位置 ) , 并且可以作为承载分发内容的出口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;内容插槽&#34;&gt;内容插槽&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// 子组件
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;这是组件的头部&amp;lt;/p&amp;gt;
    &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;
    &amp;lt;p&amp;gt;这是组件的尾部&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
复制代码

// 父组件
&amp;lt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;!-- 插槽内可以是任何内容 组件,文本,标签--&amp;gt;
    &amp;lt;slot-test&amp;gt;
      &amp;lt;p&amp;gt;这是插槽的内容&amp;lt;/p&amp;gt;
    &amp;lt;/slot-test&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;规则 :&lt;/strong&gt; 父级模板里的所有内容都是在父级作用域中编译的 ; 子模板的所有内容都在子作用域中编译&lt;/p&gt;
&lt;h3 id=&#34;默认内容插槽&#34;&gt;默认内容插槽&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 标签内可以加入 组件, 文本, 标签等默认内容 , 如果父组件调用时, 没有传入内容, 那么就会展示默认的内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;// 子组件
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;这是组件的头部&amp;lt;/p&amp;gt;
    &amp;lt;slot&amp;gt;我是默认内容&amp;lt;/slot&amp;gt;
    &amp;lt;p&amp;gt;这是组件的尾部&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;具名插槽&#34;&gt;具名插槽&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有些时候一个插槽是不能满足需求的 , 我们可能需要多个 ; 对于这种情况 , &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 元素中有一个特殊的 attribute &lt;code&gt;name&lt;/code&gt; 这个 attribute 用来定义额外的插槽&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;// 子组件
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;header&amp;gt;
      &amp;lt;slot name=&amp;quot;header&amp;quot;&amp;gt;&amp;lt;/slot&amp;gt;
    &amp;lt;/header&amp;gt;
    &amp;lt;main&amp;gt;
      &amp;lt;!-- 如果没有指定 name 默认的 name 为default --&amp;gt;
      &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;
    &amp;lt;/main&amp;gt;
    &amp;lt;footer&amp;gt;
      &amp;lt;slot name=&amp;quot;footer&amp;quot;&amp;gt;&amp;lt;/slot&amp;gt;
    &amp;lt;/footer&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;在向具名插槽提供内容的时候 , 可以在一个 &lt;code&gt;template&lt;/code&gt; 元素中上 使用&lt;code&gt;v-slot&lt;/code&gt; 指令 并以参数的形式提供名称&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;// 父组件
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
	&amp;lt;slot-test&amp;gt;
	  &amp;lt;template v-slot:header&amp;gt; 我是 header 内容 &amp;lt;/template&amp;gt;
      我是 没有指定 name 的内容 &amp;lt;!-- 或者也可以写成下面的内容 --&amp;gt;
      &amp;lt;template v-slot:default&amp;gt; 没有指定 name 的内容 &amp;lt;/template&amp;gt;
      &amp;lt;template v-slot:footer&amp;gt; 我是 footer 内容 &amp;lt;/template&amp;gt;
	&amp;lt;/slot-test&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 中的所有内容都会传入响应的插槽 , 任何没有包裹在带有 &lt;code&gt;v-slot&lt;/code&gt; 的 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 中的内容都会被视为默认插槽的内容 ; 通俗一点来说 , 就是我在子组件中声明了多个 没有 &lt;code&gt;name&lt;/code&gt; 的 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; , 那么 我在父组件中 , 只需要渲染一次 , 所有子组件的插槽就都会被渲染 ;&lt;/p&gt;
&lt;p&gt;注意 : &lt;code&gt;v-slot&lt;/code&gt; 只能添加在 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 上 , 还有一种特殊情况后面会说&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;具名插槽缩写&#34;&gt;具名插槽缩写&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;v-slot:&lt;/code&gt; 替换为 &lt;code&gt;#&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意 ： 只有带参数时可以使用 ， 其他情况下是无效的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;// 子组件
&amp;lt;div&amp;gt;
  &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;
&amp;lt;/div&amp;gt;
复制代码

/* 父组件 */

// 错误示例
&amp;lt;slot-test&amp;gt;
  &amp;lt;template #&amp;gt;
    &amp;lt;!-- 内容。。。。--&amp;gt;
  &amp;lt;/template&amp;gt;
&amp;lt;/slot-test&amp;gt;

// 正确示例
&amp;lt;slot-test&amp;gt;
  &amp;lt;template #default&amp;gt;
    &amp;lt;!-- 内容。。。。--&amp;gt;
  &amp;lt;/template&amp;gt;
&amp;lt;/slot-test&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;作用域插槽&#34;&gt;作用域插槽&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;从某种意义上来说 , 插槽是子组件高可用 , 高定制化的一种手段 , 那么我们肯定会碰到插槽内容 , 需要访问子组件中数据的情况 ;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以通过 &lt;code&gt;v-bind&lt;/code&gt; 把需要传递的值 绑定到 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 上 , 然后在 父组件中 使用 &lt;code&gt;v-slot&lt;/code&gt; 设置一个值来定义提供插槽的名字&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 子组件
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
	&amp;lt;slot name=&amp;quot;userInfo&amp;quot; :user=&amp;quot;userInfo&amp;quot;&amp;gt;&amp;lt;/slot&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
  data() {
    return {
      userInfo: {
        firstName: &#39;firstName&#39;,
        lastName: &#39;lastName&#39;
      }
    }
  }
}
&amp;lt;/script&amp;gt;
复制代码

// 父组件
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;slot-test&amp;gt;
      &amp;lt;!-- 如果只有一个插槽可以吧 v-slot 写到 组件上面 具体看下面--&amp;gt;
      &amp;lt;template v-slot:userInfo=&amp;quot;slotProps&amp;quot;&amp;gt;
        {{ slotProps.user.firstName }}
      &amp;lt;/template&amp;gt;
    &amp;lt;/slot-test&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;独占默认插槽缩写语法&#34;&gt;独占默认插槽缩写语法&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;当被提供的内容只有默认插槽时 , 组件的标签才可以当做插槽的模板使用 , 这样我们就可以把 &lt;code&gt;v-slot&lt;/code&gt; 直接用在组件上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;// 子组件
&amp;lt;div&amp;gt;
  &amp;lt;slot :user=&amp;quot;userInfo&amp;quot;&amp;gt;&amp;lt;/slot&amp;gt;
&amp;lt;/div&amp;gt;

// 组件数据
data(){
  return {
    userInfo: {
      firstName: &#39;firstName&#39;,
      lastName: &#39;lastName&#39;
    }
  }
}
复制代码

// 父组件
&amp;lt;div&amp;gt;
  &amp;lt;slot-test v-slot=&amp;quot;slotProps&amp;quot;&amp;gt;
    {{ slotProps.user.firstName }}
  &amp;lt;/slot-test&amp;gt;
&amp;lt;/div&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;不要尝试插槽的 &amp;quot;缩写语法&amp;quot; 和 &amp;quot;具名插槽混用&amp;quot; 会导致作用域不明确&lt;/li&gt;
&lt;li&gt;只要出现多个插槽 , 需要始终为所有的插槽使用 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 语法&lt;/li&gt;
&lt;li&gt;参考官网 : [默认插槽](https://cn.vuejs.org/v2/guide/components-slots.html target=)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;解构插槽-prop&#34;&gt;解构插槽 &lt;code&gt;Prop&lt;/code&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;插槽支持通过 ES6 结构传入具体的插槽 prop 至于原理 ;&lt;/p&gt;
&lt;p&gt;官网说 : 作用域插槽内部原理是将你的插槽内容包括在一个传入单个参数的函数里 ; 没有听懂 😂 自身档次还不够， 还是看看怎么用的吧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;
  &amp;lt;slot-test v-slot=&amp;quot;{ user }&amp;quot;&amp;gt;
    {{ user.firstName }}
  &amp;lt;/slot-test&amp;gt;
&amp;lt;/div&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在提供多个 prop 的时候 ，它同样开启了 prop 重命名的功能&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;
  &amp;lt;slot-test v-slot=&amp;quot;{ user: preson }&amp;quot;&amp;gt;
    {{ preson.firstName }}
  &amp;lt;/slot-test&amp;gt;
&amp;lt;/div&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;插槽其他示例&#34;&gt;插槽其他示例&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;插槽 prop 允许我们将插槽转换为可复用的模板 ， 这些模板可以基于输入不同的 prop 渲染出不同的内容；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如我们设计一个 &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; 组件 ，它是一个列表且包含一定的逻辑&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 子组件
&amp;lt;template&amp;gt;
  &amp;lt;ul&amp;gt;
    &amp;lt;li v-for=&amp;quot;item in list&amp;quot; :key=&amp;quot;item.id&amp;quot;&amp;gt;
      &amp;lt;!-- 这里把控制逻辑交出去，由父组件去控制一定的逻辑 --&amp;gt;
      &amp;lt;slot name=&amp;quot;todo&amp;quot; :item=&amp;quot;item&amp;quot;&amp;gt;
        {{ item.uname }}
      &amp;lt;/slot&amp;gt;
    &amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/template&amp;gt;
// 数据
[
  {id: 1, uname: &#39;zs&#39;},
  {id: 2, uname: &#39;ls&#39;},
  {id: 3, uname: &#39;we&#39;},
  {id: 4, uname: &#39;mz&#39;},
]
复制代码

// 父组件
&amp;lt;test v-slot:todo=&amp;quot;slotProps&amp;quot;&amp;gt;
  &amp;lt;!-- 本来是显示名字的改成了显示id --&amp;gt;
  {{ slotProps.item.id }}
&amp;lt;/test&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;动态组件-component&#34;&gt;动态组件 &lt;code&gt;component&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;在说动态组件之前， 先动手实现一个 tab 分页，不然貌似不是很好理解 😂&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 模板
&amp;lt;div&amp;gt;
  &amp;lt;button @click=&amp;quot;handle(&#39;post&#39;)&amp;quot; :style=&amp;quot;{background: !isShow ? &#39;red&#39; : &#39;&#39;}&amp;quot;&amp;gt;post&amp;lt;/button&amp;gt;
  &amp;lt;button @click=&amp;quot;handle(&#39;list&#39;)&amp;quot; :style=&amp;quot;{background: isShow ? &#39;red&#39; : &#39;&#39;}&amp;quot;&amp;gt;list&amp;lt;/button&amp;gt;
  &amp;lt;item-post v-show=&amp;quot;!isShow&amp;quot;&amp;gt;&amp;lt;/item-post&amp;gt;
  &amp;lt;item-list v-show=&amp;quot;isShow&amp;quot;&amp;gt;&amp;lt;/item-list&amp;gt;
&amp;lt;/div&amp;gt;

// script
import ItemPost from &#39;@/components/ItemPost.vue&#39;
import ItemList from &#39;@/components/ItemList.vue&#39;

export default {
  name: &#39;Home&#39;,
  components: {
    ItemPost,
    ItemList
  },
  data() {
    return {
      isShow: true
    }
  },
  methods: {
    handle(title) {
      title === &#39;list&#39; ? this.isShow = true : this.isShow = false
    }
  }
}
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;![](https://juejin.cn/post/data:image/svg+xml;utf8,&lt;?xml version=&#34;1.0&#34;?&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; version=&#34;1.1&#34; width=&#34;830&#34; height=&#34;396&#34;&gt;&lt;/svg&gt;)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可以看出上面我们写了两个小组件，做了一个简易的 tab 选项卡 ；&lt;/p&gt;
&lt;p&gt;重点可以看我们引入组件的方式；就是简单的在模板中应用；常规操做；现在只引入两个标签还好，那如果三五十来个就显得有点麻烦了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;动态组件应用&#34;&gt;动态组件应用&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有了动态组件之后， 类似这种简易的 tab 切换我们就不需要再模板中使用这么多的组件标签了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看代码示例， 我们只需要 template 中引入组件的部分 以及在 script 中的 data 新增一个属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 每次点击 button 的时候触发 handle事件函数时 is绑定的值会重新渲染组件 --&amp;gt;
&amp;lt;component :is=&amp;quot;showWhat&amp;quot;&amp;gt;&amp;lt;/component&amp;gt;
复制代码

data() {
  return {
    showWhat: &#39;ItemPost&#39;,
    isShow: true
  }
},
methods: {
  handle(title) {
    // 这里同时控制了切换之后 active 的样式，所以就不删了
    title === &#39;list&#39; ? this.isShow = true : this.isShow = false
    // 加一层判断切换逻辑
    title === &#39;list&#39; ? this.showWhat = &#39;ItemList&#39; : this.showWhat = &#39;ItemPost&#39;
  }
}
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;![](https://juejin.cn/post/data:image/svg+xml;utf8,&lt;?xml version=&#34;1.0&#34;?&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; version=&#34;1.1&#34; width=&#34;830&#34; height=&#34;396&#34;&gt;&lt;/svg&gt;)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里就出现了一些问题， 虽然我们完成了 组件之间的切换，但是关于 input 的选中状态我们没有保留下来，&lt;strong&gt;原因是每次切换的时候，Vue 都会创建一个新的 &lt;code&gt;showWhat&lt;/code&gt; 实例&lt;/strong&gt; 重新创建动态组件的行为通常来说还是非常有用的，但是在我们这个案例中，更希望它能够保留下来 为了解决这个问题，Vue 中提供了一个内置元素 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 只需要将该元素把组件包裹起来即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 失活的 tab 将会被缓存 --&amp;gt;
&amp;lt;keep-alive&amp;gt;  
  &amp;lt;component :is=&amp;quot;showWhat&amp;quot;&amp;gt;&amp;lt;/component&amp;gt;
&amp;lt;/keep-alive&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;异步组件&#34;&gt;异步组件&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在大型应用中， 我们可能需要将应用中分割成小一些的代码块，并且只在需要的时候，再次加载这个模块；道理和 webpack 的按需加载是一样的；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里先创建一个简单的组件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;这是一个简单的组件&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在主组件内常规引入看下效果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;dynamic&amp;gt;&amp;lt;/dynamic&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
import Dynamic from &#39;@/component/Dynamic.vue&#39;

export default {
  name: &#39;Home&#39;,
  components: {
    Dynamic
  }
}
&amp;lt;/script&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看下图， 上面的书写方式，加载出来的组件，会被全部渲染到一个文件里面，如果我们的这个页面组件很多，或者说有些组件，只有触发了特定操作后才会显示，我们是不是就没有必要在页面渲染时，就把所有的组件全部加载呢 ？&lt;/p&gt;
&lt;p&gt;![](https://juejin.cn/post/data:image/svg+xml;utf8,&lt;?xml version=&#34;1.0&#34;?&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; version=&#34;1.1&#34; width=&#34;827&#34; height=&#34;470&#34;&gt;&lt;/svg&gt;)&lt;/p&gt;
&lt;h3 id=&#34;异步组件示例&#34;&gt;异步组件示例&lt;/h3&gt;
&lt;p&gt;根据上面的例子，我们修改一下 script 部分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export default {
  components: {
    // script 头部的导入， 直接在组件内导入
    Dynamic: () =&amp;gt; import Dynamic from &#39;@/component/Dynamic.vue&#39;
  }
}
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出下图多出了 &lt;code&gt;0.js&lt;/code&gt; 由此可见 vue-cli 帮助我们分开打包了文件；这个文件在被加载之后，就会被缓存起来；这个例子只是看出了它被拆开了，并不能证明咱们开始说的按需渲染的道理；基于这个例子可以再改一下，加一个判断逻辑&lt;/p&gt;
&lt;p&gt;![](https://juejin.cn/post/data:image/svg+xml;utf8,&lt;?xml version=&#34;1.0&#34;?&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; version=&#34;1.1&#34; width=&#34;931&#34; height=&#34;498&#34;&gt;&lt;/svg&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    // 就是增加一个按钮，点击控制，这里就给大家简化了
    &amp;lt;dynamic  v-if=&amp;quot;isShow&amp;quot;&amp;gt;&amp;lt;/dynamic&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下图可以看出没有显示子组件时， 把这个文件给缓存起来了，只有真正调用到的时候才会加载对应的资源；&lt;/p&gt;
&lt;p&gt;![](https://juejin.cn/post/data:image/svg+xml;utf8,&lt;?xml version=&#34;1.0&#34;?&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; version=&#34;1.1&#34; width=&#34;1015&#34; height=&#34;549&#34;&gt;&lt;/svg&gt;)&lt;/p&gt;
&lt;p&gt;当然这只是其中一个功能，比如网络不好的时候，组件加载的用户体验会受到损害，超时的处理等等；具体配置参考 vue 官网 ： [处理加载状态](https://cn.vuejs.org/v2/guide/components-dynamic-async.html target=)&lt;/p&gt;
&lt;h2 id=&#34;访问子组件实例或子元素-ref&#34;&gt;访问子组件实例或子元素 &lt;code&gt;ref&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;尽管存在 prop 和事件 , 有的时候你扔可能需要再 JavaScript 中直接访问一个子组件 , 为了达到这个目的你可以使用 &lt;code&gt;ref&lt;/code&gt; 这个属性为子组件赋予一个 id 引用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 模板
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;item-list ref=&amp;quot;itemRef&amp;quot;&amp;gt;&amp;lt;/item-list&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; ref=&amp;quot;inputRef&amp;quot;/&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
// script
export default {
  mounted() {
    // 子组件的实例对象
    console.log(this.$refs.itemRef)
    // 元素的实例对象, 可以操作 dom
    console.log(this.$refs.inputRef)
  }
}
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果 ref 和 v-for 一起使用的话 , 那么 &lt;code&gt;this.refs&lt;/code&gt; 将会得到一个元素数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
  &amp;lt;li v-for=&amp;quot;user of userList&amp;quot; :key=&amp;quot;user.id&amp;quot; :style=&amp;quot;{listStyle: &#39;none&#39;}&amp;quot; ref=&amp;quot;forRef&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;checkbox&amp;quot; /&amp;gt;
    {{ user.id }} --- {{ user.uname }} --- {{ user.age }}
  &amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;

mounted() {
  console.log(this.$refs.forRef)
}
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$refs&lt;/code&gt; 只会在组件渲染完成后生效 , 并且它不是响应式的 , 这仅作为用于直接操作子组件的 逃生舱 应该尽量避免在模板或者计算属性中访问 &lt;code&gt;$refs&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;组件生命周期&#34;&gt;组件生命周期&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;每个 Vue 实例创建时都需要经过一系列的初始化 ; 开始创建 , 初始化数据 , 编译模板, 挂载DOM , 更新 , 渲染 , 卸载等一系列过程 , 成为 生命周期 , 同时在这些过程中也会运行一些叫做生命周期钩子的函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;beforeCreate&lt;/code&gt; : &lt;strong&gt;创建前&lt;/strong&gt; 实例初始化之后，this指向创建的实例，不能访问到&lt;code&gt;data&lt;/code&gt;、&lt;code&gt;computed&lt;/code&gt;、&lt;code&gt;watch&lt;/code&gt;、&lt;code&gt;methods&lt;/code&gt;上的方法和数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;created&lt;/code&gt; : &lt;strong&gt;创建后&lt;/strong&gt; 实例创建完成 , 可以访问 &lt;code&gt;data&lt;/code&gt; &lt;code&gt;computed&lt;/code&gt; &lt;code&gt;watch&lt;/code&gt; &lt;code&gt;methods&lt;/code&gt; 数据 , 没有渲染进 浏览器 无法访问 DOM ; &lt;strong&gt;注意 :&lt;/strong&gt; 这个生命周期内发送 ajax 请求 是没有什么方法对实例化过程进行拦截的 , 因此加入某些数据必须获取之后才能进入这个页面的话 , 并不适合在这个方法内完成 , 建议使用 &lt;code&gt;beforeRouterEnter&lt;/code&gt; 路由钩子中完成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;beforeMount&lt;/code&gt; : &lt;strong&gt;挂载前&lt;/strong&gt; 挂载开始之前调用 , &lt;code&gt;beforeMount&lt;/code&gt; 之前会找到对应的 template 编译成 render 函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;mounted&lt;/code&gt; : &lt;strong&gt;挂载后&lt;/strong&gt; 实例挂载到 DOM , 可以操作DOM &lt;code&gt;$ref&lt;/code&gt; 可以使用 ; 此时可以做一些 ajax 操作 , mounted 只会执行一次&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;beforeUpdate&lt;/code&gt; : &lt;strong&gt;更新前&lt;/strong&gt; 响应式数据更新时调用 , DOM 重新渲染和打补丁之前 , 可以在这里进一步更改状态 , 不会进行二次渲染&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;updated&lt;/code&gt; : &lt;strong&gt;更新后&lt;/strong&gt; 虚拟DOM重新渲染和打补丁之后调用 , 组件已经更新 , 可以执行后续操作 ; 避免在这里操作数据 , 可能会陷入死循环&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;activated&lt;/code&gt; : &lt;strong&gt;被 keep-alive 缓存的组件激活时调用&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;deacticated&lt;/code&gt; : &lt;strong&gt;被 keep-alive 缓存的组件停用时调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;// 子组件&lt;br&gt;
// 要在子组件的声命周期内 , 才会触发这两个钩子函数&lt;br&gt;
activated() {&lt;br&gt;
console.log(&#39;itemList 被激活&#39;)&lt;br&gt;
},&lt;br&gt;
deactivated() {&lt;br&gt;
console.log(&#39;itemList 被停用 / 失活&#39;)&lt;br&gt;
},&lt;br&gt;
复制代码&lt;/p&gt;
&lt;p&gt;// 父组件&lt;br&gt;
// toggle 切换时触发子组件中的这两个钩子函数&lt;br&gt;
&amp;lt;button @click=&amp;quot;com = &#39;ItemPost&#39;&amp;quot;&amp;gt;post&lt;/button&gt;&lt;br&gt;
&amp;lt;button @click=&amp;quot;com = &#39;ItemList&#39;&amp;quot;&amp;gt;list&lt;/button&gt;&lt;/p&gt;
&lt;keep-alive&gt;
  &lt;component :is=&#34;com&#34;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;
复制代码
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;beforeDestroy&lt;/code&gt; : &lt;strong&gt;销毁前&lt;/strong&gt; 实例销毁之前调用 , 这里各种数据仍然可以访问 ; 可以再次销毁定时器, 解绑事件等操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;destroyed&lt;/code&gt; : &lt;strong&gt;销毁后&lt;/strong&gt; 实例销毁后调用 , Vue 实例的所有内容都会解除绑定 , 所有事件事件监听器会被移除 , 所有子实例也会被销毁&lt;/p&gt;
&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;this is $el&lt;/p&gt;
    &lt;button @click=&#34;info = &#39;修改后的值&#39;&#34;&gt;{{ info }}&lt;/button&gt; 
    &lt;button @click=&#34;handle&#34;&gt;卸载&lt;/button&gt; 
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  name: &#39;HomePage&#39;,
  data() {
    return {
      info: &#39;data options&#39;,
      flag: true
    }
  },
  methods: {
    handle() {
      this.$destroy()
    }
  },
  beforeCreate() {
    console.group(&#39;##### 组件创建前 beforeCreate #####&#39;)
    console.log(&#39;Vue&#39;, this)
    console.log(this.info)
    console.log(this.$el)
  },
  created() {
    console.group(&#39;##### 组件创建后 created #####&#39;)
    console.log(this.info)
    console.log(this.$el)
  },
  beforeMount() {
    console.group(&#39;##### 组件挂载前 beforeMount #####&#39;)
    console.log(this.info)
    console.log(this.$el)
  },
  mounted() {
    console.group(&#39;##### 组件挂载后 mounted #####&#39;)
    console.log(this.$el)
  },
  beforeUpdate() {
    console.group(&#39;##### 组件更新前 beforeUpdate #####&#39;)
    console.log(`这里的数据已经修改了只是没有渲染 ----- `+ this.info)
    this.info  = &#39;又修改了一次&#39;
  },
  updated() {
    console.group(&#39;##### 组件更新后 updated #####&#39;)
    console.log(&#39;更新后的新值: &#39;, this.info)
  },
  beforeDestroy() {
    console.group(&#39;##### 组件卸载前 updated #####&#39;)
    console.log(this.info)
    console.log(this.$el)
  },
  destroyed() {
    console.group(&#39;##### 组件卸载后 updated #####&#39;)
    console.log(this.info)
    console.log(this.$el)
  }
}
&lt;/script&gt;
复制代码
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;![](https://juejin.cn/post/data:image/svg+xml;utf8,&lt;?xml version=&#34;1.0&#34;?&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; version=&#34;1.1&#34; width=&#34;1165&#34; height=&#34;473&#34;&gt;&lt;/svg&gt;)&lt;/p&gt;
&lt;h3 id=&#34;父子组件生命周期&#34;&gt;父子组件生命周期&lt;/h3&gt;
&lt;p&gt;![](https://juejin.cn/post/data:image/svg+xml;utf8,&lt;?xml version=&#34;1.0&#34;?&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; version=&#34;1.1&#34; width=&#34;859&#34; height=&#34;303&#34;&gt;&lt;/svg&gt;)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父组件执行完 &lt;code&gt;beforeMount&lt;/code&gt; 钩子之后就会去加载 子组件 , 只组件加载完成后才会触发父组件的 &lt;code&gt;Mounted&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;子组件更新不会触发父组件的更新, ( 不涉及父子组件交互数据 )&lt;/li&gt;
&lt;li&gt;子组件的卸载会触发父组件的更新&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;过渡-动画&#34;&gt;过渡 动画&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Vue 在插入，更新或者移出 DOM 时，提供多种不同的过渡效果&lt;/p&gt;
&lt;p&gt;在下列情形中可以给任何元素添加进入/离开过渡&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;条件渲染 （&lt;code&gt;v-if v-show&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;动态组件 (&lt;code&gt;component&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;组件根节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;过渡的类名：在进入/离开的过渡中，会有6个 class 切换&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;v-enter&lt;/code&gt; : 定义过渡的开始 , 在元素被插入之前生效 , 在元素被插入之后的下一帧移除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;v-enter-active&lt;/code&gt; : 定义进入过渡生效时的状态 , 在整个进入过渡的阶段中都会应用 . 在元素被插入之前生效 . 咋过渡/动画结束之后移除 , 这个类可以被定义进入过渡的过程时间 , 延迟 和曲线函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;v-enter-to&lt;/code&gt; : 定义进入过渡的结束状态 , 在元素被插入后的下一帧生效 ( 同时 v-enter 移除 ), 在过渡动画完成之后移除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;v-leave&lt;/code&gt; : 定义离开过渡的开始时间 , 在离开过渡被触发时立刻生效 , 下一帧被移除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;v-leave-active&lt;/code&gt; : 定义离开过渡生效时的状态 , 在整个离开过渡的阶段中应用 , 在离开过渡被触发时 立即生效 , 在过渡动画完成之后移除 , 这个类可以被定义离开过渡的过程时间 , 延迟和曲线函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;v-leave-to&lt;/code&gt; : 定义离开过渡的结束状态 , 在离开过渡被触发后下一帧生效 (同时 v-leave 移除), 在过渡东环完成之后移除&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;![](https://juejin.cn/post/data:image/svg+xml;utf8,&lt;?xml version=&#34;1.0&#34;?&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; version=&#34;1.1&#34; width=&#34;1200&#34; height=&#34;600&#34;&gt;&lt;/svg&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;transition&amp;gt;
  &amp;lt;dynamic v-if=&amp;quot;isShow&amp;quot;&amp;gt;&amp;lt;/dynamic&amp;gt;
&amp;lt;/transition&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 没有 name 属性 类名默认是 &lt;code&gt;v-&lt;/code&gt; 开头 , 如果使用了自定义名字 , 替换成自定名字开头 ; &lt;strong&gt;transition 不会被渲染成真是的 DOM 元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;示例 : &lt;code&gt;&amp;lt;transition name=&amp;quot;my-trans&amp;quot;&amp;gt;&lt;/code&gt; &lt;code&gt;my-trans-enter&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style lang=&amp;quot;css&amp;quot;&amp;gt;
  .v-enter, .v-leave-to{
    opacity: 0;
    transition: all .5s ;
  }
  .v-enter-to, .v-leave{
    opacity: 1;
    transition: all .5s ;
  }
&amp;lt;/style&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;多个组件的过渡&#34;&gt;多个组件的过渡&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;transition&amp;gt;
  &amp;lt;keep-alive&amp;gt;  
    &amp;lt;component :is=&amp;quot;showWhat&amp;quot;&amp;gt;&amp;lt;/component&amp;gt;
  &amp;lt;/keep-alive&amp;gt;
&amp;lt;/transition&amp;gt;
复制代码

&amp;lt;style lang=&amp;quot;css&amp;quot;&amp;gt;
  .v-enter, .v-leave-to{
    opacity: 0;
  }
  .v-enter-active, .v-leave-active{
    transition: opacity .3s ease;
  }
&amp;lt;/style&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;![](https://juejin.cn/post/data:image/svg+xml;utf8,&lt;?xml version=&#34;1.0&#34;?&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; version=&#34;1.1&#34; width=&#34;1015&#34; height=&#34;549&#34;&gt;&lt;/svg&gt;)&lt;/p&gt;
&lt;h4 id=&#34;过渡模式&#34;&gt;过渡模式&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;在切换 tab 的时候 内容被重绘了 , 一个是离开过渡的时候, 另一个是进入过渡 , 这是 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 的默认行为 , 进入和离开同时发生 ; 过渡模式仅适用于组件之间&lt;/p&gt;
&lt;p&gt;同时生效的进入和离开的过渡不能满足所有要求，所以 Vue 提供了&lt;strong&gt;过渡模式&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;in-out&lt;/code&gt; : 新元素先进行过渡 , 完成之后当前元素过渡离开&lt;/li&gt;
&lt;li&gt;&lt;code&gt;out-in&lt;/code&gt; : 当前元素先进行过渡 , 完成之后新元素过渡进入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看出上图的动画效果为当前元素还没有完成 , 新元素就进来了 , 此时我们可以使用 &lt;code&gt;out-in&lt;/code&gt; 模式即可解决上述问题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;transition mode=&amp;quot;out-in&amp;quot;&amp;gt;
  &amp;lt;keep-alive&amp;gt;  
    &amp;lt;component :is=&amp;quot;showWhat&amp;quot;&amp;gt;&amp;lt;/component&amp;gt;
  &amp;lt;/keep-alive&amp;gt;
&amp;lt;/transition&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;初始渲染过渡&#34;&gt;初始渲染过渡&lt;/h3&gt;
&lt;p&gt;可以通过 &lt;code&gt;appear&lt;/code&gt; 属性设置节点的初始渲染过渡 ; 需要注意的是, 这个关键字加上之后, 默认就会带有过渡效果 , &lt;code&gt;translateY&lt;/code&gt; 也可以自定义类名和钩子 ; [初始渲染过渡](https://cn.vuejs.org/v2/guide/transitions.html target=)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;transition appear&amp;gt;
  &amp;lt;div v-if=&amp;quot;toggle&amp;quot;&amp;gt;post&amp;lt;/div&amp;gt;
  &amp;lt;div v-else&amp;gt;list&amp;lt;/div&amp;gt;
&amp;lt;/transition&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;列表过渡&#34;&gt;列表过渡&lt;/h3&gt;
&lt;p&gt;列表过渡需要用到 &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;会产生标签名, 默认为 span 可以通过 tag 属性进行设置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;过渡模式不可用&lt;/p&gt;
&lt;transition-group  tag=&#34;ul&#34; appear&gt;
  &lt;li v-for=&#34;user of users&#34; :key=&#34;user.id&#34;&gt;
    &lt;p&gt;{{ user.uname }}&lt;/p&gt;
  &lt;/li&gt;
&lt;/transition-group&gt;
复制代码
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多动画相关 : &lt;a href=&#34;https://cn.vuejs.org/v2/guide/transitions.html&#34;&gt;Vue过渡动画&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;nexttick&#34;&gt;nextTick&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Vue 在更新 DOM 的时候是异步的 , 只要侦听到数据的变化 , 并缓存在同一事件循环中 , 等待事件循环中的所有的数据变化完成后, 统一更新视图 , 为了得到最新的DOM 所以设置了 &lt;code&gt;nextTick()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将回调延迟到下次 DOM 更新循环之后执行 , 在修改数据之后立即使用他 , 然后等待 DOM 更新 ;&lt;/p&gt;
&lt;p&gt;简单理解就是 : &lt;code&gt;nextTick&lt;/code&gt; 是将这个回调函数延迟在下一次 DOM 更新数据后调用 , 即 DOM 重新渲染后自动执行该函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;created() {
  // created 钩子中可以操作 DOM 元素
  this.$nextTick(() =&amp;gt; {
    this.$refs.divRef.innerHTML = &#39;hello vue&#39;
  })
}
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;混入-mixin&#34;&gt;混入 Mixin&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;混入提供一种很灵活的方式, 来分发 Vue 组件中的可复用功能, 一个混入对象可以包含任意组件选项 (data, components, methods, created 等), 当组件使用混入对象时, 所有混入对象的选项将被混合进组件本身的选项 ;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设我们现在要封装一个 button 组件, 我们可以尝试着不再 components 文件夹中去封装, 在同级目录中新建一个 Mixin 文件夹 实例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- path: Mixin/MyButton/MyButton.vue --&amp;gt;
&amp;lt;template&amp;gt;
  &amp;lt;button :class=&amp;quot;[&#39;my-btn&#39;, type]&amp;quot;&amp;gt;
    &amp;lt;!-- 我们希望用户输入按钮的名字所以使用插槽 --&amp;gt;
    &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;
  &amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
// 我们希望用户传递进来一个 type 来定制 btn 样式
export default {
  props: {
    type: {
      type: String,
      default: &#39;my-primay&#39;
    }
  }
}
&amp;lt;/script&amp;gt;
&amp;lt;style scoped&amp;gt;
 /* 基类样式 */
 .my-btn {
    border: none;
    outline: none;
    line-height: 30px;
    width: 50px;
  }
 /* 用户可拓展样式 */
.btn-primary {
  background: skyblue;
}
.btn-danger {
  background: orange;
}
.btn-success {
  background: palegreen;
}
&amp;lt;/style&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后我们在同级别的目录下建立一个 Mixin 对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// path: Mixin/MyButton/index.js
import MyButton from &#39;./MyButton.vue&#39;
export default {
  // 这里我们使用了 组件中的 components 对象
  components: {
    MyButton
  }
}
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后我们在页面中去使用它&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- views/page.vue --&amp;gt;
&amp;lt;template&amp;gt;
  &amp;lt;!-- 此时我们只需要传入指定不同的类名即可变换 button 的样式 --&amp;gt;
  &amp;lt;my-button type=&amp;quot;btn-danger&amp;quot;&amp;gt;按钮&amp;lt;/my-button&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
import MyButton from &#39;./mixin/MyButton&#39;
export default {
  // 组件内使用 mixins 将这个对象混入, 
  mixins: [MyButton]  
}
&amp;lt;/script&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;简单总结一下, 可以看出我们上面虽然用的有些牵强, 不晓得有没有注意到 , 我们实际上等于把 注册组件的方式给抽离出去了, 取而代之的是把他混入进去, 这里就可以简单理解, 很想 合并了两个对象的概念 , 那么接下来就看一下细节&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;选项合并&#34;&gt;选项合并&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;当组件和混入对象含有同名选项时 , 这些选项将以&lt;strong&gt;恰当&lt;/strong&gt; 的方式进行&lt;strong&gt;合并&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;什么叫恰当 😂 看示例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;输入对象会进行递归合并 ， 并在发生冲突时，以组件数据优先&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同名的钩子函数会合并成为一个数组，依次调用，&lt;strong&gt;mixin的钩子优先执行&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象类型选项会合并为同一个对象，&lt;strong&gt;如果键名冲突，以组件内为主&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;// mixin/index.js&lt;br&gt;
export default {&lt;br&gt;
data() {&lt;br&gt;
return {&lt;br&gt;
m_name: &#39;lisi&#39;,&lt;br&gt;
m_list: [1, 2, 3]&lt;br&gt;
}&lt;br&gt;
},&lt;br&gt;
created() {&lt;br&gt;
// 混入之后会被调用 同时我们也可以在混入之前调用组件内的数据&lt;br&gt;
console.log(this.m_name, this.m_list, &#39;mixin&#39;)&lt;br&gt;
console.log(this.c_name, this.c_list, &#39;component&#39;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 执行 handle 
this.handle() // 这个handle 实际就是调用了 组件中的handle 而不是 mixin 中的handle
this.handle1()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;},&lt;br&gt;
methods: {&lt;br&gt;
// 由于此处的 handle 与 组件内存在同名 按照上面说明， 这个handle被覆盖以下面组件中为主&lt;br&gt;
handle() {&lt;br&gt;
console.log(&#39;mixin handle&#39;)&lt;br&gt;
},&lt;br&gt;
handle1() {&lt;br&gt;
console.log(&#39;mixin handle1&#39;)&lt;br&gt;
}&lt;br&gt;
}&lt;br&gt;
}&lt;br&gt;
复制代码&lt;/p&gt;
&lt;template&gt;
  &lt;div&gt;&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import mixin from &#39;@/mixin&#39;
export default {
  mixins: [mixin],
  data() {
    return {
      c_name: &#39;zhangsan&#39;,
      c_list: [1, 2, 3]
    }
  },
  created() {
    // 同理这里也可以直接访问 mixin 中的数据，这里就不演示了
    console.log(&#39;this is component&#39;)
&lt;pre&gt;&lt;code&gt;// 调用handle 
this.handle() 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;},&lt;br&gt;
methods: {&lt;br&gt;
handle() {&lt;br&gt;
console.log(&#39;component handle&#39;)&lt;br&gt;
}&lt;br&gt;
}&lt;br&gt;
}&lt;br&gt;
&lt;/script&gt;&lt;br&gt;
复制代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;全局混入&#34;&gt;全局混入&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;混入也可以全局注册 ， 使用时需要小心， 全局混入会影响每一个之后创建的 vue 组件，也就是说以后创建的每一个 Vue 组件会混入这个 mixin 都会执行这里面的操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;// main.js
Vue.mixin({
  data() {
    return {}
  },
  created() {},
  // ......
})
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;provide-inject-依赖注入&#34;&gt;provide / inject 依赖注入&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;provide&lt;/code&gt; 和 &lt;code&gt;inject&lt;/code&gt; 主要开发高阶插件/组件库时使用，并不推荐用于普通应用程序中&lt;/p&gt;
&lt;p&gt;这对选项要一起使用，允许一个祖先组件向自己所有的子孙组件注入依赖，不论组件层间有多深；&lt;/p&gt;
&lt;p&gt;也就说这对选项可以跨越组件的传值 下面看示例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;// App.vue
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
  data() {
    return {
      info: { name: &#39;zs&#39;, age: 23 }
    }
  },
  // 使用 provide 把值传递出去
  // 这里碰到一点小问题，官网说可以是 Objct | function 返回一个对象，这里试了 Object 就是不能成功不知道为啥😭
  provide() {
    return {
      info: this.info,
      reload: this.reload
    }
  },
  methods: {
    reload() {
      console.log(&#39;reload&#39;)
    }
  }
}
&amp;lt;/script&amp;gt;
复制代码

// Home.vue
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    Home
    &amp;lt;provide-test&amp;gt;&amp;lt;/provide-test&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
// 这里我们只是把需要用到 provide 数据的组件引入，可以看出我们并没有使用
import ProvideTest from &#39;@/components/ProvideTest.vue&#39;
export default {
  components: {
    ProvideTest
  }
}
&amp;lt;/script&amp;gt;
复制代码

// components/ProvideTest.vue
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
  // 这里我们使用 indect 来接收 父组件传递过来的数据，可以看出这种方式类似于 props 接收
  inject: [&#39;info&#39;, &#39;reload&#39;],
  mounted() {
    // 然后就可以通过实例访问这些数据了
    console.log(this.info)
    this.reload()
  }
}
&amp;lt;/script&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然 &lt;code&gt;inject&lt;/code&gt; 也不是只能通过数据来接收参数；具体参考 [cn.vuejs.org/v2/api/#pro…](https://cn.vuejs.org/v2/api/ target=)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;provide&lt;/code&gt; 和 &lt;code&gt;inject&lt;/code&gt; 绑定并不是响应式的， 这是刻意为之，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应式的； &lt;code&gt;inject&lt;/code&gt; 接收过来的数据，不要试图修改，会报错的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;非父子组件传值-onon-onemit&#34;&gt;非父子组件传值 on/on / on/emit&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;$emit 这个咱们前面就知道了 触发当前实例上的事件， 附件参数传给监听器的回调 （可以实现子组件向父组件间的传值）&lt;/p&gt;
&lt;p&gt;了解如何传值之前先了解 &lt;code&gt;$on&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$on&lt;/code&gt; 监听当前实例的上的自定义事件，事件可以由 &lt;code&gt;$emit&lt;/code&gt; 触发，回调函数会接收所有传入事件触发的额外参数， 乍一看和指令 v-on 差不多，那么下面就看下具体示例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;// About.vue
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;button @click=&amp;quot;handle&amp;quot;&amp;gt;点击传递&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
  methods: {
    handle() {
      // 这里使用 emit 触发一个自定义事件 如果是监听原生事件 同样可以传递 event
      this.$emit(&#39;on-click&#39;, &#39;单文件内被监听了&#39;)
    }
  },
  mounted() {
    // 在 mounted 中 用 on 去监听触发的事件， 并且接收传递过来的参数
    this.$on(&#39;on-click&#39;, msg =&amp;gt; {
      console.log(msg)
    })
  }
}
&amp;lt;/script&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然如果只是这样使用， 肯定是略显鸡肋， 既然知道 API 的特性，那么下面看父子组件传值&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;兄弟组件之间的通信，&lt;code&gt;EventBus&lt;/code&gt; Vue 中也叫 事件总线，是一种&lt;strong&gt;发布订阅模式&lt;/strong&gt;（&lt;a href=&#34;https://juejin.im/post/6844903513009422343&#34;&gt;关于发布订阅模式&lt;/a&gt;）通过 &lt;code&gt;EventBus&lt;/code&gt; 来作为沟通桥梁，让所有组件共用一个事件中心，可以像该事件中心注册事件或者接收事件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;// Bus/index.js
import Vue from &#39;vue&#39;

// 创建一个空的 Vue 实例 用来做 桥梁
export const Bus = new Vue()
复制代码

// main.js
import { Bus } from &#39;./Bus&#39;
// 将这个空的实例绑定到 vue 的原型中
Vue.prototype.$bus = Bus
复制代码

// About.vue
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;button @click=&amp;quot;handle&amp;quot;&amp;gt;点击传递&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
  data() {
    return {
      message: &#39;&#39;
    }
  },
  methods: {
    handle() {
      // 通过 $bus.$emit 触发事件 可以是自定义事件也可以是原生事件
      this.$bus.$emit(&#39;click&#39;, &#39;其他文件内被监听了&#39;, event)
    }
  }
}
&amp;lt;/script&amp;gt;
复制代码

// Home.vue
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
  mounted() {
    // 兄弟组件中可以通过 $bus.$on 监听触发的事件， 并且接收一个回调处理参数
    this.$bus.$on(&#39;click&#39;, (msg, e) =&amp;gt; {
      console.log(msg)
      console.log(e)
    })
  }
}
&amp;lt;/script&amp;gt;
复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 组件挂在之前会执行 &lt;code&gt;mounted&lt;/code&gt; 钩子，所以在这个钩子中监听触发的事件，当然在 &lt;code&gt;created&lt;/code&gt; 中也是可以的 建议还是 &lt;code&gt;mounted&lt;/code&gt;&lt;/p&gt;
">一万字总结Vue2.6.X</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/Github-webhook/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;之前使用GitHub Actions可以在提交代码后自动上传到腾讯云COS存储桶,实现静态网站完美自动化部署.那么非静态的网站或者项目需要自动化部署到VPS服务器上就可以使用GitHub Webhooks来实现.作为纯属新手来说,网上查阅了十几篇相关教程,都没法部署成功,最后总算找到了问题关键点,决定整理成文章分享出来,希望能帮助到新手用户.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Webhook支持php,js等多种方式,可以实现简单的部署,也可以实现复杂的自动化构建等功能,本文介绍适合新手用户的php方式,来自动化部署网站.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;webhook简单原理&#34;&gt;Webhook简单原理&lt;/h3&gt;
&lt;p&gt;对于入门新手来说,Webhook可以理解为当你在本地完成代码工作后,Push提交到GitHub,GitHub检测到Push后,使用Webhook发送一条命令到你的VPS服务器上的Webhook.php文件,服务器检测到命令后根据webhook.php中的配置在服务器上执行Pull命令,同步GitHub上的代码到服务器.实现了简单的自动化部署工作.节省了你再次上传至服务器的多余操作.&lt;/p&gt;
&lt;h3 id=&#34;部署流程&#34;&gt;部署流程&lt;/h3&gt;
&lt;h4 id=&#34;启用shell_exec&#34;&gt;启用shell_exec&lt;/h4&gt;
&lt;p&gt;编辑php.ini&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /usr/local/php/etc/php.ini
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查找shell_exec,在disable_functions中删除shell_exec字段.&lt;br&gt;
&lt;img src=&#34;https://imcm.xyz/post-images/1608622210723.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;重启php.ini保存设置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/etc/init.d/php-fpm restart
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;配置站点目录权限&#34;&gt;配置站点目录权限&lt;/h4&gt;
&lt;p&gt;由于Webhook的推送请求是通过http/https方式发送至服务器,根据webhook.php中的命令执行git pull的实为运行php的用户,根据以下命令可以查执行php用户为www.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ps aux | grep php
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;确保仓库所在的站点目录所有者为www&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;chown -R www:www /home/wwwroot
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;切换为www账户&#34;&gt;切换为www账户&lt;/h4&gt;
&lt;p&gt;以root账户登陆服务器,修改www的登录权限.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /etc/passwd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;找到&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;www:x:1003:1003::/home/www:/sbin/nologin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修为改&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;www:x:1003:1003::/home/www:/bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;为www创建ssh公钥&#34;&gt;为www创建ssh公钥&lt;/h4&gt;
&lt;p&gt;切换为www登陆&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;su www
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建ssh公钥&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ssh-keygen -t rsa
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1608622389755.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;获取你的公钥id_rsa.pub&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat /home/www/.ssh/id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;登陆github配置ssh公钥&#34;&gt;登陆GitHub配置ssh公钥&lt;/h4&gt;
&lt;p&gt;登陆GitHub - 进入仓库 - Settings - Deploy keys - Add Deploy keys&lt;br&gt;
粘贴刚才创建的公钥&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1608622410820.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;首次git-clone仓库&#34;&gt;首次git clone仓库&lt;/h4&gt;
&lt;p&gt;验证ssh公钥配置成功&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ssh -T git@github.com
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1608622477397.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;首次clone仓库成功&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone git@github.com:xxxxxx/xxxxxxx.git
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1608622485033.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;配置webhookphp&#34;&gt;配置webhook.php&lt;/h4&gt;
&lt;p&gt;在项目网站根目录创建webhook.php获得外网链接为https://yourdoamin.com/webhook.php&lt;br&gt;
粘贴以下代码,只需要更改keySecret和wwwRoot即可.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

// 自行创建一个验证密码
$keySecret = &#39;xxxxxx&#39;;

// 修改为你自己的仓库绝对路径
$wwwRoot = [
    &#39;/home/wwwroot/xxxx&#39;,
];

// 保存运行脚本的日志
$logFile = &#39;log/webhook.log&#39;;

// 执行git命令
$gitCommand = &#39;git pull&#39;;

// 判断是否开启秘钥认证(已实现gitee和github)
if (isset($keySecret) &amp;amp;&amp;amp; !empty($keySecret)) {
    list($headers, $gitType) = [[], null];
    foreach ($_SERVER as $key =&amp;gt; $value) {
        &#39;HTTP_&#39; == substr($key, 0, 5) &amp;amp;&amp;amp; $headers[str_replace(&#39;_&#39;, &#39;-&#39;, substr($key, 5))] = $value;
        if (empty($gitType) &amp;amp;&amp;amp; strpos($key, &#39;GITEE&#39;) !== false) {
            $gitType = &#39;GITEE&#39;;
        }
        if (empty($gitType) &amp;amp;&amp;amp; strpos($key, &#39;GITHUB&#39;) !== false) {
            $gitType = &#39;GITHUB&#39;;
        }
    }
    if ($gitType == &#39;GITEE&#39;) {
        if (!isset($headers[&#39;X-GITEE-TOKEN&#39;]) || $headers[&#39;X-GITEE-TOKEN&#39;] != $keySecret) {
            die(&#39;GITEE - 请求失败，秘钥有误&#39;);
        }
    } elseif ($gitType == &#39;GITHUB&#39;) {
        $json_content = file_get_contents(&#39;php://input&#39;);
        $signature = &amp;quot;sha1=&amp;quot; . hash_hmac(&#39;sha1&#39;, $json_content, $keySecret);
        if ($signature != $headers[&#39;X-HUB-SIGNATURE&#39;]) {
            die(&#39;GITHUB - 请求失败，秘钥有误&#39;);
        }
    } else {
        die(&#39;请求错误，未知git类型&#39;);
    }
}

!is_array($wwwRoot) &amp;amp;&amp;amp; $wwwRoot = [$wwwRoot];
foreach ($wwwRoot as $vo) {
    $shell = sprintf(&amp;quot;cd %s &amp;amp;&amp;amp; git pull 2&amp;gt;&amp;amp;1&amp;quot;, $vo);
    $output = shell_exec($shell);
    $log = sprintf(&amp;quot;[%s] %s \n&amp;quot;, date(&#39;Y-m-d H:i:s&#39;, time()) . &#39; - &#39; . $vo, $output);
    echo $log;
    file_put_contents($logFile, $log, FILE_APPEND);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;github-webhooks配置&#34;&gt;GitHub Webhooks配置&lt;/h4&gt;
&lt;p&gt;登陆GitHub - 进入仓库 - Settings - Webhooks - Add webhook&lt;br&gt;
Payload URL 输入刚才获取的webhook.php的外网链接.&lt;br&gt;
Content type 保持默认&lt;br&gt;
Secret 输入刚才配置webhook.php创建的验证密码&lt;br&gt;
Add webhook 完成创建&lt;br&gt;
&lt;img src=&#34;https://imcm.xyz/post-images/1608622528975.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;恢复关闭www登陆&#34;&gt;恢复关闭www登陆&lt;/h4&gt;
&lt;p&gt;exit退出www登陆切回root,在次关闭www登陆.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /etc/passwd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;恢复为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;www:x:1003:1003::/home/www:/sbin/nologin
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;自动化部署成功&#34;&gt;自动化部署成功&lt;/h4&gt;
&lt;p&gt;本地push代码到GitHub后,可以看到返回信息提示服务器pull成功.&lt;br&gt;
&lt;img src=&#34;https://imcm.xyz/post-images/1608622569768.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;关键点和相关错误&#34;&gt;关键点和相关错误&lt;/h3&gt;
&lt;h4 id=&#34;权限&#34;&gt;权限&lt;/h4&gt;
&lt;p&gt;网上很多教程都没有提到权限问题,所以对于新手小白来说,就会不知道为什么不成功.而少数提到权限的教程,也没有非常详细指导用户如何配置.所以如果部署有问题,请检查权限问题,新手用户可以严格按照本教程先部署成功,在来自行修改你需要的配置.&lt;/p&gt;
&lt;h4 id=&#34;webhookphp&#34;&gt;webhook.php&lt;/h4&gt;
&lt;p&gt;webhook.php的代码网上也有很多种,有些能用有些无法使用,本文提供的是经过测试可用的,大家也可以自行搜索或者编辑.&lt;/p&gt;
&lt;h4 id=&#34;service-timeout&#34;&gt;Service Timeout&lt;/h4&gt;
&lt;p&gt;当遇到push大量代码时,服务器pull需要更长的时间,所以webhook返回给GitHub的信息如下图会出现Service Timeout超时错误,但实际上服务器也成功执行了pull,你可以登陆服务器检查来确认,同时也可以根据你的项目实际情况自行修改webhook.php执行配置.&lt;br&gt;
&lt;img src=&#34;https://imcm.xyz/post-images/1608622604663.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;证书错误&#34;&gt;证书错误&lt;/h4&gt;
&lt;p&gt;有可能会出现下图中的证书错误提示,请更换证书,测试时使用的Let&#39;s Encrypt的泛域名证书就会报错,博主更换为腾讯云申请的单域名证书就可以了.&lt;br&gt;
&lt;img src=&#34;https://imcm.xyz/post-images/1608622614276.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;结语&#34;&gt;结语&lt;/h3&gt;
&lt;p&gt;特别感谢以下两篇文章给予了关于www权限和webhook.php两个关键点的帮助:&lt;br&gt;
&lt;a href=&#34;https://learnku.com/articles/34320&#34;&gt;gitee 和 GitHub 的 webhook 的使用，实现服务器代码的自动更新&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.jianshu.com/p/00bc0323e83f&#34;&gt;gitlab之webhook自动部署&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文转自:&lt;a href=&#34;https://www.ioiox.com/archives/72.html&#34;&gt;IOIOX&lt;/a&gt;&lt;/p&gt;
"><转>新手入门 Github Webhooks 完美自动化部署教程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/libcrypto-ssh-waring/"" data-c="
          &lt;p&gt;相信很多人在使用 ssh 或者 curl 等等命令的时候都出现过“libssl.so.1.0.0 and libcrypto.so.1.0.0 no version information available”的问题，我也遇到这个问题很久了，一直懒得搭理它，因为ssh出现这个问题之后还能继续使用，直到前几天使用 nodejs 的时候又出现了这个问题严重影响了nodejs 的使用，我才决定要修复一下这个问题。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;解决方法一&#34;&gt;解决方法一&lt;/h3&gt;
&lt;p&gt;先来个最简单的解决方法。我出现的错误具体是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ssh: /usr/local/openssl/lib/libcrypto.so.1.0.0: no version information available (required by ssh)
ssh: /usr/local/openssl/lib/libcrypto.so.1.0.0: no version information available (required by ssh)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我在 /usr目录下搜索了一下这个libcrypto.so.1.0.0 和 libcrypto.so.1.0.0：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;imcm@mac-mini:~$ sudo find /usr -name libcrypto.so.1.0.0
[sudo] imcm 的密码： 
/usr/lib/x86_64-linux-gnu/libcrypto.so.1.0.0
/usr/local/openssl/lib/libcrypto.so.1.0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在网上看到有人说是因为引用了不受系统承认的版本，那我就试着把 /usr/local/openssl/lib/ 目录下的libcrypto.so.1.0.0 和 libcrypto.so.1.0.0删掉(为了保险起见，我做了移动)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo mv /usr/local/openssl/lib/libcrypto.so.1.0.0 /usr/local/openssl/lib/libcrypto.so.1.0.0.bk
sudo mv /usr/local/openssl/lib/libssl.so.1.0.0 /usr/local/openssl/lib/libssl.so.1.0.0.bk
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，case closed！问题解决 :(滑稽)&lt;/p&gt;
&lt;h3 id=&#34;解决方法二&#34;&gt;解决方法二&lt;/h3&gt;
&lt;p&gt;还有一种解决方法，是重新编译 openssl，指定全局的库路径。由于这个方法我没有试过(在主用机上搞这些有风险 :(懒得理) )，这里就直接给出原链接：https://stackoverflow.com/questions/18390833/no-version-information-available，需要 FQ 才能打开，在这里搬运一下：&lt;/p&gt;
&lt;p&gt;下载 1.0.0. 版本的 openssl 源码，在解压后的根目录里新建一个”openssl.ld”文件，文件内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;OPENSSL_1.0.0 {
    global:
    *;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接着执行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;make clean
./config --prefix=/usr/local --openssldir=/usr/local/openssl shared -Wl,--version-script=openssl.ld -Wl,-Bsymbolic-functions
make
make test
make install
ldconfig
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大致上就是这样，我的建议还是如果不懂就不要轻易试这个方法，方法一都已经能解决大部分的问题。&lt;/p&gt;
">Linux 解决“libssl.so.1.0.0 or libcrypto.so.1.0.0 no version information available”的问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/linux-update-openssl/"" data-c="
          &lt;p&gt;2020年12月08日，OpenSSL官方发布安全公告，披露CVE-2020-1971 OpenSSL GENERAL_NAME_cmp 拒绝服务漏洞。当两个GENERAL_NAME都包含同一个EDIPARTYNAME时，由于GENERAL_NAME_cmp函数未能正确处理，从而导致空指针引用，并可能导致拒绝服务。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;查看现有版本&#34;&gt;查看现有版本&lt;/h3&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;openssl version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;OpenSSL 1.0.2g 1 Mar 2016
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;备份旧版本&#34;&gt;备份旧版本&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mv /usr/bin/openssl /usr/bin/openssl.old
mv /usr/include/openssl /usr/include/openssl.old
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;更新openssl&#34;&gt;更新OpenSSL&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;下载&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;wget https://www.openssl.org/source/openssl-1.1.1i.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;解压&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;tar -zxvf openssl-1.1.1i.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;编译安装&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd openssl-1.1.1i
./config
make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;设置软连接&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ln -s /usr/local/openssl/bin/openssl /usr/bin/openssl
ln -s /usr/local/openssl/include/openssl /usr/include/openssl
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;设置动态地址库&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo &#39;/usr/local/openssl/lib&#39; &amp;gt; /etc/ld.so.conf.d/openssl-ld.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;再次查看版本&#34;&gt;再次查看版本&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;openssl version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;OpenSSL 1.1.1i 8 Dec 2020 (Library: OpenSSL 1.1.1d 10 Sep 2019)
&lt;/code&gt;&lt;/pre&gt;
">Linux手动升级OpenSSL</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/net-info/"" data-c="
          &lt;h2 id=&#34;osi&#34;&gt;OSI&lt;/h2&gt;
&lt;p&gt;开放式系统互联通信参考模型（英语：Open System Interconnection Reference Model，缩写为 OSI），简称为OSI模型（OSI model），一种概念模型，由国际标准化组织提出，一个试图使各种计算机在世界范围内互连为网络的标准框架&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;tcpip&#34;&gt;TCP/IP&lt;/h2&gt;
&lt;p&gt;互联网协议套件（英语：Internet Protocol Suite，缩写IPS）是一个网络通信模型，以及一整个网络传输协议家族，为网际网络的基础通信架构。它常被通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP&lt;/p&gt;
&lt;h2 id=&#34;dns&#34;&gt;DNS&lt;/h2&gt;
&lt;p&gt;&#39;域名系统（英文：Domain Name System，缩写： &#39;DNS）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网&lt;/p&gt;
&lt;h2 id=&#34;udp&#34;&gt;UDP&lt;/h2&gt;
&lt;p&gt;用户数据包协议（英语：User Datagram Protocol，缩写：UDP），又称用户数据包协议，是一个简单的面向数据报的传输层协议&lt;/p&gt;
&lt;h2 id=&#34;icmp&#34;&gt;ICMP&lt;/h2&gt;
&lt;p&gt;互联网控制消息协议（英语：Internet Control Message Protocol，缩写：ICMP）是互联网协议族的核心协议之一。它用于TCP/IP网络中发送控制消息，提供可能发生在通信环境中的各种问题反馈，通过这些信息，使管理者可以对所发生的问题作出诊断，然后采取适当的措施解决&lt;/p&gt;
&lt;h2 id=&#34;tcp&#34;&gt;TCP&lt;/h2&gt;
&lt;p&gt;传输控制协议（英语：Transmission Control Protocol，缩写：TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议&lt;/p&gt;
&lt;h2 id=&#34;arq&#34;&gt;ARQ&lt;/h2&gt;
&lt;p&gt;自动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层的错误纠正协议之一。它包括停止等待ARQ协议和连续ARQ协议，错误侦测（Error Detection）、正面确认（Positive Acknowledgment）、逾时重传（Retransmission after Timeout）与负面确认继以重传（Negative Acknowledgment and Retransmission）等机制&lt;/p&gt;
&lt;h2 id=&#34;syn&#34;&gt;SYN&lt;/h2&gt;
&lt;p&gt;同步序列编号（Synchronize Sequence Numbers）&lt;/p&gt;
&lt;h2 id=&#34;ack&#34;&gt;ACK&lt;/h2&gt;
&lt;p&gt;ACK (Acknowledgement）即是确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误&lt;/p&gt;
&lt;h2 id=&#34;tcb&#34;&gt;TCB&lt;/h2&gt;
&lt;p&gt;传输控制块 TCB(Transmission Control Block)存储了每一个连接中的一些重要信息，如：TCP 连接表，指向发送和接收缓存的指针，指向重传队列的指针，当前的发送和接收序号等等&lt;/p&gt;
&lt;h2 id=&#34;http&#34;&gt;HTTP&lt;/h2&gt;
&lt;p&gt;超文本传输协议（英语：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议&lt;/p&gt;
&lt;h2 id=&#34;ssltls&#34;&gt;SSL/TLS&lt;/h2&gt;
&lt;p&gt;传输层安全性协议（英语：Transport Layer Security，缩写作 TLS），及其前身安全套接层（Secure Sockets Layer，缩写作 SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障&lt;/p&gt;
&lt;h2 id=&#34;adt&#34;&gt;ADT&lt;/h2&gt;
&lt;p&gt;抽象数据类型（Abstract Data Type，ADT）是计算机科学中具有类似行为的特定类别的数据结构的数学模型；或者具有类似语义的一种或多种程序设计语言的数据类型。抽象数据类型是间接定义的，通过其上的可执行的操作以及这些操作的效果的数学约束（与可能的代价）&lt;/p&gt;
&lt;h2 id=&#34;php&#34;&gt;PHP&lt;/h2&gt;
&lt;p&gt;PHP（全称：PHP：Hypertext Preprocessor，即“PHP：超文本预处理器”）是一种开源的通用计算机脚本语言，尤其适用于网络开发并可嵌入 HTML 中使用&lt;/p&gt;
&lt;h2 id=&#34;fpm&#34;&gt;FPM&lt;/h2&gt;
&lt;p&gt;FPM(FastCGI Process Manager, FPM)是 PHP FastCGI 运行模式的一个进程管理器&lt;/p&gt;
&lt;h2 id=&#34;mvc&#34;&gt;MVC&lt;/h2&gt;
&lt;p&gt;MVC模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）&lt;/p&gt;
&lt;h2 id=&#34;orm&#34;&gt;ORM&lt;/h2&gt;
&lt;p&gt;对象关系映射（英语：Object Relational Mapping，简称ORM，或O/RM，或O/R mapping），是一种程序设计技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换&lt;/p&gt;
&lt;h2 id=&#34;pdo&#34;&gt;PDO&lt;/h2&gt;
&lt;p&gt;PDO（PHP Data Objects） PHP 数据对象，是 PHP 应用中的一个数据库抽象层规范。PDO提供了一个统一的 API 接口可以使得你的 PHP 应用不去关心具体要 连接的数据库服务器系统类型&lt;/p&gt;
&lt;h2 id=&#34;oop&#34;&gt;OOP&lt;/h2&gt;
&lt;p&gt;面向对象编程（Object Oriented Programming，OOP，面向对象程序设计）是一种计算机编程架构&lt;/p&gt;
&lt;h2 id=&#34;dom&#34;&gt;DOM&lt;/h2&gt;
&lt;p&gt;文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM&lt;/p&gt;
&lt;h2 id=&#34;cors&#34;&gt;CORS&lt;/h2&gt;
&lt;h2 id=&#34;json&#34;&gt;JSON&lt;/h2&gt;
&lt;p&gt;JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式&lt;/p&gt;
&lt;h2 id=&#34;jsonp&#34;&gt;JSONP&lt;/h2&gt;
&lt;p&gt;JSONP(JSON with Padding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题&lt;/p&gt;
&lt;h2 id=&#34;rdb&#34;&gt;RDB&lt;/h2&gt;
&lt;p&gt;RDB(Redis Database)，在指定时间间隔对 Redis 内存数据进行快照存储&lt;/p&gt;
&lt;h2 id=&#34;aof&#34;&gt;AOF&lt;/h2&gt;
&lt;p&gt;只追加文件(append-only file，AOF)，在执行写命令时，将被执行的写命令复制到磁盘里面&lt;/p&gt;
&lt;h2 id=&#34;ipc&#34;&gt;IPC&lt;/h2&gt;
&lt;p&gt;进程间通信（IPC，Inter-Process Communication），指至少两个进程或线程间传送数据或信号的一些技术或方法&lt;/p&gt;
&lt;h2 id=&#34;qps&#34;&gt;QPS&lt;/h2&gt;
&lt;p&gt;每秒查询率 QPS(Query Per Second) 是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准&lt;/p&gt;
&lt;h2 id=&#34;tps&#34;&gt;TPS&lt;/h2&gt;
&lt;p&gt;Transactions Per Second（每秒传输的事物处理个数），即服务器每秒处理的事务数&lt;/p&gt;
&lt;h2 id=&#34;xss&#34;&gt;XSS&lt;/h2&gt;
&lt;p&gt;跨站脚本（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响&lt;/p&gt;
&lt;h2 id=&#34;csrf&#34;&gt;CSRF&lt;/h2&gt;
&lt;p&gt;跨站请求伪造（英语：Cross-site request forgery），通常缩写为 CSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法&lt;/p&gt;
&lt;h2 id=&#34;ddos&#34;&gt;DDOS&lt;/h2&gt;
&lt;p&gt;DDOS 又称为分布式拒绝服务，全称是 Distributed Denial of Service。DDOS 本是利用合理的请求造成资源过载，导致服务不可用&lt;/p&gt;
&lt;h2 id=&#34;oop-2&#34;&gt;OOP&lt;/h2&gt;
&lt;p&gt;面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针&lt;/p&gt;
&lt;h2 id=&#34;sso&#34;&gt;SSO&lt;/h2&gt;
&lt;p&gt;单点登录（英语：Single sign-on，缩写为 SSO），又译为单一签入，一种对于许多相互关连，但是又是各自独立的软件系统，提供访问控制的属性。当拥有这项属性时，当用户登录时，就可以获取所有系统的访问权限，不用对每个单一系统都逐一登录&lt;/p&gt;
&lt;h2 id=&#34;rest&#34;&gt;REST&lt;/h2&gt;
&lt;p&gt;表现层状态转换（英语：Representational State Transfer，缩写：REST）是一种万维网软件架构风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息&lt;/p&gt;
&lt;h2 id=&#34;jwt&#34;&gt;JWT&lt;/h2&gt;
&lt;p&gt;JSON Web Token 是一种跨域认证解决方案&lt;/p&gt;
&lt;h2 id=&#34;lvs&#34;&gt;LVS&lt;/h2&gt;
&lt;p&gt;Linux 虚拟服务器（Linux Virtual Server，LVS）是一个虚拟的服务器集群系统，用于实现负载均衡&lt;/p&gt;
&lt;p&gt;以上内容均摘录自维基百科、百度百科&lt;/p&gt;
">术语对照表</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/php-5-array/"" data-c="
          &lt;p&gt;PHP String 函数是 PHP 核心的组成部分。无需安装即可使用这些函数。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;addcslashes()&lt;/td&gt;
&lt;td&gt;返回在指定的字符前添加反斜杠的字符串。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;addslashes()&lt;/td&gt;
&lt;td&gt;返回在预定义的字符前添加反斜杠的字符串。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bin2hex()&lt;/td&gt;
&lt;td&gt;把 ASCII 字符的字符串转换为十六进制值。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;chop()&lt;/td&gt;
&lt;td&gt;移除字符串右侧的空白字符或其他字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;chr()&lt;/td&gt;
&lt;td&gt;从指定 ASCII 值返回字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;chunk_split()&lt;/td&gt;
&lt;td&gt;把字符串分割为一连串更小的部分。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;convert_cyr_string()&lt;/td&gt;
&lt;td&gt;把字符串由一种 Cyrillic 字符集转换成另一种。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;convert_uudecode()&lt;/td&gt;
&lt;td&gt;对 uuencode 编码的字符串进行解码。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;convert_uuencode()&lt;/td&gt;
&lt;td&gt;使用 uuencode 算法对字符串进行编码。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;count_chars()&lt;/td&gt;
&lt;td&gt;返回字符串所用字符的信息。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;crc32()&lt;/td&gt;
&lt;td&gt;计算一个字符串的 32 位 CRC（循环冗余校验）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;crypt()&lt;/td&gt;
&lt;td&gt;单向的字符串加密法（hashing）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;echo()&lt;/td&gt;
&lt;td&gt;输出一个或多个字符串。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;explode()&lt;/td&gt;
&lt;td&gt;把字符串打散为数组。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fprintf()&lt;/td&gt;
&lt;td&gt;把格式化的字符串写入到指定的输出流。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;get_html_translation_table()&lt;/td&gt;
&lt;td&gt;返回 htmlspecialchars() 和 htmlentities() 使用的翻译表。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hebrev()&lt;/td&gt;
&lt;td&gt;把希伯来（Hebrew）文本转换为可见文本。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hebrevc()&lt;/td&gt;
&lt;td&gt;把希伯来（Hebrew）文本转换为可见文本，并把新行（\n）转换为 &lt;br&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hex2bin()&lt;/td&gt;
&lt;td&gt;把十六进制值的字符串转换为 ASCII 字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;html_entity_decode()&lt;/td&gt;
&lt;td&gt;把 HTML 实体转换为字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;htmlentities()&lt;/td&gt;
&lt;td&gt;把字符转换为 HTML 实体。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;htmlspecialchars_decode()&lt;/td&gt;
&lt;td&gt;把一些预定义的 HTML 实体转换为字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;htmlspecialchars()&lt;/td&gt;
&lt;td&gt;把一些预定义的字符转换为 HTML 实体。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;implode()&lt;/td&gt;
&lt;td&gt;返回一个由数组元素组合成的字符串。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;join()&lt;/td&gt;
&lt;td&gt;implode() 的别名。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lcfirst()&lt;/td&gt;
&lt;td&gt;把字符串中的首字符转换为小写。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;levenshtein()&lt;/td&gt;
&lt;td&gt;返回两个字符串之间的 Levenshtein 距离。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;localeconv()&lt;/td&gt;
&lt;td&gt;返回本地数字及货币格式信息。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ltrim()&lt;/td&gt;
&lt;td&gt;移除字符串左侧的空白字符或其他字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;md5()&lt;/td&gt;
&lt;td&gt;计算字符串的 MD5 散列。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;md5_file()&lt;/td&gt;
&lt;td&gt;计算文件的 MD5 散列。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;metaphone()&lt;/td&gt;
&lt;td&gt;计算字符串的 metaphone 键。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;money_format()&lt;/td&gt;
&lt;td&gt;返回格式化为货币字符串的字符串。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nl_langinfo()&lt;/td&gt;
&lt;td&gt;返回指定的本地信息。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nl2br()&lt;/td&gt;
&lt;td&gt;在字符串中的每个新行之前插入 HTML 换行符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;number_format()&lt;/td&gt;
&lt;td&gt;通过千位分组来格式化数字。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ord()&lt;/td&gt;
&lt;td&gt;返回字符串中第一个字符的 ASCII 值。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;parse_str()&lt;/td&gt;
&lt;td&gt;把查询字符串解析到变量中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;print()&lt;/td&gt;
&lt;td&gt;输出一个或多个字符串。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;printf()&lt;/td&gt;
&lt;td&gt;输出格式化的字符串。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;quoted_printable_decode()&lt;/td&gt;
&lt;td&gt;把 quoted-printable 字符串转换为 8 位字符串。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;quoted_printable_encode()&lt;/td&gt;
&lt;td&gt;把 8 位字符串转换为 quoted-printable 字符串。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;quotemeta()&lt;/td&gt;
&lt;td&gt;引用元字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rtrim()&lt;/td&gt;
&lt;td&gt;移除字符串右侧的空白字符或其他字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;setlocale()&lt;/td&gt;
&lt;td&gt;设置地区信息（地域信息）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sha1()&lt;/td&gt;
&lt;td&gt;计算字符串的 SHA-1 散列。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sha1_file()&lt;/td&gt;
&lt;td&gt;计算文件的 SHA-1 散列。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;similar_text()&lt;/td&gt;
&lt;td&gt;计算两个字符串的相似度。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;soundex()&lt;/td&gt;
&lt;td&gt;计算字符串的 soundex 键。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sprintf()&lt;/td&gt;
&lt;td&gt;把格式化的字符串写入一个变量中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sscanf()&lt;/td&gt;
&lt;td&gt;根据指定的格式解析来自一个字符串的输入。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;str_getcsv()&lt;/td&gt;
&lt;td&gt;把 CSV 字符串解析到数组中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;str_ireplace()&lt;/td&gt;
&lt;td&gt;替换字符串中的一些字符（大小写不敏感）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;str_pad()&lt;/td&gt;
&lt;td&gt;把字符串填充为新的长度。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;str_repeat()&lt;/td&gt;
&lt;td&gt;把字符串重复指定的次数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;str_replace()&lt;/td&gt;
&lt;td&gt;替换字符串中的一些字符（大小写敏感）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;str_rot13()&lt;/td&gt;
&lt;td&gt;对字符串执行 ROT13 编码。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;str_shuffle()&lt;/td&gt;
&lt;td&gt;随机地打乱字符串中的所有字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;str_split()&lt;/td&gt;
&lt;td&gt;把字符串分割到数组中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;str_word_count()&lt;/td&gt;
&lt;td&gt;计算字符串中的单词数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strcasecmp()&lt;/td&gt;
&lt;td&gt;比较两个字符串（大小写不敏感）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strchr()&lt;/td&gt;
&lt;td&gt;查找字符串在另一字符串中的第一次出现。（strstr() 的别名。）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strcmp()&lt;/td&gt;
&lt;td&gt;比较两个字符串（大小写敏感）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strcoll()&lt;/td&gt;
&lt;td&gt;比较两个字符串（根据本地设置）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strcspn()&lt;/td&gt;
&lt;td&gt;返回在找到任何指定的字符之前，在字符串查找的字符数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strip_tags()&lt;/td&gt;
&lt;td&gt;剥去字符串中的 HTML 和 PHP 标签。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;stripcslashes()&lt;/td&gt;
&lt;td&gt;删除由 addcslashes() 函数添加的反斜杠。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;stripslashes()&lt;/td&gt;
&lt;td&gt;删除由 addslashes() 函数添加的反斜杠。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;stripos()&lt;/td&gt;
&lt;td&gt;返回字符串在另一字符串中第一次出现的位置（大小写不敏感）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;stristr()&lt;/td&gt;
&lt;td&gt;查找字符串在另一字符串中第一次出现的位置（大小写不敏感）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strlen()&lt;/td&gt;
&lt;td&gt;返回字符串的长度。中文字符串的处理使用 mb_strlen() 函数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strnatcasecmp()&lt;/td&gt;
&lt;td&gt;使用一种&amp;quot;自然排序&amp;quot;算法来比较两个字符串（大小写不敏感）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strnatcmp()&lt;/td&gt;
&lt;td&gt;使用一种&amp;quot;自然排序&amp;quot;算法来比较两个字符串（大小写敏感）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strncasecmp()&lt;/td&gt;
&lt;td&gt;前 n 个字符的字符串比较（大小写不敏感）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strncmp()&lt;/td&gt;
&lt;td&gt;前 n 个字符的字符串比较（大小写敏感）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strpbrk()&lt;/td&gt;
&lt;td&gt;在字符串中搜索指定字符中的任意一个。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strpos()&lt;/td&gt;
&lt;td&gt;返回字符串在另一字符串中第一次出现的位置（大小写敏感）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strrchr()&lt;/td&gt;
&lt;td&gt;查找字符串在另一个字符串中最后一次出现。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strrev()&lt;/td&gt;
&lt;td&gt;反转字符串。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strripos()&lt;/td&gt;
&lt;td&gt;查找字符串在另一字符串中最后一次出现的位置(大小写不敏感)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strrpos()&lt;/td&gt;
&lt;td&gt;查找字符串在另一字符串中最后一次出现的位置(大小写敏感)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strspn()&lt;/td&gt;
&lt;td&gt;返回在字符串中包含的特定字符的数目。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strstr()&lt;/td&gt;
&lt;td&gt;查找字符串在另一字符串中的第一次出现（大小写敏感）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strtok()&lt;/td&gt;
&lt;td&gt;把字符串分割为更小的字符串。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strtolower()&lt;/td&gt;
&lt;td&gt;把字符串转换为小写字母。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strtoupper()&lt;/td&gt;
&lt;td&gt;把字符串转换为大写字母。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strtr()&lt;/td&gt;
&lt;td&gt;转换字符串中特定的字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;substr()&lt;/td&gt;
&lt;td&gt;返回字符串的一部分。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mb_substr()&lt;/td&gt;
&lt;td&gt;返回中文字符串的一部分。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;substr_compare()&lt;/td&gt;
&lt;td&gt;从指定的开始位置（二进制安全和选择性区分大小写）比较两个字符串。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;substr_count()&lt;/td&gt;
&lt;td&gt;计算子串在字符串中出现的次数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;substr_replace()&lt;/td&gt;
&lt;td&gt;把字符串的一部分替换为另一个字符串。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;trim()&lt;/td&gt;
&lt;td&gt;移除字符串两侧的空白字符和其他字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ucfirst()&lt;/td&gt;
&lt;td&gt;把字符串中的首字符转换为大写。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ucwords()&lt;/td&gt;
&lt;td&gt;把字符串中每个单词的首字符转换为大写。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;vfprintf()&lt;/td&gt;
&lt;td&gt;把格式化的字符串写到指定的输出流。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;vprintf()&lt;/td&gt;
&lt;td&gt;输出格式化的字符串。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;vsprintf()&lt;/td&gt;
&lt;td&gt;把格式化字符串写入变量中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wordwrap()&lt;/td&gt;
&lt;td&gt;按照指定长度对字符串进行折行处理。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
">PHP 5 String 函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/linuxmac-list-fields/"" data-c="
          &lt;p&gt;这篇文章主要介绍了Linux下统计当前文件夹下的文件个数、目录个数,本文使用ls命令配合管理、grep命令实现统计需求&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;1-统计当前文件夹下文件的个数&#34;&gt;1. 统计当前文件夹下文件的个数&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ls -l |grep &amp;quot;^-&amp;quot;|wc -l
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-统计当前文件夹下目录的个数&#34;&gt;2.  统计当前文件夹下目录的个数&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ls -l |grep &amp;quot;^d&amp;quot;|wc -l
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-统计当前文件夹下文件的个数包括子文件夹里的&#34;&gt;3. 统计当前文件夹下文件的个数，包括子文件夹里的&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ls -lR|grep &amp;quot;^-&amp;quot;|wc -l
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-统计文件夹下目录的个数包括子文件夹里的&#34;&gt;4. 统计文件夹下目录的个数，包括子文件夹里的&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ls -lR|grep &amp;quot;^d&amp;quot;|wc -l
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-说明&#34;&gt;5. 说明&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;代码如下:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ls -l
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;长列表输出当前文件夹下文件信息(注意这里的文件，不同于一般的文件，可能是目录、链接、设备文件等)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码如下:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;grep &amp;quot;^-&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里将长列表输出信息过滤一部分，只保留一般文件，如果只保留目录就是 ^d&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码如下:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;wc -l
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;统计输出信息的行数，因为已经过滤得只剩一般文件了，所以统计结果就是一般文件信息的行数，又由于一行信息对应一个文件，所以也就是文件的个数。&lt;/p&gt;
">Linux/Mac下统计当前文件夹下的文件个数、目录个数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/docker-pi/"" data-c="
          &lt;h3 id=&#34;1-使用官方安装脚本自动安装-仅适用于公网环境&#34;&gt;1. 使用官方安装脚本自动安装 （仅适用于公网环境）&lt;/h3&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-手动安装帮助-阿里云ecs可以通过内网安装见注释部分内容&#34;&gt;2. 手动安装帮助 (阿里云ECS可以通过内网安装，见注释部分内容)&lt;/h3&gt;
&lt;h4 id=&#34;ubuntu-1404-1604-使用apt-get进行安装&#34;&gt;Ubuntu 14.04 16.04 (使用apt-get进行安装)&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# step 1: 安装必要的一些系统工具
sudo apt-get update
sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common
# step 2: 安装GPG证书
curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -
# Step 3: 写入软件源信息
sudo add-apt-repository &amp;quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&amp;quot;
# Step 4: 更新并安装 Docker-CE
sudo apt-get -y update
sudo apt-get -y install docker-ce

注意：其他注意事项在下面的注释中
# 安装指定版本的Docker-CE:
# Step 1: 查找Docker-CE的版本:
# apt-cache madison docker-ce
#   docker-ce | 17.03.1~ce-0~ubuntu-xenial | http://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages
#   docker-ce | 17.03.0~ce-0~ubuntu-xenial | http://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages
# Step 2: 安装指定版本的Docker-CE: (VERSION 例如上面的 17.03.1~ce-0~ubuntu-xenial)
# sudo apt-get -y install docker-ce=[VERSION]

# 通过经典网络、VPC网络内网安装时，用以下命令替换Step 2、Step 3中的命令
# 经典网络：
# curl -fsSL http://mirrors.aliyuncs.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -
# sudo add-apt-repository &amp;quot;deb [arch=amd64] http://mirrors.aliyuncs.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&amp;quot;
# VPC网络：
# curl -fsSL http://mirrors.cloud.aliyuncs.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -
# sudo add-apt-repository &amp;quot;deb [arch=amd64] http://mirrors.cloud.aliyuncs.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;centos-7-使用yum进行安装&#34;&gt;CentOS 7 (使用yum进行安装)&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# step 1: 安装必要的一些系统工具
sudo yum install -y yum-utils device-mapper-persistent-data lvm2
# Step 2: 添加软件源信息
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
# Step 3: 更新并安装 Docker-CE
sudo yum makecache fast
sudo yum -y install docker-ce
# Step 4: 开启Docker服务
sudo service docker start

注意：其他注意事项在下面的注释中
# 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，你可以通过以下方式开启。同理可以开启各种测试版本等。
# vim /etc/yum.repos.d/docker-ce.repo
#   将 [docker-ce-test] 下方的 enabled=0 修改为 enabled=1
#
# 安装指定版本的Docker-CE:
# Step 1: 查找Docker-CE的版本:
# yum list docker-ce.x86_64 --showduplicates | sort -r
#   Loading mirror speeds from cached hostfile
#   Loaded plugins: branch, fastestmirror, langpacks
#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            docker-ce-stable
#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            @docker-ce-stable
#   docker-ce.x86_64            17.03.0.ce-1.el7.centos            docker-ce-stable
#   Available Packages
# Step2 : 安装指定版本的Docker-CE: (VERSION 例如上面的 17.03.0.ce.1-1.el7.centos)
# sudo yum -y install docker-ce-[VERSION]
# 注意：在某些版本之后，docker-ce安装出现了其他依赖包，如果安装失败的话请关注错误信息。例如 docker-ce 17.03 之后，需要先安装 docker-ce-selinux。
# yum list docker-ce-selinux- --showduplicates | sort -r
# sudo yum -y install docker-ce-selinux-[VERSION]

# 通过经典网络、VPC网络内网安装时，用以下命令替换Step 2中的命令
# 经典网络：
# sudo yum-config-manager --add-repo http://mirrors.aliyuncs.com/docker-ce/linux/centos/docker-ce.repo
# VPC网络：
# sudo yum-config-manager --add-repo http://mirrors.could.aliyuncs.com/docker-ce/linux/centos/docker-ce.repo
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安装校验&#34;&gt;安装校验&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;root@iZbp12adskpuoxodbkqzjfZ:$ docker version
Client:
 Version:      17.03.0-ce
 API version:  1.26
 Go version:   go1.7.5
 Git commit:   3a232c8
 Built:        Tue Feb 28 07:52:04 2017
 OS/Arch:      linux/amd64

Server:
 Version:      17.03.0-ce
 API version:  1.26 (minimum version 1.12)
 Go version:   go1.7.5
 Git commit:   3a232c8
 Built:        Tue Feb 28 07:52:04 2017
 OS/Arch:      linux/amd64
 Experimental: false
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;常用命令&#34;&gt;常用命令&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#查看 Docker 版本
docker -v
sudo docker pull 仓库/镜像:版本（留空的话默认为 latest）
sudo docker run 加参数，用来创建容器
#查看运行容器
sudo docker ps
#查看所有下载的镜像
sudo docker images
#进入容器终端
sudo docker exec -i -t ha /bin/bash
#实时查看10行的 ha 日志
sudo docker logs -f -t --tail 10 ha
#重启 systemctl 守护进程
sudo systemctl daemon-reload
#设置 Docker 开机启动
sudo systemctl enable docker
#开启 Docker 服务
sudo systemctl start docker

#下载 Docker 图形化界面 portainer
sudo docker pull portainer/portainer
#创建 portainer 容器
sudo docker volume create portainer_data
#运行 portainer
sudo docker run -d -p 9000:9000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料&#34;&gt;参考资料&lt;/h3&gt;
&lt;p&gt;其他关于旧版本Docker卸载以及测试开发版本Docker安装的帮助，可以参考官方文档的说明进行安装&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/engine/installation/linux/docker-ce/centos/?spm=a2c6h.12873639.0.0.1aba47efpIg1xo&#34;&gt;CentOS帮助链接&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/?spm=a2c6h.12873639.0.0.1aba47efpIg1xo&#34;&gt;Ubuntu帮助链接&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://docs.docker.com/engine/installation/linux/docker-ce/debian/?spm=a2c6h.12873639.0.0.1aba47efpIg1xo&#34;&gt;Debian帮助链接&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://docs.docker.com/engine/installation/linux/docker-ce/fedora/?spm=a2c6h.12873639.0.0.1aba47efpIg1xo&#34;&gt;Fedora帮助链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转自：&lt;a href=&#34;https://developer.aliyun.com/article/110806&#34;&gt;阿里云开发社区&lt;/a&gt;&lt;/p&gt;
">Docker CE 镜像源</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/qcloud-v/"" data-c="
          &lt;p&gt;本教程需要用到腾讯云的云函数SCF。没有腾讯云账户的请先申请账户，注册&lt;a href=&#34;https://cloud.tencent.com/act/cps/redirect-all?redirect=10135&amp;amp;opc_hash_key=XG7JfqCPIb8b1609&#34;&gt;腾讯云&lt;/a&gt;。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;1-浏览器打开腾讯视频官网&#34;&gt;1. 浏览器打开腾讯视频官网：&lt;/h3&gt;
&lt;p&gt;https://v.qq.com/&lt;br&gt;
登录VIP账号&lt;/p&gt;
&lt;h3 id=&#34;2-vip账号登录成功后打开另一个地址&#34;&gt;2. VIP账号登录成功后，打开另一个地址：&lt;/h3&gt;
&lt;p&gt;https://vip.video.qq.com/fcgi-bin/comm_cgi?name=hierarchical_task_system&amp;amp;cmd=2&lt;br&gt;
（没错这个就是签到地址。APP抓出来的。）&lt;/p&gt;
&lt;h3 id=&#34;3-在第二个地址按下快捷键ctrlshiftj&#34;&gt;3. 在第二个地址，按下快捷键：CTRL+SHIFT+J&lt;/h3&gt;
&lt;p&gt;在&amp;gt;后面输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;document.cookie
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;回车，复制【引号里】的内容（脚本要用的cookies）：&lt;/p&gt;
&lt;p&gt;用qq或者微信登录&lt;a href=&#34;https://console.cloud.tencent.com/scf&#34;&gt;腾讯云scf&lt;/a&gt;(无服务器云函数)&lt;/p&gt;
&lt;p&gt;函数服务=》（选择区域，上海，广州，成都，香港，北京）&lt;br&gt;
=》新建=》空白函数=》函数名称（随便写，比如txsp_qiandao）=》运行环境（python3.6）=》下一步&lt;/p&gt;
&lt;p&gt;复制下面代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# -*- coding: utf8 -*-
 
import requests
import re
import time
from urllib.parse import quote
 
def start():
    try:
        s = requests.session()
 
        cookie1 = &#39;TXSP_COOKIE&#39;
 
        this_time = int(round(time.time() * 1000))
 
        login_url = &#39;https://vip.video.qq.com/fcgi-bin/comm_cgi?name=hierarchical_task_system&amp;amp;cmd=2&amp;amp;_=&#39; + str(this_time)
 
        headers={
            &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.204 Safari/537.36&#39;,
            &#39;Cookie&#39;: cookie1
        }
 
        res =s.get(login_url,headers=headers).text
 
        print(&#39;访问结果：&#39;+res)
 
        if &#39;Account Verify Error&#39; in res:
            print(&#39;cookies失效，通知SERVER酱！&#39;)
            requests.get(&#39;https://sc.ftqq.com/SCKEY.send?text=&#39; + quote(&#39;腾讯视频自动签到失败~&#39;+time.strftime(&#39;%Y.%m.%d&#39;,time.localtime(time.time()))) +&#39;&amp;amp;desp=&#39;+quote(&#39;cookies失效，请更新！\n&#39;))
        else:
            print(&#39;签到完成&#39;)
 
    except Exception as e:
        print(&amp;quot;地址访问失败，通知SERVER酱！&amp;quot;)
        requests.get(&#39;https://sc.ftqq.com/SCKEY.send?text=&#39; + quote(&#39;腾讯视频自动签到失败~&#39;+time.strftime(&#39;%Y.%m.%d&#39;,time.localtime(time.time()))) +&#39;&amp;amp;desp=&#39;+quote(&#39;异常代码：\n&#39;+str(e)))
 
 
def main_handler(event, context):
    return start()
 
 
if __name__ == &#39;__main__&#39;:
    start()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码需要修改的地方3处，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TXSP_COOKIE （一处，刚才获取的cookies字符串）&lt;/li&gt;
&lt;li&gt;https://sc.ftqq.com/XXXX.send （两处，server酱的地址，申请地址：http://sc.ftqq.com/）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完成。&lt;/p&gt;
&lt;h3 id=&#34;4-触发方式定时触发-名称txsp_timer-自定义触发周期0-0-3-保存&#34;&gt;4. 触发方式=》定时触发 / 名称：txsp_timer / 自定义触发周期（0 0 3 * * * *）保存&lt;/h3&gt;
&lt;h3 id=&#34;5-函数代码测试如果日志显示checkin_score-5这个5就是获得的v力值签到过也会有中文提示&#34;&gt;5. 函数代码=》测试（如果日志显示”checkin_score”: 5，这个5就是获得的V力值，签到过也会有中文提示）&lt;/h3&gt;
&lt;h3 id=&#34;其他说明&#34;&gt;其他说明&lt;/h3&gt;
&lt;h4 id=&#34;1-如果日志里提示&#34;&gt;1. 如果日志里提示：&lt;/h4&gt;
&lt;p&gt;{“msg”:”Account Verify Error”,”ret”:-10006}说明COOKIES获取错误。&lt;/p&gt;
&lt;h4 id=&#34;2-cookie能用多久还不知道反正我挂了40多天了-验证失败了也会微信通知更新下cookies就行&#34;&gt;2. COOKIE能用多久还不知道，，反正我挂了40多天了。。。验证失败了，也会微信通知，更新下COOKIES就行。&lt;/h4&gt;
&lt;h4 id=&#34;3签到分数不保证-现在大多是10分左右偶尔50分-这个腾讯的锅~就当腾讯云函数来背吧~&#34;&gt;3.签到分数不保证。。现在大多是10分左右，偶尔50分+。。。这个腾讯的锅~&lt;s&gt;就当腾讯云函数来背吧&lt;/s&gt;~&lt;/h4&gt;
&lt;p&gt;来源(Source)：&lt;a href=&#34;https://lsdlhlx.top/2019/10/%E8%85%BE%E8%AE%AF%E8%A7%86%E9%A2%91%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0%E8%8E%B7%E5%BE%97v%E5%8A%9B%E5%80%BC/&#34;&gt;西瓜小窝&lt;/a&gt;&lt;/p&gt;
">腾讯视频自动签到获得V力值</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/ecmascript/"" data-c="
          &lt;p&gt;ECMAScript 2015～2020 思维导图&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1597377198390.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://imcm.xyz/post-images/1597377288128.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;转自：&lt;a href=&#34;http://es.xiecheng.live/&#34;&gt;XieCheng&lt;/a&gt;&lt;/p&gt;
">ECMAScript 2015～2020 语法思维导图</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/linux-zerotier-moon/"" data-c="
          &lt;h3 id=&#34;说明&#34;&gt;说明&lt;/h3&gt;
&lt;p&gt;zerotier 可以作为一款 p2p 的 vlan 内网穿透工具，功能强大且易用，同类产品还有 frp和 LanProxy等。最近有个朋友有创建 p2p vlan 的需求，在简单调研之后决定使用 zerotier 作为基础工具。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;官方给出的使用方案比较简单。首先需要一个中心的节点用于两个内网节点的握手，该中心节点需要有一个公网 IP。zerotier 官网提供了中心节点相关服务，免费账户有一定的使用限制，但是由于其节点位于国外，延迟比较高，且可能还需要科学上网才能使用。除此之外，zerotier 也支持自己搭建中心节点服务器，也叫做 MOON 服务器。下面是它的搭建步骤。&lt;/p&gt;
&lt;h3 id=&#34;moon-服务器配置&#34;&gt;MOON 服务器配置&lt;/h3&gt;
&lt;p&gt;操作系统版本是 &lt;code&gt;Ubuntu 18.04, Zerotier One&lt;/code&gt; 版本是 &lt;code&gt;v1.2.10&lt;/code&gt;, 公网 (也就是 MOON 服务器) 地址是 1.1.1.1。&lt;/p&gt;
&lt;h4 id=&#34;1-通过官网文档根据不同操作系统选择不同的安装方式这里直接通过命令行安装&#34;&gt;1. 通过&lt;a href=&#34;https://www.zerotier.com/&#34;&gt;官网&lt;/a&gt;文档根据不同操作系统选择不同的安装方式，这里直接通过命令行安装&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -s &#39;https://pgp.mit.edu/pks/lookup?op=get&amp;amp;search=0x1657198823E52A61&#39; | gpg --import &amp;amp;&amp;amp; \ if z=(curl -s &#39;https://install.zerotier.com/&#39; | gpg); then echo &amp;quot;z&amp;quot; | sudo bash; fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果上述命令运行失败，那么使用下面命令(建议用这个)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -s https://install.zerotier.com/ | sudo bash
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-将-moon-服务器加入-zerotier-局域网&#34;&gt;2. 将 MOON 服务器加入 Zerotier 局域网&lt;/h4&gt;
&lt;p&gt;虽然搭建了 MOON 服务器，我们还是需要借助 &lt;a href=&#34;https://my.zerotier.com/network&#34;&gt;zerotier network&lt;/a&gt;，也就是需要先通过 zerotier 官网创建一个 network，并且内网节点需要使用 &lt;code&gt;join&lt;/code&gt; 命令加入该网络才能实现内网节点的互通，换句话说 MOON 节点只起到了加速的作用，虚拟网络的分配和管理还是需要 zerotier 服务端参与。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zerotier-cli join &amp;lt;network id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-生成配置文件&#34;&gt;3. 生成配置文件&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo chmod 777 /var/lib/zerotier-one # 这里为了有写入文件的权限
cd /var/lib/zerotier-one
sudo zerotier-idtool initmoon identity.public &amp;gt; moon.json
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4-修改配置文件-moonjson主要是添加公网-ip修改内容如下9993-是默认端口&#34;&gt;4. 修改配置文件 &lt;code&gt;moon.json&lt;/code&gt;，主要是添加公网 IP，修改内容如下，&lt;code&gt;9993&lt;/code&gt; 是默认端口&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;quot;stableEndpoints&amp;quot;: [ &amp;quot;1.1.1.1/9993&amp;quot; ] #修改为VPS公网IP/9993
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还需要注意 &lt;code&gt;moon.json&lt;/code&gt; 中的 id 值，它是 MOON 服务器的 ID，是一个 10 位的字符串，我的为 &lt;code&gt;efe9e9a259&lt;/code&gt;，也可以用 &lt;code&gt;sudo zerotier-cli info&lt;/code&gt; 查看，后面会用到。&lt;/p&gt;
&lt;h4 id=&#34;5-生成-moon-文件&#34;&gt;5. 生成 moon 文件&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo zerotier-idtool genmoon moon.json
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;6-在-varlibzerotier-one-目录下新建-moonsd-文件夹中并将生成的-moon-文件放到该文件夹下我的-moon-文件名为-000000efe9e9a259moon&#34;&gt;6. 在 &lt;code&gt;/var/lib/zerotier-one&lt;/code&gt; 目录下新建 &lt;code&gt;moons.d&lt;/code&gt; 文件夹中，并将生成的 moon 文件放到该文件夹下，我的 moon 文件名为 &lt;code&gt;000000efe9e9a259.moon&lt;/code&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mv 000000efe9e9a259.moon moons.d/
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;7-重启-zerotier-one&#34;&gt;7. 重启 &lt;code&gt;zerotier-one&lt;/code&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo systemctl restart zerotier-one.service
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;内网节点配置本地设备&#34;&gt;内网节点配置(本地设备)&lt;/h3&gt;
&lt;h4 id=&#34;1-在内网节点安装-zerotier安装方法和上面类似根据文档选择不同操作系统的方法进行安装即可-请参考文章zerotier-无公网-ip-实现内网穿透&#34;&gt;1. 在内网节点安装 zerotier，安装方法和上面类似，根据&lt;a href=&#34;https://www.moewah.com/go/aHR0cHM6Ly93d3cuemVyb3RpZXIuY29tL2Rvd25sb2FkLnNodG1s&#34;&gt;文档&lt;/a&gt;选择不同操作系统的方法进行安装即可。请参考文章&lt;a href=&#34;https://www.moewah.com/archives/1474.html&#34;&gt;《ZeroTier 无公网 IP 实现内网穿透》&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;2-将-moon-节点添加到常规节点&#34;&gt;2. 将 MOON 节点添加到常规节点&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo zerotier-cli orbit efe9e9a259 efe9e9a259 # 注意这里是两次根节点的ID
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果没返回 &lt;code&gt;200 orbit OK&lt;/code&gt; 的话，需要手动拷贝生成的 moon 文件 &lt;code&gt;000000efe9e9a259.moon&lt;/code&gt; 文件到常规节点的机器上，位置如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Windows: C:\ProgramData\ZeroTier\One
Macintosh: /Library/Application Support/ZeroTier/One (在 Terminal 中应为 /Library/Application\ Support/ZeroTier/One)
Linux: /var/lib/zerotier-one
FreeBSD/OpenBSD: /var/db/zerotier-one
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-然后重启-zerotier-one&#34;&gt;3. 然后重启 zerotier-one&lt;/h4&gt;
&lt;p&gt;查看节点列表，出现根服务器的 MOON 节点表示成功&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; ~ sudo zerotier-cli listpeers
200 listpeers     
200 listpeers 3dfa0fd16b - -1 - LEAF
200 listpeers 8841408a2e 45.32.248.87/9993;11749;11453 252 1.1.5 PLANET
200 listpeers 9d219039f3 128.199.197.217/9993;11749;11381 390 1.1.5 PLANET
200 listpeers abfd31bd47 178.128.240.145/35368;6238;14319 509 1.2.5 LEAF
200 listpeers efe9e9a259 1.1.1.1/9993;6238;1184 36 1.2.12 MOON
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4-我们再在内网节点上运行-ifconfigwindows-是-ipconfig可以看到-zerotier-vlan-分配给其的内网-ip&#34;&gt;4. 我们再在内网节点上运行 ifconfig(windows 是 ipconfig)，可以看到 zerotier vlan 分配给其的内网 IP&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zt0: flags=8843 metric 5000 mtu 2800
    ether 1a:42:9a:39:7d:3f
    inet 10.147.18.127 netmask 0xffffff00 broadcast 10.147.18.255
    inet6 fe80::1842:9aff:fe39:7d3f%zt0 prefixlen 64 scopeid 0xc
    inet6 fcec:2f1a:a769:487e:c00e::1 prefixlen 40
    nd6 options=201
    media: autoselect
    status: active
    open (pid 84214)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的 &lt;code&gt;10.147.18.127&lt;/code&gt;就是其虚拟局域网的 IP，在另外一个局域网中通过上述过程配置另外一个节点，它的虚拟局域网 IP 为 &lt;code&gt;10.147.18.30&lt;/code&gt;，两个节点通过 &lt;code&gt;ping&lt;/code&gt; 可以互相通&lt;/p&gt;
&lt;p&gt;转自：&lt;a href=&#34;https://opt.gs/posts/56602/&#34;&gt;vps侦探&lt;/a&gt;&lt;/p&gt;
">LinuxVPS 自建ZeroTier 的MOON根目录服务器</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/laravel-facades/"" data-c="
          &lt;p&gt;这是一个查找给定 Facade 类 API 文档的工具。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Facade&lt;/th&gt;
&lt;th&gt;类&lt;/th&gt;
&lt;th&gt;服务容器绑定&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;App&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Foundation/Application.html&#34;&gt;Illuminate\Foundation\Application&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;app&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Artisan&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Contracts/Console/Kernel.html&#34;&gt;Illuminate\Contracts\Console\Kernel&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;artisan&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Auth&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Auth/AuthManager.html&#34;&gt;Illuminate\Auth\AuthManager&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;auth&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Auth (Instance)&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Contracts/Auth/Guard.html&#34;&gt;Illuminate\Contracts\Auth\Guard&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;auth.driver&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Blade&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/View/Compilers/BladeCompiler.html&#34;&gt;Illuminate\View\Compilers\BladeCompiler&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;blade.compiler&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Broadcast&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Contracts/Broadcasting/Factory.html&#34;&gt;Illuminate\Contracts\Broadcasting\Factory&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Broadcast (Instance)&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Contracts/Broadcasting/Broadcaster.html&#34;&gt;Illuminate\Contracts\Broadcasting\Broadcaster&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Bus&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Contracts/Bus/Dispatcher.html&#34;&gt;Illuminate\Contracts\Bus\Dispatcher&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Cache&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Cache/CacheManager.html&#34;&gt;Illuminate\Cache\CacheManager&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;cache&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Cache (Instance)&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Cache/Repository.html&#34;&gt;Illuminate\Cache\Repository&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;cache.store&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Config&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Config/Repository.html&#34;&gt;Illuminate\Config\Repository&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;config&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Cookie&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Cookie/CookieJar.html&#34;&gt;Illuminate\Cookie\CookieJar&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;cookie&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Crypt&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Encryption/Encrypter.html&#34;&gt;Illuminate\Encryption\Encrypter&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;encrypter&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DB&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Database/DatabaseManager.html&#34;&gt;Illuminate\Database\DatabaseManager&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;db&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DB (Instance)&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Database/Connection.html&#34;&gt;Illuminate\Database\Connection&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;db.connection&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Event&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Events/Dispatcher.html&#34;&gt;Illuminate\Events\Dispatcher&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;events&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;File&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Filesystem/Filesystem.html&#34;&gt;Illuminate\Filesystem\Filesystem&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;files&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Gate&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Contracts/Auth/Access/Gate.html&#34;&gt;Illuminate\Contracts\Auth\Access\Gate&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Hash&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Contracts/Hashing/Hasher.html&#34;&gt;Illuminate\Contracts\Hashing\Hasher&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;hash&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Lang&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Translation/Translator.html&#34;&gt;Illuminate\Translation\Translator&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;translator&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Log&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Log/Logger.html&#34;&gt;Illuminate\Log\Logger&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;log&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mail&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Mail/Mailer.html&#34;&gt;Illuminate\Mail\Mailer&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;mailer&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Notification&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Notifications/ChannelManager.html&#34;&gt;Illuminate\Notifications\ChannelManager&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Password&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Auth/Passwords/PasswordBrokerManager.html&#34;&gt;Illuminate\Auth\Passwords\PasswordBrokerManager&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;auth.password&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Password (Instance)&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Auth/Passwords/PasswordBroker.html&#34;&gt;Illuminate\Auth\Passwords\PasswordBroker&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;auth.password.broker&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Queue&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Queue/QueueManager.html&#34;&gt;Illuminate\Queue\QueueManager&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;queue&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Queue (Instance)&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Contracts/Queue/Queue.html&#34;&gt;Illuminate\Contracts\Queue\Queue&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;queue.connection&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Queue (Base Class)&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Queue/Queue.html&#34;&gt;Illuminate\Queue\Queue&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Redirect&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Routing/Redirector.html&#34;&gt;Illuminate\Routing\Redirector&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;redirect&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Redis&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Redis/RedisManager.html&#34;&gt;Illuminate\Redis\RedisManager&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;redis&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Redis (Instance)&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Redis/Connections/Connection.html&#34;&gt;Illuminate\Redis\Connections\Connection&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;redis.connection&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Request&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Http/Request.html&#34;&gt;Illuminate\Http\Request&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;request&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Response&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Contracts/Routing/ResponseFactory.html&#34;&gt;Illuminate\Contracts\Routing\ResponseFactory&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Response (Instance)&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Http/Response.html&#34;&gt;Illuminate\Http\Response&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Route&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Routing/Router.html&#34;&gt;Illuminate\Routing\Router&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;router&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Schema&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Database/Schema/Builder.html&#34;&gt;Illuminate\Database\Schema\Builder&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Session&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Session/SessionManager.html&#34;&gt;Illuminate\Session\SessionManager&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;session&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Session (Instance)&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Session/Store.html&#34;&gt;Illuminate\Session\Store&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;session.store&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Storage&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Filesystem/FilesystemManager.html&#34;&gt;Illuminate\Filesystem\FilesystemManager&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;filesystem&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Storage (Instance)&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Contracts/Filesystem/Filesystem.html&#34;&gt;Illuminate\Contracts\Filesystem\Filesystem&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;filesystem.disk&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;URL&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Routing/UrlGenerator.html&#34;&gt;Illuminate\Routing\UrlGenerator&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;url&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Validator&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Validation/Factory.html&#34;&gt;Illuminate\Validation\Factory&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;validator&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Validator (Instance)&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/Validation/Validator.html&#34;&gt;Illuminate\Validation\Validator&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;View&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/View/Factory.html&#34;&gt;Illuminate\View\Factory&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;view&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;View (Instance)&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://laravel.com/api/%7B%7Bversion%7D%7D/Illuminate/View/View.html&#34;&gt;Illuminate\View\View&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
">Facade 类参考</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/china-history/"" data-c="
          &lt;p&gt;公元前4300前——2500年：大汶口文化中晚期，处于父系氏族公社时期。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;约4000多年前：传说中的黄帝、尧、舜、禹时期。&lt;/p&gt;
&lt;p&gt;帝尧时期：尧命羲和观测天象，制定历法，以366日为一年。&lt;/p&gt;
&lt;p&gt;约公元前21世纪：禹将部落联盟首领之位传子启，夏朝建立。&lt;/p&gt;
&lt;p&gt;约公元前21前17世纪：二里头文化繁荣时期，二里头文化与我国历史记载中的夏朝时间基本相吻合。&lt;/p&gt;
&lt;p&gt;公元前2000年：中国约在此时已有凿井取水的技术。&lt;/p&gt;
&lt;p&gt;约公元前1600年：汤伐夏桀，战于鸣条，夏朝灭亡。&lt;/p&gt;
&lt;p&gt;约公元前16世纪：商汤制定刑法，后来称为《汤刑》。&lt;/p&gt;
&lt;p&gt;约公元前14世纪：盘庚即位，迁都于殷，商朝中兴。&lt;/p&gt;
&lt;p&gt;约公元前13世纪：商王武丁任命傅说为相，使商朝政治局面大有改善。&lt;/p&gt;
&lt;p&gt;约公元前12世纪：商朝进入青铜器全盛时代。&lt;/p&gt;
&lt;p&gt;公元前12世纪：周人首领古公亶父迁周人于岐山，周朝王业自此开始。&lt;/p&gt;
&lt;p&gt;公元前1046年：周武王率军伐商，在牧野之战中大败商军，灭亡商朝。&lt;/p&gt;
&lt;p&gt;公元前10世纪：周穆王西巡，会见西王母，在《穆天子传》中有记载。&lt;/p&gt;
&lt;p&gt;公元前9世纪：周厉王实行“专利”，引起国人不满。&lt;/p&gt;
&lt;p&gt;公元前841年：国人暴动，厉王出奔，召公、周公二相行政，号曰“共和”看，自此，中国历史始有准确年代。&lt;/p&gt;
&lt;p&gt;公元前828年：厉王死于彘，召公、周公立太子静为王，是为周宣王。&lt;/p&gt;
&lt;p&gt;公元前771年：申侯与缯、西夷犬戎攻周幽王，杀之于骊山，西周亡。&lt;/p&gt;
&lt;p&gt;公元前770年：周平王自镐京东迁洛邑，自是年起史称东周。&lt;/p&gt;
&lt;p&gt;公元前750年：秦文公伐戎，戎败，文公收其民。&lt;/p&gt;
&lt;p&gt;公元前722年：史书《春秋》记事从本年开始。&lt;/p&gt;
&lt;p&gt;公元前685年：齐桓公即位，以管仲为相，齐国实力大增，成为霸主。&lt;/p&gt;
&lt;p&gt;公元前684年：齐鲁长勺之战，齐师败绩。&lt;/p&gt;
&lt;p&gt;公元前632年：晋国联合齐、宋、秦之师破楚师于城濮，晋文公盟诸侯于践土。&lt;/p&gt;
&lt;p&gt;公元前594年：鲁国实行“初税亩”，标志井田制开始瓦解。&lt;/p&gt;
&lt;p&gt;公元前536年：郑国子产铸刑书。&lt;/p&gt;
&lt;p&gt;公元前514年：吴王阖闾召伍员为行人（外交官），与其共谋国事。&lt;/p&gt;
&lt;p&gt;公元前479年：孔子去世，孔子是我国古代著名思想家、教育家，为儒家学派创始人。&lt;/p&gt;
&lt;p&gt;公元前473年：越王勾践灭吴，后会齐、晋诸侯于徐州，成为诸侯霸主。&lt;/p&gt;
&lt;p&gt;公元前453年：晋国赵、韩、魏三家共灭智氏，三分其领地。&lt;/p&gt;
&lt;p&gt;公元前445年：魏文侯即位。他在位期间，任用李悝在魏国实行变法。&lt;/p&gt;
&lt;p&gt;公元前403年：周威烈王命赵、韩、魏列为诸侯。&lt;/p&gt;
&lt;p&gt;公元前391年：齐国田和迁齐康公于海上，田氏遂有齐国。&lt;/p&gt;
&lt;p&gt;公元前381年：楚悼王卒，他在位期间任用吴起在楚国变法。&lt;/p&gt;
&lt;p&gt;公元前356年：秦孝公任用商鞅，实行变法。&lt;/p&gt;
&lt;p&gt;公元前221年：战国时期结束，秦王嬴政建立起中国封建社会历史上第一个统一王朝——秦朝。&lt;/p&gt;
&lt;p&gt;公元前202年：刘邦称帝，是为汉高祖刘邦，建立汉朝，定都长安。&lt;/p&gt;
&lt;p&gt;公元前141年：汉景帝死，皇太子彻嗣位，是为汉武帝。文帝、景帝统治时期，汉朝社会经济逐渐发展，史称“文景之治”。&lt;/p&gt;
&lt;p&gt;公元前119年：卫青、霍去病分道出击匈奴，其后匈奴远徙，漠南无王庭。&lt;/p&gt;
&lt;p&gt;公元前51年：汉宣帝召集石渠阁会议，讲论五经异同。&lt;/p&gt;
&lt;p&gt;公元8年：王莽即真天子位，定国号曰“新”，西汉灭亡。&lt;/p&gt;
&lt;p&gt;公元25年：刘秀称帝，建元建武，是为东汉光武帝。&lt;/p&gt;
&lt;p&gt;公元92年：汉和帝与宦官郑众定议，诛大将军窦宪，郑众以功封侯，是为东汉宦官用权之始。&lt;/p&gt;
&lt;p&gt;公元166年：第一次党锢之祸，司隶校尉李膺等200余人被称为党人，逮捕下狱。&lt;/p&gt;
&lt;p&gt;公元184年：张角率众起义，因起义军皆戴黄巾，故称黄巾起义。&lt;/p&gt;
&lt;p&gt;公元265年：司马炎废魏主，称帝，是为晋武帝，定都洛阳。&lt;/p&gt;
&lt;p&gt;公元357年：前秦苻坚即位，称大秦天王，汉人王猛辅政。&lt;/p&gt;
&lt;p&gt;公元383年：晋秦淝水之战，前秦大败，内部分崩。&lt;/p&gt;
&lt;p&gt;公元399～412年：高僧法显前往天竺求佛，著有《佛国记》。&lt;/p&gt;
&lt;p&gt;公元420年：刘裕废晋恭帝自立，国号宋，史称刘宋，是为宋武帝。南朝开始。&lt;/p&gt;
&lt;p&gt;公元500年：祖冲之去世，生前首次把圆周率准确数值推算到小数点后七位数。&lt;/p&gt;
&lt;p&gt;公元581年：杨坚称帝，国号隋，是为隋文帝，建都长安。&lt;/p&gt;
&lt;p&gt;公元618年：李渊称帝，国号唐，是为唐高祖，隋朝亡。&lt;/p&gt;
&lt;p&gt;公元645年：玄奘取经而还，抵达长安，《大唐西域记》成书。&lt;/p&gt;
&lt;p&gt;公元690年：武则天废睿宗，称帝，改国号为周。&lt;/p&gt;
&lt;p&gt;公元705年：张柬之等人发动政变，逼武则天退位，复立中宗李显，复国号唐。&lt;/p&gt;
&lt;p&gt;公元713年：唐朝封靺鞨首领大祚荣为都督、渤海郡王。&lt;/p&gt;
&lt;p&gt;公元738年：《唐六典》成书。&lt;/p&gt;
&lt;p&gt;公元745年：唐玄宗敕改波斯（景教）寺为大秦寺。&lt;/p&gt;
&lt;p&gt;公元755年：唐朝爆发安史之乱，由盛转衰。&lt;/p&gt;
&lt;p&gt;公元813年：唐宪宗元和八年，李吉甫撰成《元和郡县图志》。&lt;/p&gt;
&lt;p&gt;公元907年：朱温逼唐哀帝禅让，即帝位，改名朱晃，是为后梁太祖，史称后梁，唐朝亡。&lt;/p&gt;
&lt;p&gt;公元916年：契丹首领耶律阿保机称帝，是为辽太祖，建契丹。&lt;/p&gt;
&lt;p&gt;公元960年：陈桥兵变，赵匡胤即位，是为宋太祖，国号宋，后周亡。&lt;/p&gt;
&lt;p&gt;公元993年：王小波、李顺起义。&lt;/p&gt;
&lt;p&gt;1038年：党项首领元昊称帝，国号大夏，史称西夏，是为西夏景宗，建都兴庆府。&lt;/p&gt;
&lt;p&gt;1127年：金军俘宋徽、钦二帝北还，北宋灭亡。康王赵构于南京应天府即位，是为宋高宗，建立南宋。&lt;/p&gt;
&lt;p&gt;1141年：宋金议和，史称绍兴和议。&lt;/p&gt;
&lt;p&gt;1164年：隆兴和议，宋金重订和约。&lt;/p&gt;
&lt;p&gt;1279年：元军攻破崖山，宋帝溺死，宋亡。&lt;/p&gt;
&lt;p&gt;1286年：《农桑辑要》颁行，为中国现存最古的官修农书。&lt;/p&gt;
&lt;p&gt;1345年：元朝修成《辽史》《金史》《宋史》。&lt;/p&gt;
&lt;p&gt;1355年：刘福通迎韩山童之子韩林儿为帝，建国号宋，改元龙凤，韩林儿号小明王。&lt;/p&gt;
&lt;p&gt;1368年：朱元璋在应天府即帝位，国号明，是为明太祖。&lt;/p&gt;
&lt;p&gt;1399～1402年：燕王朱棣发动靖难之役，攻占南京，即位称帝，是为明成祖。&lt;/p&gt;
&lt;p&gt;1405年：明成祖命宦官郑和与王景弘等使南洋各地，郑和下西洋自此始。&lt;/p&gt;
&lt;p&gt;1407年：明成祖永乐五年，《永乐大典》成书。&lt;/p&gt;
&lt;p&gt;1421年：明成祖迁都北京，以南京为留都。&lt;/p&gt;
&lt;p&gt;1429年：明朝设钞关，以船只大小收税，称“船料”。&lt;/p&gt;
&lt;p&gt;1449年：瓦剌也先犯大同，英宗率军亲征，在土木堡被瓦剌军所破，英宗被俘，史称“土木之变”。&lt;/p&gt;
&lt;p&gt;1457年：宦官曹吉祥及其党羽石亨等乘景帝病危，迎太上皇英宗复位，史称“夺门之变”。&lt;/p&gt;
&lt;p&gt;1521～1524年：大礼议之争，群臣力争，下狱者100多人。&lt;/p&gt;
&lt;p&gt;1542年：宫婢杨金英等谋杀世宗未遂，史称嘉靖“宫婢之变”。&lt;/p&gt;
&lt;p&gt;1563年：巡抚谭纶率戚继光、俞大猷、刘显三将大破倭寇，收复兴化，浙、闽倭寇渐平。&lt;/p&gt;
&lt;p&gt;1571年：明朝封俺答为顺义王，开互市。&lt;/p&gt;
&lt;p&gt;1581年：张居正进行赋役制度改革，全面推行一条鞭法。&lt;/p&gt;
&lt;p&gt;1587年：海瑞死于南京右都御史任上，百姓为之罢市致哀。&lt;/p&gt;
&lt;p&gt;1588年：努尔哈赤统一建州女真。&lt;/p&gt;
&lt;p&gt;1594年：顾宪成被责革职，遂回无锡修东林书院讲学，讽议朝政评论人物，东林党议始于此。&lt;/p&gt;
&lt;p&gt;1599年：明神宗遣宦官至各地征税、办矿，激起临清、沙市、武昌、汉阳等地民变。&lt;/p&gt;
&lt;p&gt;1600年：耶稣会教士利玛窦到达北京，明神宗允许在京师建教堂传教。&lt;/p&gt;
&lt;p&gt;1615年：努尔哈赤正式建立八旗制度。&lt;/p&gt;
&lt;p&gt;1616年：努尔哈赤在赫图阿拉称汗，国号金，史称后金。&lt;/p&gt;
&lt;p&gt;1618年：后金汗努尔哈赤以“七大恨”誓师伐明。&lt;/p&gt;
&lt;p&gt;1619年：萨尔浒之战，明军大败。&lt;/p&gt;
&lt;p&gt;1621年：后金攻陷沈阳，又陷辽阳，并迁都辽阳。&lt;/p&gt;
&lt;p&gt;1625年：后金迁都沈阳，改称盛京。&lt;/p&gt;
&lt;p&gt;1633年：高迎祥、李自成、张献忠等起义军渡黄河南下，进入豫西。&lt;/p&gt;
&lt;p&gt;1636年：皇太极即帝位，改国号为清。&lt;/p&gt;
&lt;p&gt;1637年：宋应星所著《天工开物》刊行。&lt;/p&gt;
&lt;p&gt;1641年：李自成起义军攻入洛阳，杀明福王朱常洵。&lt;/p&gt;
&lt;p&gt;1644年：李自成率大顺军攻占北京，明崇祯帝自缢，明亡。&lt;/p&gt;
&lt;p&gt;1655年：清世祖顺治帝于内十三衙门立铁牌，严禁太监干政。&lt;/p&gt;
&lt;p&gt;1661年：郑成功率军驱逐荷兰殖民者，收复台湾。&lt;/p&gt;
&lt;p&gt;1729年：因西北用兵，设军机房，后改为军机处。&lt;/p&gt;
&lt;p&gt;1735年：清世宗雍正帝去世，子弘历继位，是为清高宗，改元乾隆。&lt;/p&gt;
&lt;p&gt;1747年：大金川土司沙罗奔举兵反，清廷派重兵平叛，两年后平定。&lt;/p&gt;
&lt;p&gt;1762年：清廷设伊犁将军，总统新疆南北两路事务。&lt;/p&gt;
&lt;p&gt;1771年：土尔扈特部在首领渥巴锡率领下，长途跋涉，从沙俄重返祖国。&lt;/p&gt;
&lt;p&gt;1776年：大金川索诺木出降，大小金川之役结束。&lt;/p&gt;
&lt;p&gt;1782年：第一部《四库全书》修成。&lt;/p&gt;
&lt;p&gt;1784年：美国商船“中国皇后”号从纽约出发，绕道非洲好望角，驶抵广州。&lt;/p&gt;
&lt;p&gt;1785年：乾隆帝于乾清宫设“千叟宴”，60岁以上老人入宴者达3000人。&lt;/p&gt;
&lt;p&gt;1793年：乾隆帝在热河行宫接见英国马戛尔尼使团。&lt;/p&gt;
&lt;p&gt;1795年：乾隆帝立皇十五子颙琰为皇太子，定明年继承皇位，改元嘉庆。&lt;/p&gt;
&lt;p&gt;1813年：林清率领的起义军攻入紫禁城，旋即失败。&lt;/p&gt;
&lt;p&gt;1814年：纂辑《全唐文》告成，全书1000卷，收入作家3000多人，作品18000多篇。&lt;/p&gt;
&lt;p&gt;1814年：史学家赵翼去世，著有《廿二史札记》《皇朝武功纪盛》等。&lt;/p&gt;
&lt;p&gt;1821年：清廷重申禁烟令，严禁在澳门、黄埔囤放和售卖鸦片。&lt;/p&gt;
&lt;p&gt;1822年：清廷定例禁止银两出洋。&lt;/p&gt;
&lt;p&gt;1823年：医学家陈念祖去世，著作颇丰，以《医学三字经》广为流传。&lt;/p&gt;
&lt;p&gt;1824年：林则徐综办江浙水利。&lt;/p&gt;
&lt;p&gt;1825年：《西夏书事》刊行，吴广成辑唐以来诸史、文集和野史有关西夏史事，以编年体成书。&lt;/p&gt;
&lt;p&gt;1826年：贺长龄、魏源等编《皇朝经世文编》成书，120卷，搜录重要史料。&lt;/p&gt;
&lt;p&gt;1829年：洋钱、鸦片为害日甚，道光帝命严行查禁。&lt;/p&gt;
&lt;p&gt;1830年：小说家李汝珍约于此年去世，著有长篇小说《镜花缘》。&lt;/p&gt;
&lt;p&gt;1833年：清廷定洋银与纹银使用条例。&lt;/p&gt;
&lt;p&gt;1839年：林则徐在虎门海滩销毁收缴的鸦片。&lt;/p&gt;
&lt;p&gt;1840年：鸦片战争爆发。清廷命琦善为钦差大臣，赴广州与英谈判，林则徐被革职。&lt;/p&gt;
&lt;p&gt;1842年：清廷被迫与英国签订《南京条约》。&lt;/p&gt;
&lt;p&gt;1844年：清廷被迫先后签订中美《望厦条约》、中法《黄埔条约》。&lt;/p&gt;
&lt;p&gt;1845年：英国驻沪领事与上海道台订立《上海租地章程》，是为外国侵略者在中国设立租界的开始。&lt;/p&gt;
&lt;p&gt;1851年：太平天国起义爆发。&lt;/p&gt;
&lt;p&gt;1853年：太平军沿长江东下，占领南京，定为首都，改称天京。&lt;/p&gt;
&lt;p&gt;1853年：太平天国颁布《天朝田亩制度》。&lt;/p&gt;
&lt;p&gt;1855年：太平军北伐失败，主将林凤祥、李开芳牺牲。&lt;/p&gt;
&lt;p&gt;1856年：太平天国发生天京事变。&lt;/p&gt;
&lt;p&gt;1856年：英国借口“亚罗号事件”，挑起第二次鸦片战争。&lt;/p&gt;
&lt;p&gt;1857年：石达开受洪秀全猜忌，率众自天京出走。&lt;/p&gt;
&lt;p&gt;1858年：俄、美、英、法逼迫清廷相继签订《天津条约》。&lt;/p&gt;
&lt;p&gt;1859年：太平天国颁布《资政新篇》。&lt;/p&gt;
&lt;p&gt;1860年：美国人华尔组成“洋枪队”，协助清廷镇压太平军。&lt;/p&gt;
&lt;p&gt;1860年：英法联军攻陷北京，恭亲王与英、法、俄分别签订《北京条约》。&lt;/p&gt;
&lt;p&gt;1861年：咸丰卒，慈禧发动政变，慈禧、慈安两太后垂帘听政，史称“辛酉政变”。&lt;/p&gt;
&lt;p&gt;1864年：天京为清军攻陷，太平天国起义失败。&lt;/p&gt;
&lt;p&gt;1872年：李鸿章在上海创办轮船招商局，侨商陈启源在广东南海创办继昌隆缫丝局，中国民族资本主义近代工业开始出现。&lt;/p&gt;
&lt;p&gt;1875年：清廷以兵部侍郎郭嵩焘任出使英国钦差大臣，为中国正式派遣驻外使节的开始。&lt;/p&gt;
&lt;p&gt;1885年：清军取得谅山大捷，此后李鸿章和法国公使巴德诺在天津签订《中法新约》，中法战争结束。&lt;/p&gt;
&lt;p&gt;1888年：北洋海军建成，以丁汝昌为提督，林泰曾、刘步蟾为左、右翼总兵。&lt;/p&gt;
&lt;p&gt;1894年：中日甲午战争爆发。&lt;/p&gt;
&lt;p&gt;1898年：光绪帝下“明定国是”诏书，戊戌变法开始。八月初六（9月21日），慈禧幽禁光绪帝于瀛台，百日维新失败。&lt;/p&gt;
&lt;p&gt;1900年：由英国海军上将西摩尔统率的八国联军进犯北京。&lt;/p&gt;
&lt;p&gt;1901年：清廷与俄、英、美、日、德、法、意、奥、比、西、荷等十一国签订《辛丑条约》。&lt;/p&gt;
&lt;p&gt;1905年：清廷废除科举考试制度。&lt;/p&gt;
&lt;p&gt;1911年：四川保路运动爆发。&lt;/p&gt;
&lt;p&gt;1911年：辛亥革命。&lt;/p&gt;
&lt;p&gt;1912年：南京临时政府成立，孙中山就任临时大总统，定国号为中华民国。&lt;/p&gt;
&lt;p&gt;1913年：“二次革命”爆发，以失败告终。&lt;/p&gt;
&lt;p&gt;1914年：袁世凯废除《中华民国临时约法》，公布《中华民国约法》。&lt;/p&gt;
&lt;p&gt;1915年：日本提出灭亡中国的“二十一条”。&lt;/p&gt;
&lt;p&gt;1917年：张勋复辟，旋即失败。&lt;/p&gt;
&lt;p&gt;1919年：“五四”运动爆发。&lt;/p&gt;
&lt;p&gt;1919年：中华革命党改组为中国国民党。&lt;/p&gt;
&lt;p&gt;1921年：中国共产党成立。&lt;/p&gt;
&lt;p&gt;1922年：第一次直奉战争爆发。&lt;/p&gt;
&lt;p&gt;1923年：京汉铁路工人大罢工。&lt;/p&gt;
&lt;p&gt;1924年：黄埔军校建立。&lt;/p&gt;
&lt;p&gt;1925年：3月12日，孙中山在北京逝世。&lt;/p&gt;
&lt;p&gt;1927年：《现代评论》创刊于北京，形成现代评论派。&lt;/p&gt;
&lt;p&gt;1927年：汉口、九江民众收回英租界。&lt;/p&gt;
&lt;p&gt;1928年：皇姑屯事件，张作霖死。&lt;/p&gt;
&lt;p&gt;1930年：蒋阎冯中原大战。&lt;/p&gt;
&lt;p&gt;1931年：日本帝国主义在沈阳制造“九一八”事变。&lt;/p&gt;
&lt;p&gt;1935年：聂耳为电影《风云儿女》主题歌谱曲《义勇军进行曲》。&lt;/p&gt;
&lt;p&gt;1935年：曾朴于本年去世，著有长篇小说《孽海花》。&lt;/p&gt;
&lt;p&gt;1935年：“一二·九”运动爆发。&lt;/p&gt;
&lt;p&gt;1936年：12月12日，张学良、杨虎城发动西安事变。&lt;/p&gt;
&lt;p&gt;1937年：卢沟桥事变发生，全面抗日战争开始。&lt;/p&gt;
&lt;p&gt;1937年：12月，南京陷落，日军入城大肆杀戮。&lt;/p&gt;
&lt;p&gt;1940年：八路军发动百团大战。&lt;/p&gt;
&lt;p&gt;1941年：陈纳德飞虎队来中国协助抗战。&lt;/p&gt;
&lt;p&gt;1945年：中、美、英三国发表《波茨坦公告》，促令日本无条件投降。&lt;/p&gt;
&lt;p&gt;1945年：中印公路全线贯通。&lt;/p&gt;
&lt;p&gt;1945年：抗日战争胜利。&lt;/p&gt;
&lt;p&gt;1945年：孙犁创作短篇小说《荷花淀》。&lt;/p&gt;
&lt;p&gt;1946年：巴金写成中篇小说《寒夜》。&lt;/p&gt;
&lt;p&gt;1947年：土地改革运动在解放区全面展开。&lt;/p&gt;
&lt;p&gt;1949年：10月1日，中华人民共和国成立。&lt;/p&gt;
&lt;p&gt;1953年：开始执行发展国民经济的第一个五年计划。&lt;/p&gt;
&lt;p&gt;1955年：成（都）——阿（坝）公路全线通车，全长507千米。&lt;/p&gt;
&lt;p&gt;1957年：第一届中国出口商品交易会在广州举行（简称“广交会”）。&lt;/p&gt;
&lt;p&gt;1965年：中国人工合成结晶牛胰岛素，是世界上首次人工合成蛋白质。&lt;/p&gt;
&lt;p&gt;1980年：中国向太平洋预定海域发射的第一枚运载火箭获得圆满成功。&lt;/p&gt;
&lt;p&gt;1984年：中国体育代表团在美国洛杉矶举行的第23届奥运会上获得15枚金牌，实现了中国在奥运会金牌榜上零的突破。&lt;/p&gt;
&lt;p&gt;1987年：中葡两国政府在北京签署关于澳门问题的联合声明，确认中国政府于1999年12月20日对澳门恢复行使主权。&lt;/p&gt;
&lt;p&gt;1988年：北京正负电子对撞机首次对撞成功。&lt;/p&gt;
&lt;p&gt;1990年：第11届亚洲运动会在北京举行，这是中国第一次承办综合性国际体育大赛。&lt;/p&gt;
&lt;p&gt;1997年：7月1日，中国政府对香港恢复行使主权。&lt;/p&gt;
&lt;p&gt;1999年：12月20日，中国政府对澳门恢复行使主权。&lt;/p&gt;
"> 中国大事记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/linux-systemd-start/"" data-c="
          &lt;p&gt;下面的教程将介绍如何将命令或程序配置为开机启动时自动运行的服务。完成配置之后，就可以通过 Linux 命令行来「启动/停止/禁用」这个服务了。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;创建服务&#34;&gt;创建服务&lt;/h2&gt;
&lt;p&gt;在树莓派上创建一个 .service 文件。例如：&lt;/p&gt;
&lt;p&gt;myscript.service&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[Unit]
Description=My service
After=network.target

[Service]
ExecStart=/usr/bin/python3 -u main.py
WorkingDirectory=/home/pi/myscript
StandardOutput=inherit
StandardError=inherit
Restart=always
User=pi

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的范例中，服务会去以 Python 3 来运行 /home/pi/myscript 目录下面的 main.py 脚本。用这种方法，你不仅可以配置 Python 脚本，只需要将 ExecStart 这行改为需要启动的任何程序或脚本即可。&lt;/p&gt;
&lt;p&gt;将这个文件用 root 用户保存到 /etc/systemd/system 目录：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo cp myscript.service /etc/systemd/system/myscript.service
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后就可以用下面的命令尝试启动服务了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo systemctl start myscript.service
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;停止服务：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo systemctl stop myscript.service
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置开机时自动运行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo systemctl enable myscript.service
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;systemctl 命令还可以用来重启或禁用它。&lt;/p&gt;
&lt;h2 id=&#34;注意事项&#34;&gt;注意事项：&lt;/h2&gt;
&lt;p&gt;1、启动顺序取决于他们的依赖关系。如果是依赖于网络的服务，应当在引导过程中尽可能晚一点启动。&lt;br&gt;
使用 man systemctl 命令或访问 https://fedoramagazine.org/what-is-an-init-system/ 了解更多。&lt;/p&gt;
&lt;p&gt;本文转自：&lt;a href=&#34;https://shumeipai.nxez.com/2020/06/30/linux-usage-systemd.html&#34;&gt;树莓派实验室&lt;/a&gt;&lt;/p&gt;
">Linux 下使用 systemd 设置开机启动项</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/mac-nvm/"" data-c="
          &lt;h2 id=&#34;1-安装命令行工具&#34;&gt;1. 安装命令行工具&lt;/h2&gt;
&lt;p&gt;你需要在 Mac 下安装苹果系统的命令行工具，你可以通过两个方法来安装，第一是在 App Store 上搜索 XCode 进行安装（推荐）；第二是通过以下命令来安装命令行工具：&lt;/p&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ xcode-select --install
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你使用第一种方法安装 XCode 来安装命令行工具，你需要至少启动一次 XCode ，接受了苹果的软件使用协议后，才能正常使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-安装-nvm&#34;&gt;2. 安装 NVM&lt;/h2&gt;
&lt;p&gt;安装完成命令行工具后，即可通过以下命令来安装 nvm：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者你也可以选择手动安装 NVM，首先你把项目 &lt;code&gt;https://github.com/creationix/nvm&lt;/code&gt; clone 到本地文件夹 &lt;code&gt;~/.nvm&lt;/code&gt; ，然后将以下两行代码加到你的启动脚本中 (&lt;code&gt;~/.bash_profile&lt;/code&gt;, &lt;code&gt;~/.zshrc&lt;/code&gt;, &lt;code&gt;~/.profile&lt;/code&gt;, 或者 &lt;code&gt;~/.bashrc&lt;/code&gt;)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export NVM_DIR=&amp;quot;$HOME/.nvm&amp;quot;
[ -s &amp;quot;$NVM_DIR/nvm.sh&amp;quot; ] &amp;amp;&amp;amp; \. &amp;quot;$NVM_DIR/nvm.sh&amp;quot; # This loads nvm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实，以上的 &lt;code&gt;install.sh&lt;/code&gt; 脚本也是这样操作的，&lt;a href=&#34;https://github.com/creationix/nvm#manual-install&#34;&gt;详见这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;NVM 安装后，你需要重启你的命令行会话，或者重新打开一个命令行窗口。&lt;/p&gt;
&lt;h2 id=&#34;3-测试一下&#34;&gt;3. 测试一下&lt;/h2&gt;
&lt;p&gt;命令行下测试：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ nvm --version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会输出：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1594260048253.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;4-nvm-的基本使用&#34;&gt;4. NVM 的基本使用&lt;/h2&gt;
&lt;p&gt;查看本地所有可以用的 Node.js 版本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ nvm list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看服务器端可用的 Node.js 版本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ nvm ls-remote
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;推荐使用 8.* LTS 版本 (长久维护版本) ，使用以下命令安装:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ nvm install 8.11.2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置默认版本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ nvm use 8.11.2
$ nvm alias default 8.11.2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;检查 Node.js 的版本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ node -v
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你应该能看到如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1594260041310.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;使用淘宝进行加速 NPM ：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ npm config set registry=https://registry.npm.taobao.org
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用以下命令将 NPM 更新到最新：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ npm install -g npm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更新后使用以下命令检测版本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ npm -v
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此安装完成。&lt;/p&gt;
&lt;p&gt;本文章转载于 &lt;a href=&#34;https://learnku.com/docs/environment-setup/install-nvm-under-mac/3132&#34;&gt;LearnKu.com&lt;/a&gt; 网站。&lt;/p&gt;
">Mac 下安装 NVM</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/github-restful-api/"" data-c="
          &lt;h2 id=&#34;什么是-restful&#34;&gt;什么是 RESTful&lt;/h2&gt;
&lt;!-- more --&gt;
&lt;p&gt;RESTful 是一种软件设计风格，由 &lt;a href=&#34;http://roy.gbiv.com/&#34;&gt;Roy Fielding&lt;/a&gt; 在他的 &lt;a href=&#34;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&#34;&gt;论文&lt;/a&gt; 中提出，全称为 &lt;code&gt;Representational State Transfer&lt;/code&gt;，直译为&lt;code&gt;表现层状态转移&lt;/code&gt;，或许可以解释为&lt;code&gt;用 URL 定位资源，用 HTTP 动词描述操作&lt;/code&gt;，不用太纠结于定义，接下来我们会详细讨论。&lt;/p&gt;
&lt;p&gt;RESTful 风格的接口，目前来看，实现的最好的就是 &lt;a href=&#34;https://developer.github.com/v3/&#34;&gt;Github API&lt;/a&gt;，经常被效仿。接下来我们通过分析 Github API 来引出我们的 API 设计原则。&lt;/p&gt;
&lt;h2 id=&#34;为什么选择-restful&#34;&gt;为什么选择 RESTful&lt;/h2&gt;
&lt;p&gt;我认为一套接口应该尽量满足以下几个原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安全可靠，高效，易扩展。&lt;/li&gt;
&lt;li&gt;简单明了，可读性强，没有歧义。&lt;/li&gt;
&lt;li&gt;API 风格统一，调用规则，传入参数和返回数据有统一的标准。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们当然可以根据自己的经验，或者参考知名公司的接口总结设计出一套满足要求的接口，但是每个人对接口的理解不同，设计出来的接口也会有所不同，接口的命名，请求参数的格式，响应的结果，错误响应的错误码，等等很多地方都会有不一样的实现。当你去寻求一种设计理念来帮助我们设计出满足要求的接口，一定会发现 RESTful。&lt;br&gt;
RESTful 的设计理念基于 HTTP 协议，因为 &lt;a href=&#34;http://roy.gbiv.com/&#34;&gt;Roy Fielding&lt;/a&gt; 就是 HTTP 协议（1.0 版和 1.1 版）的主要设计者。它是一种设计风格，没有规定我们一定如何实现，但是为我们提供了很好的设计理念。风格的统一，使得我们不需要过多的解释，就能让使用者明白该如何使用，同时也会有很多现成的工具来帮助我们实现 RESTful 风格的接口。&lt;/p&gt;
&lt;h2 id=&#34;restful-设计原则&#34;&gt;RESTful 设计原则&lt;/h2&gt;
&lt;h3 id=&#34;1-https&#34;&gt;1. HTTPS&lt;/h3&gt;
&lt;p&gt;HTTPS 为接口的安全提供了保障，可以有效防止通信被窃听和篡改。而且现在部署 HTTPS 的成本也越来越低，你可以通过 certbot 等工具，方便快速的制作免费的安全证书，所以生产环境，请务必使用 HTTPS。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;另外注意，非 HTTPS 的 API 调用，不要重定向到 HTTPS，而要直接返回调用错误以禁止不安全的调用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2-域名&#34;&gt;2. 域名&lt;/h3&gt;
&lt;p&gt;应当尽可能的将 API 与其主域名区分开，可以使用专用的域名，访问我们的 API，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://api.larabbs.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者可以放在主域名下，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://www.larabbs.com/api
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-版本控制&#34;&gt;3. 版本控制&lt;/h3&gt;
&lt;p&gt;随着业务的发展，需求的不断变化，API 的迭代是必然的，很可能当前版本正在使用，而我们就得开发甚至上线一个不兼容的新版本，为了让旧用户可以正常使用，为了保证开发的顺利进行，我们需要控制好 API 的版本。&lt;/p&gt;
&lt;p&gt;通常情况下，有两种做法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将版本号直接加入 URL 中&lt;pre&gt;&lt;code&gt;https://api.larabbs.com/v1
https://api.larabbs.com/v2
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;使用 HTTP 请求头的 Accept 字段进行区分&lt;pre&gt;&lt;code&gt;https://api.larabbs.com/
    Accept: application/prs.larabbs.v1+json
    Accept: application/prs.larabbs.v2+json
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Github Api 虽然默认使用了第一种方法，但是其实是推荐并实现了第二种方法的，我们同样也尽量使用第二种方式。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1594115088167.png&#34; alt=&#34;current verson&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;4-用-url-定位资源&#34;&gt;4.  用 URL 定位资源&lt;/h3&gt;
&lt;p&gt;在 RESTful 的架构中，所有的一切都表示资源，每一个 URL 都代表着一种资源，资源应当是一个名词，而且大部分情况下是名词的复数，尽量不要在 URL 中出现动词。&lt;br&gt;
先来看看 github 的 &lt;a href=&#34;https://developer.github.com/v3/issues/comments/&#34;&gt;例子&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET /issues                                      列出所有的 issue
GET /orgs/:org/issues                            列出某个项目的 issue
GET /repos/:owner/:repo/issues/:number           获取某个项目的某个 issue
POST /repos/:owner/:repo/issues                  为某个项目创建 issue
PATCH /repos/:owner/:repo/issues/:number         修改某个 issue
PUT /repos/:owner/:repo/issues/:number/lock      锁住某个 issue
DELETE /repos/:owner/:repo/issues/:number/lock   解锁某个 issue
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;例子中冒号开始的代表变量，例如 /repos/summerblue/larabbs/issues&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 github 的实现中，我们可以总结出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;资源的设计可以嵌套，表明资源与资源之间的关系。&lt;/li&gt;
&lt;li&gt;大部分情况下我们访问的是某个资源集合，想得到单个资源可以通过资源的 id 或 number 等唯一标识获取。&lt;/li&gt;
&lt;li&gt;某些情况下，资源会是单数形式，例如某个项目某个 issue 的锁，每个 issue 只会有一把锁，所以它是单数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;错误的例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST https://api.larabbs.com/createTopic
GET https://api.larabbs.com/topic/show/1
POST https://api.larabbs.com/topics/1/comments/create
POST https://api.larabbs.com/topics/1/comments/100/delete
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;正确的例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST https://api.larabbs.com/topics
GET https://api.larabbs.com/topics/1
POST https://api.larabbs.com/topics/1/comments
DELETE https://api.larabbs.com/topics/1/comments/100
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-用-http-动词描述操作&#34;&gt;5. 用 HTTP 动词描述操作&lt;/h3&gt;
&lt;p&gt;HTTP 设计了很多动词，来表示不同的操作，RESTful 很好的利用的这一点，我们需要正确的使用 HTTP 动词，来表明我们要如何操作资源。&lt;br&gt;
先来解释一个概念，&lt;code&gt;幂等性&lt;/code&gt;，指一次和多次请求某一个资源应该具有同样的副作用，也就是一次访问与多次访问，对这个资源带来的变化是相同的。&lt;/p&gt;
&lt;p&gt;常用的动词及幂等性&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;动词&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;是否幂等&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;GET&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;获取资源，单个或多个&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;POST&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;创建资源&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;PUT&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;更新资源，客户端提供完整的资源数据&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;PATCH&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;更新资源，客户端提供部分的资源数据&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;DELETE&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;删除资源&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么 PUT 是幂等的而 PATCH 是非幂等的，因为 PUT 是根据客户端提供了完整的资源数据，客户端提交什么就替换什么，而 PATCH 有可能是根据客户端提供的参数，动态的计算出某个值，例如每次请求后资源的某个参数减 1，所以多次调用，资源会有不同的变化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外需要注意的是，GET 请求对于资源来说是安全的，不允许通过 GET 请求改变（更新或创建）资源，但是真实使用中，为了方便统计类的数据，会有一些例外情况，例如帖子详情，记录访问次数，每调用一次，访问次数 +1;&lt;/p&gt;
&lt;h3 id=&#34;6-资源过滤&#34;&gt;6. 资源过滤&lt;/h3&gt;
&lt;p&gt;我们需要提供合理的参数供客户端过滤资源，例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;?state=closed: 不同状态的资源
?page=2&amp;amp;per_page=100：访问第几页数据，每页多少条。
?sortby=name&amp;amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;7-正确使用状态码&#34;&gt;7. 正确使用状态码&lt;/h3&gt;
&lt;p&gt;HTTP 提供了丰富的状态码供我们使用，正确的使用状态码可以让响应数据更具可读性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;200 OK - 对成功的 GET、PUT、PATCH 或 DELETE 操作进行响应。也可以被用在不创建新资源的 - POST 操作上&lt;/li&gt;
&lt;li&gt;201 Created - 对创建新资源的 POST 操作进行响应。应该带着指向新资源地址的 Location 头&lt;/li&gt;
&lt;li&gt;202 Accepted - 服务器接受了请求，但是还未处理，响应中应该包含相应的指示信息，告诉客户端该去哪里查询关于本次请求的信息&lt;/li&gt;
&lt;li&gt;204 No Content - 对不会返回响应体的成功请求进行响应（比如 DELETE 请求）&lt;/li&gt;
&lt;li&gt;304 Not Modified - HTTP 缓存 header 生效的时候用&lt;/li&gt;
&lt;li&gt;400 Bad Request - 请求异常，比如请求中的 body 无法解析&lt;/li&gt;
&lt;li&gt;401 Unauthorized - 没有进行认证或者认证非法&lt;/li&gt;
&lt;li&gt;403 Forbidden - 服务器已经理解请求，但是拒绝执行它&lt;/li&gt;
&lt;li&gt;404 Not Found - 请求一个不存在的资源&lt;/li&gt;
&lt;li&gt;405 Method Not Allowed - 所请求的 HTTP 方法不允许当前认证用户访问&lt;/li&gt;
&lt;li&gt;410 Gone - 表示当前请求的资源不再可用。当调用老版本 API 的时候很有用&lt;/li&gt;
&lt;li&gt;415 Unsupported Media Type - 如果请求中的内容类型是错误的&lt;/li&gt;
&lt;li&gt;422 Unprocessable Entity - 用来表示校验错误&lt;/li&gt;
&lt;li&gt;429 Too Many Requests - 由于请求频次达到上限而被拒绝访问&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;8-数据响应格式&#34;&gt;8. 数据响应格式&lt;/h4&gt;
&lt;p&gt;考虑到响应数据的可读性及通用性，默认使用 JSON 作为数据响应格式。如果客户端有需求使用其他的响应格式，例如 XML，需要在 Accept 头中指定需要的格式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://api.larabbs.com/
    Accept: application/prs.larabbs.v1+json
    Accept: application/prs.larabbs.v1+xml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于错误数据，默认使用如下结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#39;message&#39; =&amp;gt; &#39;:message&#39;,          // 错误的具体描述
&#39;errors&#39; =&amp;gt; &#39;:errors&#39;,            // 参数的具体错误描述，422 等状态提供
&#39;code&#39; =&amp;gt; &#39;:code&#39;,                // 自定义的异常码
&#39;status_code&#39; =&amp;gt; &#39;:status_code&#39;,  // http状态码
&#39;debug&#39; =&amp;gt; &#39;:debug&#39;,              // debug 信息，非生产环境提供
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;message&amp;quot;: &amp;quot;422 Unprocessable Entity&amp;quot;,
    &amp;quot;errors&amp;quot;: {
        &amp;quot;name&amp;quot;: [
            &amp;quot;姓名 必须为字符串。&amp;quot;
        ]
    },
    &amp;quot;status_code&amp;quot;: 422
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;message&amp;quot;: &amp;quot;您无权访问该订单&amp;quot;,
    &amp;quot;status_code&amp;quot;: 403
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;9-调用频率限制&#34;&gt;9. 调用频率限制&lt;/h3&gt;
&lt;p&gt;为了防止服务器被攻击，减少服务器压力，需要对接口进行合适的限流控制，需要在响应头信息中加入合适的信息，告知客户端当前的限流情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;X-RateLimit-Limit :100 最大访问次数&lt;/li&gt;
&lt;li&gt;X-RateLimit-Remaining :93 剩余的访问次数&lt;/li&gt;
&lt;li&gt;X-RateLimit-Reset :1513784506 到该时间点，访问次数会重置为 &lt;code&gt;X-RateLimit-Limit&lt;/code&gt;&lt;br&gt;
超过限流次数后，需要返回 &lt;code&gt;429 Too Many Requests&lt;/code&gt; 错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;10-编写文档&#34;&gt;10. 编写文档&lt;/h3&gt;
&lt;p&gt;为了方便用户使用，我们需要提供清晰的文档，尽可能包括以下几点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包括每个接口的请求参数，每个参数的类型限制，是否必填，可选的值等。&lt;/li&gt;
&lt;li&gt;响应结果的例子说明，包括响应结果中，每个参数的释义。&lt;/li&gt;
&lt;li&gt;对于某一类接口，需要有尽量详细的文字说明，比如针对一些特定场景，接口应该如何调用。&lt;/li&gt;
&lt;/ul&gt;
">Github 的 Restful HTTP API 设计分解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/restful-api/"" data-c="
          &lt;p&gt;RESTful API = Http Method（动词，描述资源操作类型） + URI(名词+属性，描述资源的层级和位置)&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;写在前面&#34;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;因为内容本身是一些规范约束性的理论，或许不会短时间内就能对日常开发工作有明显的促进作用，生搬硬套一些规则，为了使用而使用，可能反而会给自己的开发过程造成约束，影响效率。&lt;/p&gt;
&lt;p&gt;所以，不妨各抒己见，来讨论一番。&lt;/p&gt;
&lt;h3 id=&#34;特别说明&#34;&gt;特别说明&lt;/h3&gt;
&lt;p&gt;文章主体内容摘选自：&lt;a href=&#34;https://www.cnblogs.com/jaxu/p/7908111.html#a_1&#34;&gt;RESTful 服务最佳实践&lt;/a&gt;，侵删。&lt;/p&gt;
&lt;h2 id=&#34;rest-是什么&#34;&gt;REST 是什么？&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;表现层状态转换（英语：Representational State Transfer，缩写：REST）是 Roy Thomas Fielding 博士于 2000 年在他的博士论文 [1] 中提出来的一种万维网软件架构风格，目的是便于不同软件 / 程序在网络（例如互联网）中互相传递信息。表现层状态转换是根基于超文本传输协议（HTTP）之上而确定的一组约束和属性，是一种设计提供万维网络服务的软件构建风格。 —— 来源于自由的 WIKI 百科『&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2&#34;&gt;表现层状态转换&lt;/a&gt;』&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;tips&#34;&gt;Tips:&lt;/h4&gt;
&lt;p&gt;由此可见，REST 只是一种「软件架构风格」，不是多么玄乎的东西，设计出来的目的是为了方便应用程序之间互相传递信息。通常说的 RESTful API 就是表明应用系统中 API 的架构设计符合 REST 规范，遵守这种规范某种程度上可以说明应用系统的架构设计优秀。&lt;/p&gt;
&lt;p&gt;近些年实际上出现了另外一种 API 设计风格 GraphQL 已经趋于成熟，各种编程语言的支持逐渐出现，也可以感受下『&lt;a href=&#34;https://segmentfault.com/a/1190000018849004&#34;&gt;为什么 GraphQL 是 API 的未来&lt;/a&gt;』（规范的成熟不等同于实际项目中就可以直接落地使用，技术选型前要有自己的判断，预估一下未来能够投入的时间和人力成本，不要受网文推广的影响）&lt;/p&gt;
&lt;h2 id=&#34;使用-http-动词表示一些含义&#34;&gt;使用 HTTP 动词表示一些含义&lt;/h2&gt;
&lt;p&gt;任何 API 的使用者能够发送 GET、POST、PUT 和 DELETE 请求，它们很大程度明确了所给请求的目的。&lt;/p&gt;
&lt;p&gt;同时，GET 请求不能改变任何潜在的资源数据。测量和跟踪仍可能发生，但只会更新数据而不会更新由 URI 标识的资源数据。&lt;/p&gt;
&lt;h3 id=&#34;合理的资源名&#34;&gt;合理的资源名&lt;/h3&gt;
&lt;p&gt;合理的资源名称或者路径（如 /posts/23 而不是 /api?type=posts&amp;amp;id=23）可以更明确一个请求的目的。&lt;/p&gt;
&lt;p&gt;使用 URL 查询串来过滤数据是很好的方式，但不应该用于定位资源名称。&lt;/p&gt;
&lt;p&gt;适当的资源名称为服务端请求提供上下文，增加服务端 API 的可理解性。&lt;/p&gt;
&lt;p&gt;通过 URI 名称分层地查看资源，可以给使用者提供一个友好的、容易理解的资源层次，以在他们的应用程序上应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;资源名称应该是名词，避免为动词。使用 HTTP 方法来指定请求的动作部分，能让事情更加的清晰。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tips&lt;/strong&gt;: 相关名词解释和理解&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;URL&lt;/strong&gt;：&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6&#34;&gt;统一资源定位符&lt;/a&gt;（英语：Uniform Resource Locator，缩写：URL；或称统一资源定位器、定位地址、URL 地址 [1]，俗称网页地址或简称网址）是因特网上标准的资源的地址（Address），如同在网络上的门牌。—— 来自维基百科）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;URI&lt;/strong&gt;：&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E5%BF%97%E7%AC%A6&#34;&gt;统一资源标识符&lt;/a&gt;（英语：Uniform Resource Identifier，缩写：URI）—— 来自维基百科&lt;/p&gt;
&lt;p&gt;应用到 RESTful API 的路由设计中：&lt;/p&gt;
&lt;p&gt;API URL = Http Method（动词，描述对资源操作的类型 CRUD） + URI（Uniform Resource Identifier）（可以类比文件路径，体现资源层级以及描述资源位置）&lt;/p&gt;
&lt;p&gt;也就是在 API 的 URL 应该是用来描述去哪个位置找到资源，然后通过 Http Method 描述对资源进行怎样的操作，这样路由设计就清晰了&lt;/p&gt;
&lt;p&gt;至于 URI 如何定义，你可以类比平时是如何在磁盘中进行分类管理文件的，或许就思路清晰了。&lt;/p&gt;
&lt;h3 id=&#34;相关定义&#34;&gt;相关定义&lt;/h3&gt;
&lt;p&gt;我们一起简单过一下与 REST 有关的定义。&lt;/p&gt;
&lt;h4 id=&#34;幂等性&#34;&gt;幂等性&lt;/h4&gt;
&lt;p&gt;下面是来自维基百科的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在计算机科学中，术语幂等用于更全面地描述一个操作，一次或多次执行该操作产生的结果是一致的。根据应用的上下文，这可能有不同的含义。例如，在方法或者子例程调用具有副作用的情况下，意味着在第一调用之后被修改的状态也保持不变。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从 REST 服务端的角度来看，由于操作（或服务端调用）是幂等的，客户端可以用重复的调用而产生&lt;strong&gt;相同的结果&lt;/strong&gt;。注意，当幂等操作在服务器上产生相同的结果（副作用），响应本身可能是不同的（例如在多个请求之间，资源的状态可能会改变）。&lt;/p&gt;
&lt;p&gt;PUT 和 DELETE 方 法被定义为是幂等的。GET、HEAD、OPTIO 和 TRACE 方法自从被定义为安全的方法后，也被定义为幂等的。&lt;/p&gt;
&lt;h4 id=&#34;安全&#34;&gt;安全&lt;/h4&gt;
&lt;p&gt;来自维基百科：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一些方法（例如 GET、HEAD、OPTIONS 和 TRACE）被定义为安全的方法，这意味着它们仅被用于信息检索，而不能更改服务器的状态。换句话说，它们不会有副作用，除了相对来说无害的影响如日志、缓存、横幅广告或计数服务等。任意的 GET 请求，不考虑应用状态的上下文，都被认为是安全的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总之，&lt;strong&gt;安全&lt;/strong&gt;意味着调用的方法不会引起&lt;strong&gt;副作用&lt;/strong&gt;。因此，客户端可以反复使用安全的请求而不用担心对服务端产生任何副作用。这意味着服务端必须遵守 GET、HEAD、OPTIONS 和 TRACE 操作的安全定义。否则，除了对客户端产生混淆外，它还会导致 Web 缓存，搜索引擎以及其它自动代理的问题 —— 这将在服务器上产生意想不到的后果。&lt;/p&gt;
&lt;p&gt;根据定义，安全操作是幂等的，因为它们在服务器上产生相同的结果。&lt;/p&gt;
&lt;p&gt;安全的方法被实现为&lt;strong&gt;只读&lt;/strong&gt;操作。然而，安全并不意味着服务器必须每次都返回相同的响应。&lt;/p&gt;
&lt;h3 id=&#34;http-动词-方法&#34;&gt;Http 动词 / 方法&lt;/h3&gt;
&lt;p&gt;Http 动词主要遵循 “统一接口” 规则，并提供给我们对应的&lt;strong&gt;基于名词的资源&lt;/strong&gt;的动作。&lt;/p&gt;
&lt;p&gt;最主要或者最常用的 http 动词（或者称之为方法，这样称呼可能更恰当些）有 POST、GET、PUT 和 DELETE。这些分别对应于创建、读取、更新和删除 (CRUD) 操作。&lt;/p&gt;
&lt;p&gt;也有许多其它的动词，但是使用频率比较低。在这些使用较少的方法中，OPTIONS 和 HEAD 往往使用得更多。&lt;/p&gt;
&lt;h4 id=&#34;get&#34;&gt;GET&lt;/h4&gt;
&lt;p&gt;HTTP 的 GET 方法用于**检索（或读取）**资源的数据。&lt;/p&gt;
&lt;p&gt;在正确的请求路径下，GET 方法会返回一个 xml 或者 json 格式的数据，以及一个 200 的 HTTP 响应代码（表示正确返回结果）。在错误情况下，它通常返回 404（不存在）或 400（错误的请求）。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET http://www.example.com/customers/12345
GET http://www.example.com/customers/12345/orders
GET http://www.example.com/buckets/sample
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按照 HTTP 的设计规范，GET（以及附带的 HEAD）请求仅用于读取数据而不改变数据。因此，这种使用方式被认为是安全的。&lt;/p&gt;
&lt;p&gt;也就是说，它们的调用&lt;strong&gt;没有数据修改或污染的风险&lt;/strong&gt; —— 调用 1 次和调用 10 次或者没有被调用的效果一样。&lt;/p&gt;
&lt;p&gt;此外，GET（以及 HEAD）是&lt;strong&gt;幂等&lt;/strong&gt;的，这意味着使用多个相同的请求与使用单个的请求最终都拥有相同的结果。&lt;/p&gt;
&lt;p&gt;不要通过 GET 暴露不安全的操作 —— 它应该永远都不能修改服务器上的任何资源。&lt;/p&gt;
&lt;h4 id=&#34;put&#34;&gt;PUT&lt;/h4&gt;
&lt;p&gt;PUT 通常被用于&lt;strong&gt;更新&lt;/strong&gt;资源。&lt;/p&gt;
&lt;p&gt;通过 PUT 请求一个已知的资源 URI 时，需要在&lt;strong&gt;请求的 body&lt;/strong&gt; 中包含对原始资源的更新数据。&lt;/p&gt;
&lt;p&gt;不过，在资源 ID 是由客户端而非服务端提供的情况下，PUT 同样可以被用来创建资源。换句话说，如果 PUT 请求的 URI 中包含的资源 ID 值在服务器上不存在，则用于创建资源。同时请求的 body 中必须包含要创建的资源的数据。有人觉得这会产生歧义，所以除非真的需要，使用这种方法来创建资源应该被慎用。&lt;/p&gt;
&lt;p&gt;或者我们也可以在 body 中提供由客户端定义的资源 ID 然后使用 POST 来创建新的资源 —— 假设请求的 URI 中不包含要创建的资源 ID（参见下面 POST 的部分)。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PUT http://www.example.com/customers/12345　
PUT http://www.example.com/customers/12345/orders/98765
PUT http://www.example.com/buckets/secret_stuff
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当使用 PUT 操作更新成功时，会返回 200（或者返回 204，表示返回的 body 中不包含任何内容）。如果使用 PUT 请求创建资源，成功返回的 HTTP 状态码是 201。&lt;/p&gt;
&lt;p&gt;响应的 body 是可选的 —— 如果提供的话将会消耗更多的带宽。在创建资源时没有必要通过头部的位置返回链接，因为客户端已经设置了资源 ID。&lt;/p&gt;
&lt;p&gt;PUT &lt;strong&gt;不是一个安全的操作&lt;/strong&gt;，因为它会修改（或创建）服务器上的状态，但它是&lt;strong&gt;幂等&lt;/strong&gt;的。换句话说，如果你使用 PUT 创建或者更新资源，然后重复调用，资源仍然存在并且状态不会发生变化。&lt;/p&gt;
&lt;p&gt;但是，如果在资源&lt;strong&gt;增量计数器&lt;/strong&gt;中调用 PUT，那么这个调用方法就不再是幂等的。这种情况有时候会发生，且可能足以证明它是非幂等性的。不过，建议保持 PUT 请求的幂等性。并&lt;strong&gt;强烈建议非幂等性的请求&lt;/strong&gt;使用 POST。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tips&lt;/strong&gt;: 为什么 PUT 是幂等？&lt;/p&gt;
&lt;p&gt;比如，你第一次请求更新订单状态为配送中，第二次请求如果不加校验，让请求处理成功，订单也是被更新成了配送中的状态。两次请求得到的结果相同，都是将订单更新成了配送中的状态。（要理解结果相同和响应不一定相同这一点，多次请求对资源造成的结果相同就被定义成幂等）&lt;/p&gt;
&lt;h4 id=&#34;post&#34;&gt;POST&lt;/h4&gt;
&lt;p&gt;POST 请求经常被用于&lt;strong&gt;创建&lt;/strong&gt;新的资源，特别是被用来&lt;strong&gt;创建从属资源&lt;/strong&gt;。从属资源即归属于其它资源（如父资源）的资源。换句话说，当创建一个新资源时，POST 请求发送给父资源，服务端负责将新资源与父资源进行关联，并分配一个 ID（新资源的 URI），等等。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST &amp;lt;http://www.example.com/customers
POST &amp;lt;http://www.example.com/customers/12345/orders
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当创建成功时，返回 HTTP 状态码 201，并附带一个位置头（Location:xxx）信息，其中带有指向最先创建的资源的链接。&lt;/p&gt;
&lt;p&gt;POST 请求&lt;strong&gt;既不是安全的又不是幂等&lt;/strong&gt;的，因此它被定义为非幂等性资源请求。&lt;/p&gt;
&lt;p&gt;使用两个相同的 POST 请求很可能会导致创建两个包含相同信息的资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tips&lt;/strong&gt;: 非幂等操作在实际项目中需要考虑的点&lt;/p&gt;
&lt;p&gt;在实际项目开发中遇到这种请求需要考虑并发情况，解决思路参考：前端增加校验，比如创建按钮禁用，不允许短时间内连续操作，必须等待后端返回成功后才能继续下一次创建操作；后端增加「业务锁」处理前端发送过来的请求前加锁，等业务处理完以后释放锁。&lt;/p&gt;
&lt;h4 id=&#34;put-和-post-的创建比较&#34;&gt;PUT 和 POST 的创建比较&lt;/h4&gt;
&lt;p&gt;总之，我们建议使用 POST 来创建资源。当由客户端来决定新资源具有哪些 URI（通过资源名称或 ID）时，使用 PUT：即如果客户端知道 URI（或资源 ID）是什么，则对该 URI 使用 PUT 请求。否则，当由服务器或服务端来决定创建的资源的 URI 时则使用 POST 请求。换句话说，当客户端在创建之前不知道（或无法知道）结果的 URI 时，使用 POST 请求来创建新的资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tips:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以简单点约定，获取 / 查询资源使用 GET；更新整个资源（相当于替换）使用 PUT；更新资源部分的内容使用 PATCH；删除资源使用 DELETE；创建资源使用 POST，以及非幂等性的请求使用 POST（比如更新资源内部的计数器等）。&lt;/p&gt;
&lt;h4 id=&#34;delete&#34;&gt;DELETE&lt;/h4&gt;
&lt;p&gt;DELETE 很容易理解。它被用来根据 URI 标识&lt;strong&gt;删除&lt;/strong&gt;资源。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DELETE &amp;lt;http://www.example.com/customers/12345
DELETE &amp;lt;http://www.example.com/customers/12345/orders
DELETE &amp;lt;http://www.example.com/buckets/sample
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当删除成功时，返回 HTTP 状态码 200（表示正确），同时会附带一个响应体 body，body 中可能包含了删除项的数据（这会占用一些网络带宽），或者封装的响应（参见下面的返回值）。也可以返回 HTTP 状态码 204（表示无内容）表示没有响应体。总之，可以返回状态码 204 表示没有响应体，或者返回状态码 200 同时附带 JSON 风格的响应体。&lt;/p&gt;
&lt;p&gt;根据 HTTP 规范，DELETE 操作是&lt;strong&gt;幂等&lt;/strong&gt;的。如果你对一个资源进行 DELETE 操作，资源就被移除了。在资源上反复调用 DELETE 最终导致的结果都相同：即资源被移除了。&lt;/p&gt;
&lt;p&gt;但如果将 DELETE 的操作用于&lt;strong&gt;计数器&lt;/strong&gt;（资源内部），则 DETELE 将不再是幂等的。如前面所述，只要数据没有被更新，统计和测量的用法依然可被认为是幂等的。&lt;strong&gt;建议非幂等性的资源请求使用 POST 操作&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;然而，这里有一个关于 DELETE 幂等性的警告。在一个资源上第二次调用 DELETE 往往会返回 404（未找到），因为该资源已经被移除了，所以找不到了。这使得 DELETE 操作不再是幂等的。如果资源是从数据库中删除而不是被简单地标记为删除，这种情况需要适当妥协。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tips&lt;/strong&gt;: 如何理解 DELETE 操作被定义为幂等？&lt;/p&gt;
&lt;p&gt;上面讨论的也就是「物理删除」和「软删除」的不同场景要不要都使用 DELETE，因为资源的「物理删除」不是幂等操作，第二次请求操作时资源在第一次就没了，对资源造成的结果不同。&lt;/p&gt;
&lt;p&gt;物理删除，都没有资源了还怎么操作资源，第一次是有操作结果，第二次没有操作结果（都没资源可以操作，哪来的结果？），两次操作结果不同，所以不是幂等&lt;/p&gt;
&lt;p&gt;软删除，第一次删除是更新资源的删除状态为删除，第二次删除即使不加校验，最终也是将资源更新为删除状态。&lt;/p&gt;
&lt;h2 id=&#34;资源命名uri&#34;&gt;资源命名（URI）&lt;/h2&gt;
&lt;p&gt;除了适当地使用 HTTP 动词，在创建一个可以理解的、易于使用的 Web 服务 API 时，资源命名可以说是最具有争议和最重要的概念。一个好的资源命名，它所对应的 API 看起来更直观并且易于使用。相反，如果命名不好，同样的 API 会让人感觉很笨拙并且难以理解和使用。当你需要为你的新 API 创建资源 URL 时，这里有一些小技巧值得借鉴。&lt;/p&gt;
&lt;p&gt;从本质上讲，一个 RESTFul API 最终都可以被简单地看作是一堆 URI 的集合，HTTP 调用这些 URI 以及一些用 JSON 和（或）XML 表示的资源，它们中有许多包含了相互关联的链接。RESTful 的可寻址能力主要依靠 URI。每个资源都有自己的地址或 URI—— 服务器能提供的每一个有用的信息都可以作为资源来公开。统一接口的原则部分地通过 URI 和 HTTP 动词的组合来解决，并符合使用标准和约定。&lt;/p&gt;
&lt;p&gt;在决定你系统中要使用的资源时，&lt;strong&gt;使用名词来命名这些资源，而不是用动词或动作来命名&lt;/strong&gt;。换句话说，一个 RESTful URI 应该&lt;strong&gt;关联到一个具体的资源，而不是关联到一个动作&lt;/strong&gt;。另外，名词还具有一些动词没有的属性，这也是另一个显著的因素。&lt;/p&gt;
&lt;p&gt;一些资源的例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统的用户&lt;/li&gt;
&lt;li&gt;学生登记的课程&lt;/li&gt;
&lt;li&gt;一个用户帖子的时间轴&lt;/li&gt;
&lt;li&gt;关注其他用户的用户&lt;/li&gt;
&lt;li&gt;一篇关于骑马的文章&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;服务套件中的每个资源至少有一个 URI 来标识。&lt;strong&gt;如果这个 URI 能表示一定的含义并且能够充分描述它所代表的资源，那么它就是一个最好的命名&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;URI 应该具备&lt;strong&gt;可预测性&lt;/strong&gt;和&lt;strong&gt;分层结构&lt;/strong&gt;，这将有助于提高它们的可理解性和可用性的：可预测指的是资源应该和名称保持一致；而分层指的是数据具有关系上的结构。这并非 REST 规则或规范，但是它强化了对 API 的定义。&lt;/p&gt;
&lt;p&gt;RESTful API 是提供给消费端（客户端）的，&lt;strong&gt;URI 的名称和结构应该将它所表达的含义传达给消费者&lt;/strong&gt;。通常我们很难知道数据的边界是什么，但是从你的数据上你应该很有可能去尝试找到要返回给客户端的数据是什么。&lt;strong&gt;API 是为客户端而设计的，而不是为你的数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;假设我们现在要描述一个包括客户、订单，列表项，产品等功能的订单系统。考虑一下我们该如何来描述在这个服务中所涉及到的资源的 URIs：&lt;/p&gt;
&lt;h3 id=&#34;准确的案例&#34;&gt;准确的案例✅&lt;/h3&gt;
&lt;p&gt;为了在系统中插入（创建）一个新的用户，我们可以使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST &amp;lt;http://www.example.com/customers
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;读取编号为 33245 的用户信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET &amp;lt;http://www.example.com/customers/33245
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 PUT 和 DELETE 来请求相同的 URI，可以更新和删除数据。&lt;/p&gt;
&lt;p&gt;下面是对产品相关的 URI 的一些建议：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST &amp;lt;http://www.example.com/products
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用于创建新的产品。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET|PUT|DELETE &amp;lt;http://www.example.com/products/66432
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分别用于读取、更新、删除编号为 66432 的产品。&lt;/p&gt;
&lt;p&gt;那么，如何为用户创建一个新的订单呢？&lt;/p&gt;
&lt;p&gt;一种方案是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST &amp;lt;http://www.example.com/orders
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方式可以用来创建订单，但缺少相应的用户数据。&lt;/p&gt;
&lt;p&gt;因为我们想为用户创建一个订单（注意之间的关系），这个 URI 可能不够直观，下面这个 URI 则更清晰一些：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST &amp;lt;http://www.example.com/customers/33245/orders
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在我们知道它是为编号 33245 的用户创建一个订单。（&lt;strong&gt;Tips&lt;/strong&gt;: 体现上面提到的 URI 应该具备&lt;strong&gt;分层结构&lt;/strong&gt;的特性）&lt;/p&gt;
&lt;p&gt;那下面这个请求返回的是什么呢？（&lt;strong&gt;Tips&lt;/strong&gt;: 下面举例体现了 URI 应该具体&lt;strong&gt;可预测&lt;/strong&gt;的特性，从 URI 中就可以推断出即将返回的资源数据）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET &amp;lt;http://www.example.com/customers/33245/orders
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可能是一个编号为 33245 的用户所创建或拥有的订单列表。注意：我们可以屏蔽对该 URI 进行 DELETE 或 PUT 请求，因为它的操作对象是一个集合。&lt;/p&gt;
&lt;p&gt;继续深入，那下面这个 URI 的请求又代表什么呢？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST &amp;lt;http://www.example.com/customers/33245/orders/8769/lineitems
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可能是（为编号 33245 的用户）增加一个编号为 8769 的订单条目。没错！如果使用 GET 方式请求这个 URI，则会返回这个订单的所有条目。但是，如果这些条目与用户信息无关，我们将会提供&lt;code&gt;POST www.example.com/orders/8769/lineitems&lt;/code&gt; 这个 URI。&lt;/p&gt;
&lt;p&gt;从返回的这些条目来看，指定的资源可能会有多个 URIs，所以我们可能也需要要提供这样一个 URI &lt;code&gt;GET &amp;lt;http://www.example.com/orders/8769&lt;/code&gt;，用来在不知道用户 ID 的情况下根据订单 ID 来查询订单。&amp;gt;&lt;/p&gt;
&lt;p&gt;更进一步：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET &amp;lt;http://www.example.com/customers/33245/orders/8769/lineitems/1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可能只返回同个订单中的第一个条目。&lt;/p&gt;
&lt;p&gt;现在你应该理解什么是分层结构了。它们并不是严格的规则，只是为了确保在你的服务中这些强制的结构能够更容易被用户所理解。与所有软件开发中的技能一样，&lt;strong&gt;命名是成功的关键&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;错误的案例&#34;&gt;错误的案例❌&lt;/h3&gt;
&lt;p&gt;前面我们已经讨论过一些恰当的资源命名的例子，然而有时一些反面的例子也很有教育意义。下面是一些不太具有 RESTful 风格的资源 URIs，看起来比较混乱。这些都是错误的例子！&lt;/p&gt;
&lt;p&gt;首先，一些 serivices 往往使用单一的 URI 来指定服务接口，然后通过查询参数来指定 HTTP 请求的动作。例如，要更新编号 12345 的用户信息，带有 JSON body 的请求可能是这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET &amp;lt;http://api.example.com/services?op=update_customer&amp;amp;id=12345&amp;amp;format=json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;尽管上面 URL 中的”services” 的这个节点是一个名词，但这个 URL 不是&lt;strong&gt;自解释&lt;/strong&gt;的，因为对于所有的请求而言，该 URI 的层级结构都是一样的。此外，它使用 GET 作为 HTTP 动词来执行一个更新操作，这简直就是反人类（甚至是危险的）。&lt;/p&gt;
&lt;p&gt;下面是另外一个更新用户的操作的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET &amp;lt;http://api.example.com/update_customer/12345
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以及它的一个变种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET &amp;lt;http://api.example.com/customers/12345/update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你会经常看到在其他开发者的服务套件中有很多这样的用法。可以看出，这些开发者试图去创建 RESTful 的资源名称，而且已经有了一些进步。但是你仍然能够识别出 URL 中的动词短语。注意，在这个 URL 中我们不需要”update” 这个词，因为我们可以依靠 HTTP 动词来完成操作。下面这个 URL 正好说明了这一点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PUT &amp;lt;http://api.example.com/customers/12345/update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个请求同时存在 PUT 和”update”，这会对消费者产生迷惑！这里的”update” 指的是一个资源吗？因此，这里我们费些口舌也是希望你能够明白……&lt;/p&gt;
&lt;h3 id=&#34;是否需要使用复数形式&#34;&gt;是否需要使用复数形式？&lt;/h3&gt;
&lt;p&gt;让我们来讨论一下复数和 “单数” 的争议… 还没听说过？但这种争议确实存在，事实上它可以归结为这个问题……&lt;/p&gt;
&lt;p&gt;在你的&lt;strong&gt;层级结构&lt;/strong&gt;中 URI 节点是否需要被命名为单数或复数形式呢？举个例子，你用来检索用户资源的 URI 的命名是否需要像下面这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET &amp;lt;http://www.example.com/customer/33245
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET &amp;lt;http://www.example.com/customers/33245
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;两种方式都没问题，但通常我们都会选择使用复数命名，以使得你的 API URI 在所有的 HTTP 方法中保持一致。原因是基于这样一种考虑：customers 是服务套件中的一个集合，而 ID33245 的这个用户则是这个集合中的其中一个。&lt;/p&gt;
&lt;p&gt;按照这个规则，一个使用复数形式的多节点的 URI 会是这样（注意粗体部分）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET &amp;lt;http://www.example.com/**customers**/33245/**orders**/8769/**lineitems**/1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;“customers”、“orders” 以及 “lineitems” 这些 URI 节点都使用的是复数形式。&lt;/p&gt;
&lt;p&gt;这意味着你的每个根资源只需要两个基本的 URL 就可以了，一个用于创建集合内的资源，另一个用来根据标识符获取、更新和删除资源。&lt;/p&gt;
&lt;p&gt;例如，以 customers 为例，创建资源可以使用下面的 URL 进行操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST &amp;lt;http://www.example.com/customers
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而读取、更新和删除资源，使用下面的 URL 操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET|PUT|DELETE &amp;lt;http://www.example.com/customers/{id}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;正如前面提到的，给定的资源可能有多个 URI，但作为一个最小的完整的增删改查功能，利用两个简单的 URI 来处理就够了。&lt;/p&gt;
&lt;p&gt;或许你会问：是否在有些情况下复数没有意义？嗯，事实上是这样的。当没有集合概念的时候（此时复数没有意义）。换句话说，当资源只有一个的情况下，使用单数资源名称也是可以的 —— 即一个单一的资源。&lt;/p&gt;
&lt;p&gt;例如，如果有一个单一的总体配置资源，你可以使用一个单数名称来表示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET|PUT|DELETE &amp;lt;http://www.example.com/configuration
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意这里缺少 configuration 的 ID 以及 HTTP 动词 POST 的用法。假设每个用户有一个配置的话，那么这个 URL 会是这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET|PUT|DELETE &amp;lt;http://www.example.com/customers/12345/configuration
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样注意这里没有指定 configuration 的 ID，以及没有给定 POST 动词的用法。在这两个例子中，可能也会有人认为使用 POST 是有效的。好吧…&lt;/p&gt;
&lt;h2 id=&#34;回顾&#34;&gt;回顾&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Http Method 的使用场景&lt;br&gt;
增：post、put（非幂等）&lt;br&gt;
删：delete（幂等，类似修改计数器资源时非幂等）&lt;br&gt;
改：put、patch（幂等，类似修改计数器资源时非幂等）&lt;br&gt;
查：get、head（幂等）&lt;br&gt;
其他：connect、options、trace（幂等）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 PUT 创建 / 更新资源&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;创建资源：当由客户端来决定新资源具有哪些 URI（通过资源名称或 ID）时，使用 PUT http://www.example.com/article, 请求 body 中 id 为 123，用来修改资源名称的 id 为 123&lt;/p&gt;
&lt;p&gt;更新资源：PUT http://www.example.com/article/123，用来更新文章 123 的内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非幂等的请求建议统一使用 POST&lt;/li&gt;
&lt;li&gt;使用 Http Method 来描述 API 请求对资源的操作类型（CRUD）&lt;/li&gt;
&lt;li&gt;使用 URI 来描述 API 请求处理资源的&lt;strong&gt;位置&lt;/strong&gt;和&lt;strong&gt;层级&lt;/strong&gt;，UIR 可以是名词+描述名词的属性 , 需要具备可预测性和分层结构，能够自解释。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;在-lumen-api-starter-中的应用&#34;&gt;在 lumen-api-starter 中的应用&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// routes/web.php
Route::get(&#39;/&#39;, function () {
    return app()-&amp;gt;version();
});

Route::get(&#39;author&#39;, function () {
    $response = Http::withOptions([&#39;timeout&#39; =&amp;gt; 3])-&amp;gt;get(&#39;&amp;lt;https://api.github.com/users/Jiannei&amp;gt;&#39;);
    $response-&amp;gt;throw();

    return $response-&amp;gt;json();
});

Route::get(&#39;configurations&#39;, &#39;ExampleController@configurations&#39;);
Route::get(&#39;logs&#39;, &#39;ExampleController@logs&#39;);

Route::post(&#39;users&#39;, &#39;UsersController@store&#39;);
Route::get(&#39;users/{id}&#39;, &#39;UsersController@show&#39;);
Route::get(&#39;users&#39;, &#39;UsersController@index&#39;);

Route::post(&#39;authorization&#39;, &#39;AuthorizationController@store&#39;);
Route::delete(&#39;authorization&#39;, &#39;AuthorizationController@destroy&#39;);
Route::put(&#39;authorization&#39;, &#39;AuthorizationController@update&#39;);
Route::get(&#39;authorization&#39;, &#39;AuthorizationController@show&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;扩展阅读&#34;&gt;扩展阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/jaxu/p/7908111.html#a_1&#34;&gt;RESTful 服务最佳实践&lt;/a&gt;（网友翻译的优质资源）&lt;br&gt;
&lt;a href=&#34;https://www.ruanyifeng.com/blog/2011/09/restful.html&#34;&gt;理解 RESTful 架构&lt;/a&gt;（阮一峰出品）&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/xml/x-urlni.html&#34;&gt;分清 URI、URL 和 URN&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.cnblogs.com/jaxu/p/7908111.html#a_1&#34;&gt;RESTful 服务最佳实践&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.jianshu.com/p/49ebc4a78474&#34;&gt;HTTP head 请求&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://learnku.com/articles/45526&#34;&gt;HTTP 请求方法&lt;/a&gt;&lt;/p&gt;
">RESTful API 路由设计的最佳实践</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/laravel-admin-pjax/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://laravel-admin.org/&#34;&gt;Laravel Admin&lt;/a&gt; 使用的是 Pjax ，所以自定义 JS 时候需要按照 Pjax 的事件周期来。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Pjax 事件请见 &lt;a href=&#34;https://github.com/defunkt/jquery-pjax#usage&#34;&gt;jquery-pjax&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;第一步&#34;&gt;第一步&lt;/h3&gt;
&lt;p&gt;加载 JS 文件&lt;/p&gt;
&lt;p&gt;app/Admin/bootstrap.php&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-PHP&#34;&gt;Admin::js(&#39;/js/admin-extended.js&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;第二步&#34;&gt;第二步&lt;/h3&gt;
&lt;p&gt;public/js/admin-extended.js&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-PHP&#34;&gt;(function($){
    var AdminExtended = {
        init: function(){
            var self = this;

            // Pjax 所有事件请见：https://github.com/defunkt/jquery-pjax#usage

            $(document).on(&#39;pjax:start&#39;, function() {

            });

            //  after replacing content
            $(document).on(&#39;pjax:end&#39;, function() {

                // Pjax 模式里页面加载成功后的初始化
                self.siteBootUp();
            });

            // always fires after ajax, regardless of result
            $(document).on(&#39;pjax:complete&#39;, function() {

            });


            // 正常页面加载成功后的初始化
            self.siteBootUp();
        },

        siteBootUp: function(){
            var self = this;

            self.replaceEnglish();
        },

        replaceEnglish: function(){
            // 创建页面
            $(&#39;.file-drop-zone-title&#39;).text(&amp;quot;拖动文件到此上传...&amp;quot;);

            // 左边搜索框
            $(&#39;.sidebar-form .input-group input.form-control.autocomplete&#39;).attr(&amp;quot;placeholder&amp;quot;, &#39;搜索...&#39;);
        },

    };
    window.AdminExtended = AdminExtended;
})(jQuery);

$(document).ready(function()
{
    AdminExtended.init();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本文转自： &lt;a href=&#34;https://learnku.com/articles/42041&#34;&gt;learnku.com&lt;/a&gt;&lt;/p&gt;
">Laravel Admin 自定义 JavaScript 的正确方式？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/vue-introduction/"" data-c="
          &lt;h3 id=&#34;知识背景&#34;&gt;知识背景&lt;/h3&gt;
&lt;!-- more --&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是node.js&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;nodo.js式基于chrome v8的js运行环境&lt;br&gt;
使js可以当作一门后端语言&lt;br&gt;
特征：基于事件驱动，非阻塞式IO模型&lt;br&gt;
知乎上解释的很好：https://www.zhihu.com/question/33578075&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是npm&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;npm 全称【node package management】是node.js内置的软件包管理器&lt;br&gt;
说明：https://www.jianshu.com/p/c36666b306aa&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是webpack&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;webpack是一个开源前端打包工具，Webpack 提供了前端开发缺乏的模块化开发方式，将各种静态资源视为模块，并从它生成优化过的代码。要使用Webpack 前须先安装Node.js。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;与Vue之间的关系&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们通过vue.js开发项目通常使用npm做包管理器，npm运行依赖node.js；&lt;br&gt;
构建一个vue项目的时候，推荐使用npm，这时候我们需要安装node.js。&lt;br&gt;
一些说明：&lt;br&gt;
https://www.cnblogs.com/jianxian/p/10734204.html&lt;br&gt;
https://www.jianshu.com/p/9967c253da5b&lt;br&gt;
https://www.cnblogs.com/Py-king/p/11669976.html&lt;/p&gt;
&lt;h3 id=&#34;部署环境&#34;&gt;部署环境&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装 node.js&lt;br&gt;
官网安装：https://nodejs.org/en/download/&lt;br&gt;
windoes zip版安装过程：https://www.cnblogs.com/lxg0/p/9472851.html&lt;br&gt;
本次安装以mac 10.15.4为例，win下去掉命令前的“sudo”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看版本&lt;br&gt;
打开终端分别输入&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;//查看node版本
node -v
//查看npm版本
npm -v
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;安装淘宝镜像（可选）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为大天朝的网络环境，国内可能连接不到，建议安装一下淘宝镜像。&lt;br&gt;
--verbose 打印详细信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo npm install -g cnpm --registry=https://registry.npm.taobao.org --verbose
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;安装webpack&lt;br&gt;
“-g”全局安装&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;//安装（官方镜像）
sudo npm install webpack webpack-cli -g
//安装（淘宝镜像）
sudo cnpm install webpack webpack-cli -g
//查看版本
webpack -v
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;安装vue-cli&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;//安装（官方镜像）
sudo npm install -g vue-cli
//安装（淘宝镜像）
sudo cnpm install -g vue-cli
//查看版本
//注意这里是大写的“V”
vue -V
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;创建项目&#34;&gt;创建项目&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;项目位置&lt;br&gt;
打开cmd cd到硬盘的某个路径，这个路径就是接下来项目的存放路径。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vue init webpack demo（项目名，小写）
Project name（项目名：默认“demo”）
Project description （项目介绍：默认 A Vue.js project）
Author （作者名）
Vue build （Use arrow keys）
Runtime + Compiler：recommended for most users（运行加编译）
Runtime—only：about 6KB lighter min+gzip，but templaters（or any Vue-spcific HTML）are ONLY allowed in .Vue files - render functions are required elsewhere（仅运行）
Install vue-router ? （Y/n）（安装Vue路由？）
Use ESLint to lint your code ? （Y/n）（使用ESlint对代码进行校验？）
Set up unit tests （Y/n）（使用单元测试？）
Setup e2e tests with Nightwatch？ （Y/n）（使用e2e测试？）
Should we run npm install fr you after the project has been created?（recommended）（Use arrow keys）
Yes，use Npm
Yes，use Yarn
No，I whill handle that myself
如果npm可以正常使用，选第一项
如果使用淘宝镜像选最后一个
根据提示
cd demo
cnpm install （or if using yarn ：yarn）
npm run dev
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;项目文件解释&#34;&gt;项目文件解释&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;build（webpack 编译任务配置文件: 开发环境与生产环境）&lt;/li&gt;
&lt;li&gt;config（项目的配置文件）&lt;/li&gt;
&lt;li&gt;config&amp;gt;index.js（项目的基础的配置信息）&lt;/li&gt;
&lt;li&gt;config&amp;gt;dev.env.js（开发环境的配置信息）&lt;/li&gt;
&lt;li&gt;config&amp;gt;pro.env.js（线上环境的配置信息）&lt;/li&gt;
&lt;li&gt;node_modules（项目所有依赖的包文件，比如vue-router、vuex等插件都会下载到这个文件夹里面）&lt;/li&gt;
&lt;li&gt;src（工作目录，主要写代码的地方）&lt;/li&gt;
&lt;li&gt;static（静态资源）&lt;/li&gt;
&lt;li&gt;.babelrc（语法解析器）&lt;/li&gt;
&lt;li&gt;.editorconfig（帮助配置编辑器 里 自动化 的语法）&lt;/li&gt;
&lt;li&gt;.gitignore（用来过滤一些版本控制的文件，比如node_modules文件夹）&lt;/li&gt;
&lt;li&gt;.postcssrc.js（是对postcss的一个配置项）&lt;/li&gt;
&lt;li&gt;index.html（入口文件）&lt;/li&gt;
&lt;li&gt;package.json（项目文件，记载着一些命令和依赖还有简要的项目描述信息）&lt;/li&gt;
&lt;li&gt;package-lock.json（package的锁文件，可以帮助确定安装第三包的具体版本，保持编程团队的统一）&lt;/li&gt;
&lt;li&gt;README.md（项目说明介绍）&lt;/li&gt;
&lt;/ul&gt;
">搭建Vue脚手架以及创建项目</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/redis-basic/"" data-c="
          &lt;p&gt;redis 基础知识巩固一下&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;启动&#34;&gt;启动&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;启动：redis-server.exe redis.windows.conf/redis-server&lt;/li&gt;
&lt;li&gt;连接：redis-cli.exe -h 127.0.0.1 -p 6379&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;redis-命令&#34;&gt;redis 命令&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;启动客户端后利用 redis-cli 连接本地服务&lt;/li&gt;
&lt;li&gt;ping 检测 redis 服务是否启动&lt;/li&gt;
&lt;li&gt;执行远程 redis 服务：redis-cli -h host -p port -a password&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;数据类型&#34;&gt;数据类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;string （字符串）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;hash （哈希）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;key：value （键值对集合），适合存储对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;list （列表）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单的字符串列表，可以添加元素到列表的头部和尾部&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;set （集合）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;string 类型的无序集合&lt;/li&gt;
&lt;li&gt;集合是通过哈希表实现的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;zset （有序集合）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;zset 和 set 一样也是 string 类型元素的集合，且不允许重复的成员&lt;/li&gt;
&lt;li&gt;不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序&lt;/li&gt;
&lt;li&gt;zset 的成员是唯一的，但分数 (score) 却可以重复&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;操作指南&#34;&gt;操作指南&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;key 操作&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;-- SET KEY_NAME VALUE（设置给定 key 的值。如果 key 已经存储其他值， SET 就覆写旧值，且无视类型）
&amp;gt; set name Lhao

-- GET KEY_NAME （获取指定 key 的值。如果 key 不存在，返回 nil 。如果key 储存的值不是字符串类型，返回一   个错误）
&amp;gt; get name // 输出：Lhao

-- DUMP KEY_NAME （序列化 name，输出序列化之后的值）
&amp;gt; dump name // 输出：&amp;quot;\x00\x04Lhao\t\x00\xd3JL\xcf\xafsi\x8f&amp;quot;

-- EXISTS KEY_NAME （判断 key 是否存在）
&amp;gt; exists name // 输出：1

-- Expire KEY_NAME TIME_IN_SECONDS (设置有效时间，过期之后则删除，单位：s , 可对已存在的 key 进行操作)
&amp;gt; expire name 10 // 输出：1

-- Expireat KEY_NAME TIME_IN_UNIX_TIMESTAMP (指定过期时间戳)
&amp;gt; set name Lhao // 上面设置了过期时间，已经没了 ，哈哈
&amp;gt; expireat name 1551341040 // 输出：1

-- KEYS PATTERN (用于查找所有符合给定模式 pattern 的 key )
&amp;gt; set name Lhao
&amp;gt; keys * //（返回所有键名）输出：name
&amp;gt; set naes haha
&amp;gt; keys na* // 输出：name、naes

-- SELECT index (切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值)
&amp;gt; select 0 

-- MOVE KEY_NAME DESTINATION_DATABASE (将当前数据库的 key 移动到给定的数据库 db 当)
&amp;gt; move name 1 // (移动 name 到 1 数据库中)
&amp;gt; exists name // 输出：0
&amp;gt; select 1
&amp;gt; exists name // 输出：1

&amp;gt; expire name 10

-- TTL KEY_NAME (以秒为单位返回 key 的剩余过期时间)
&amp;gt; ttl name // 输出：8

-- PERSIST KEY_NAME (移除给定 key 的过期时间，使得 key 永不过期)
&amp;gt; persist name // 输出：1
&amp;gt; ttl name // 输出：-1 （表示不过期）

-- DEL KEY_NAME (删除已存在的键。不存在的 key 会被忽略)
&amp;gt; del name // 输出：1

&amp;gt; set name Lhao
&amp;gt; set age 24

-- RANDOMKEY (从当前数据库中随机返回一个 key)
&amp;gt; randomkey // 输出：age

-- FLUSHDB (清空当前数据库中的所有 key)
&amp;gt; flushdb

&amp;gt; set name Lhao

-- RENAME OLD_KEY_NAME NEW_KEY_NAME (修改 key 的名称)
&amp;gt; rename name newname
&amp;gt; get name // 输出：nli (不存在)
&amp;gt; set namecopy wjh
&amp;gt; rename newname namecopy
&amp;gt; get namecopy // 输出：Lhao

&amp;gt; set name Lhao

-- RENAMENX OLD_KEY_NAME NEW_KEY_NAME (用于在新的 key 不存在时修改 key 的名称)
&amp;gt; renamenx namecopy name // 输出：0 (此时修改 key 名不成功)

-- TYPE KEY_NAME (返回 key 所储存的值的类型)
&amp;gt; type name // 输出：string
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;字符串-操作&#34;&gt;字符串 操作&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/27672245&#34;&gt;知乎：setbit\getbit 用法&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt; flushdb

&amp;gt; set title &amp;quot;my name is Lhao&amp;quot;
&amp;gt; get title // 输出：my name is Lhao

-- GETRANGE KEY_NAME start end （用于获取存储在指定 key 中字符串的子字符串。字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)）
&amp;gt; getrange title 0 4 // 输出：my na

-- GETSET KEY_NAME VALUE (用于设置指定 key 的值，并返回 key 的旧值)
&amp;gt; getset title &amp;quot;new title&amp;quot; // 输出：my name is Lhao
&amp;gt; get title // 输出：new title

-- MGET KEY1 KEY2 .. KEYN (返回所有(一个或多个)给定 key 的值。 如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil )
&amp;gt; mget title name 
// 输出：
 1) (nil)
 2) &amp;quot;new title&amp;quot;

-- SETEX KEY_NAME TIMEOUT VALUE (为指定的 key 设置值及其过期时间。如果 key 已经存在， SETEX 命令将会替换旧的值)
&amp;gt; setex name 60 liuhao

&amp;gt; del name

-- SETNX KEY_NAME VALUE（SET if Not eXists） 命令在指定的 key 不存在时，为 key 设置指定的值
&amp;gt; setnx name Lhao // 输出：1
&amp;gt; setnx title Lhao // 输出：0

-- SETRANGE KEY_NAME OFFSET VALUE （用指定的字符串覆盖给定 key 所储存的字符串值，覆盖的位置从偏移量 offset 开始）
&amp;gt; setrange name 3 Lhao // 输出：7
&amp;gt; get name // 输出：LhaLhao

-- STRLEN KEY_NAME (用于获取指定 key 所储存的字符串值的长度。当 key 储存的不是字符串值时，返回一个错误)
&amp;gt; strlen name // 输出：7

-- 用于同时设置一个或多个 key-value 对 (MSET key1 value1 key2 value2 .. keyN valueN )
&amp;gt; mset name Lhao age 24 // 输出：ok
&amp;gt; mget name age 
// 输出：
 1) &amp;quot;Lhao&amp;quot;
 2) &amp;quot;24&amp;quot;

-- MSETNX key1 value1 key2 value2 .. keyN valueN （用于所有给定 key 都不存在时，同时设置一个或多个 key-value 对）
&amp;gt; msetnx name Lhao age 24 // 输出：0
&amp;gt; msetnx name Lhao25 sex men //输出：0
&amp;gt; get sex // 输出：nli

-- INCR KEY_NAME 
// 将 key 中储存的数字值增一。
// 如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。
// 如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。
// 本操作的值限制在 64 位(bit)有符号数字表示之内。
&amp;gt; incr name // 输出：(error) ERR value is not an integer or out of range
&amp;gt; incr money // 输出：1

-- DECRBY KEY_NAME DECREMENT_AMOUNT (将 key 中储存的数字加上指定的增量值)
&amp;gt; incrby money 80 // 输出：81

-- DECR KEY_NAME （将 key 中储存的数字值减一）
&amp;gt; decr money // 输出：80

-- DECRBY KEY_NAME DECREMENT_AMOUNT （将 key 所储存的值减去指定的减量值）
&amp;gt; decrby money 10 // 输出：70

-- APPEND KEY_NAME NEW_VALUE
// 为指定的 key 追加值。
// 如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。
// 如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样。
&amp;gt; append name &amp;quot; love&amp;quot; //  输出：8
&amp;gt; get name // 输出：Lhaolove
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;哈希-操作&#34;&gt;哈希 操作&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt; flushdb

-- HSET KEY_NAME FIELD VALUE (用于为哈希表中的字段赋值;如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作;如果字段已经存在于哈希表中，旧值将被覆盖)
&amp;gt; hset user name Lhao // 输出：1

-- HGET KEY_NAME FIELD_NAME (用于返回哈希表中指定字段的值)
&amp;gt; hget user name // 输出：Lhao

&amp;gt; hset user name wjh // 输出：0
&amp;gt; hget user name // 输出：wjh

-- HMSET KEY_NAME FIELD1 VALUE1 ...FIELDN VALUEN (用于同时将多个 field-value (字段-值)对设置到哈希表中)
&amp;gt; hmset user name Lhao age 24 // 输出：ok
&amp;gt; hmget user name age
// 输出：
 1) &amp;quot;Lhao&amp;quot;
 2) &amp;quot;24&amp;quot;

-- HDEL KEY_NAME FIELD1.. FIELDN（用于删除哈希表 key 中的一个或多个指定字段，不存在的字段将被忽略）
&amp;gt; hdel user name // 输出：1

-- HEXISTS KEY_NAME FIELD_NAME (用于查看哈希表的指定字段是否存在)
&amp;gt; hexists user name // 输出：0

-- HGETALL KEY_NAME (用于返回哈希表中，所有的字段和值;在返回值里，紧跟每个字段名(field name)之后是字段的值(value)，所以返回值的长度是哈希表大小的两倍)
&amp;gt; hgetall user
// 输出：
 1) &amp;quot;age&amp;quot;
 2) &amp;quot;24&amp;quot;

-- HINCRBY KEY_NAME FIELD_NAME INCR_BY_NUMBER（用于为哈希表中的字段值加上指定增量值）
&amp;gt; hincrby user age 1 // 输出：25

-- HKEYS key (用于获取哈希表中的所有域（field）)
&amp;gt; hkeys user
// 输出：
1) &amp;quot;age&amp;quot;

-- HLEN KEY_NAME （用于获取哈希表中字段的数量）
&amp;gt; hlen user //  输出：1

-- HSETNX KEY_NAME FIELD VALUE（用于为哈希表中不存在的的字段赋值）
&amp;gt; hsetnx user name hao // 输出：1
&amp;gt; hsetnx user age 24 // 输出：0

-- HVALS KEY_NAME FIELD VALUE（返回哈希表所有域(field)的值）
&amp;gt; hvals user 
// 输出：
1) &amp;quot;25&amp;quot;
2) &amp;quot;Lhao&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;列表-操作&#34;&gt;列表 操作&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt; flushdb

-- LPUSH KEY_NAME VALUE1.. VALUEN （将一个或多个值插入到列表头部。 如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。 当 key 存在但不是列表类型时，返回一个错误。）
&amp;gt; lpush users Lhao wjh // 输出：2

-- LRANGE KEY_NAME START END (返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推)
&amp;gt; lrange users 0 0 // 输出：wjh
&amp;gt; lrange users 0 -1 // 输出：wjh、Lhao 

-- BLPOP LIST1 LIST2 .. LISTN TIMEOUT （移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止）
&amp;gt; blpop users 10 
// 输出：
1) &amp;quot;users&amp;quot;
2) &amp;quot;wjh&amp;quot;
&amp;gt; lrange users 0 -1 // 输出：Lhao

-- BRPOPLPUSH LIST1 ANOTHER_LIST TIMEOUT （从列表中弹出第一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。）
&amp;gt; brpoplpush users users_two 10 // 输出：Lhao
&amp;gt; lrange users 0 -1 // 输出：(empty list or set)
&amp;gt; lrange users_two 0 -1 // 输出：Lhao

&amp;gt; lpush users wjh Lhao

-- LINDEX KEY_NAME INDEX_POSITION (用于通过索引获取列表中的元素。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。)
&amp;gt; lindex users 0 // 输出：lhao
&amp;gt; lindex users -1 // 输出：wjh

&amp;gt; del users

-- RPUSH KEY_NAME VALUE1..VALUEN (用于将一个或多个值插入到列表的尾部(最右边);如果列表不存在，一个空列表会被创建并执行 RPUSH 操作。 当列表存在但不是列表类型时，返回一个错误)
&amp;gt; rpush users Lhao wjh
&amp;gt; lrange 0 -1 // 输出：Lhao wjh

-- LINSERT key BEFORE|AFTER pivot value (用于在列表的元素前或者后插入元素。当指定元素不存在于列表中时，不执行任何操作;当列表不存在时，被视为空列表，不执行任何操作;如果 key 不是列表类型，返回一个错误)
&amp;gt; linsert users before wjh love // 输出：3
&amp;gt; lrange 0 -1 // 输出：Lhao love wjh

-- LLEN KEY_NAME (用于返回列表的长度。 如果列表 key 不存在，则 key 被解释为一个空列表，返回 0 。 如果 key 不是列表类型，返回一个错误)
&amp;gt; llen users // 输出：3

-- Lpop KEY_NAME (用于移除并返回列表的第一个元素)
&amp;gt; lpop users // 输出：Lhao
&amp;gt; lrange users 0 -1 // 输出：love wjh

-- LPUSHX KEY_NAME VALUE1.. VALUEN (将一个值插入到已存在的列表头部，列表不存在时操作无效)
&amp;gt; lpushx users Lhao // 输出：3
&amp;gt; lrange users 0 -1 // 输出：Lhao love wjh
&amp;gt; lpushx user you // 输出：0
&amp;gt; lpush users Lhao Lhao // 输出：5
&amp;gt; lrange users 0 -1 // 输出：Lhao Lhao Lhao love wjh

-- LREM KEY_NAME COUNT VALUE
// 根据参数 COUNT 的值，移除列表中与参数 VALUE 相等的元素
// count &amp;gt; 0 : 从表头开始向表尾搜索，移除与 VALUE 相等的元素，数量为 COUNT 。
// count &amp;lt; 0 : 从表尾开始向表头搜索，移除与 VALUE 相等的元素，数量为 COUNT 的绝对值。
// count = 0 : 移除表中所有与 VALUE 相等的值。

&amp;gt; lrem users 2 Lhao // 输出：2
&amp;gt; lrange users 0 -1 // 输出：Lhao love wjh 

-- LSET KEY_NAME INDEX VALUE (通过索引来设置元素的值;当索引参数超出范围，或对一个空列表进行 LSET 时，返回一个错误)
&amp;gt; lset users 0 liuhao // 输出：ok
&amp;gt; lrange users 0 -1 // 输出：liuhao love wjh

&amp;gt; lpush fruit apple cherry strawbrerry

-- LTRIM KEY_NAME START STOP (对一个列表进行修剪(trim)，就是说，让列表只保留指定 区间内的元素，不在指定区间之内的元素都将被删除;下标 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。)
&amp;gt; ltrim fruit 1 -1 // 输出：ok
&amp;gt; lrange fruit 0 -1 // 输出：cherry apple

-- RPOP KEY_NAME （用于移除列表的最后一个元素，返回值为移除的元素）
&amp;gt; rpop fruit // 输出：apple
&amp;gt; lrange fruit 0 -1 // 输出：cherry

&amp;gt; lpush fruit apple cherry // 输出：3

-- RPOPLPUSH SOURCE_KEY_NAME DESTINATION_KEY_NAME （用于移除列表的最后一个元素，并将该元素添加到另一个列表并返回）
&amp;gt; rpoplpush fruit users // 输出：cherry
&amp;gt; lrange users 0 -1 // 输出：cherry、apple
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;集合-操作&#34;&gt;集合 操作&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt; flushdb

-- SADD KEY_NAME VALUE1..VALUEN（将一个或多个成员元素加入到集合中，已经存在于集合的成员元素将被忽略；假如集合 key 不存在，则创建一个只包含添加的元素作成员的集合；当集合 key 不是集合类型时，返回一个错误。）
&amp;gt; sadd users wjh Lhao // 输出：2
&amp;gt; sadd users wjh // 输出：0 

-- SMEMBERS key （返回集合中的所有的成员。 不存在的集合 key 被视为空集合）
&amp;gt; smembers users // 输出：wjh Lhao

-- SCARD KEY_NAME (返回集合中元素的数量)
&amp;gt; scard users // 输出：2 

&amp;gt; sadd usersTwo abing laoxia 
&amp;gt; smembers usersTwo // 输出：abing laoxia

-- SDIFF FIRST_KEY OTHER_KEY1..OTHER_KEYN (返回给定集合之间的差集。不存在的集合 key 将视为空集；差集的结果来自前面的 FIRST_KEY ,而不是后面的 OTHER_KEY1，也不是整个 FIRST_KEY OTHER_KEY1..OTHER_KEYN 的差集)
&amp;gt; sdiff users usersTwo // 输出：wjh Lhao
&amp;gt; sadd usersTwo Lhao
&amp;gt; sdiff users usersTwo // 输出：wjh

-- SDIFFSTORE DESTINATION_KEY KEY1..KEYN (将给定集合之间的差集存储在指定的集合中。如果指定的集合 key 已存在，则会被覆盖)
&amp;gt; sdiffstore usersThree users usersTwo // 输出：1
&amp;gt; smembers usersThree // 输出：wjh

&amp;gt; del users usersTwo usersThree

&amp;gt; sadd users wjh Lhao
&amp;gt; sadd usersTwo Lhao abing laoxia

-- SINTER KEY KEY1..KEYN (返回给定所有给定集合的交集。 不存在的集合 key 被视为空集。 当给定集合当中有一个空集时，结果也为空集(根据集合运算定律))
&amp;gt; sinter users usersTwo // 输出：Lhao

-- SINTERSTORE DESTINATION_KEY KEY KEY1..KEYN (将给定集合之间的交集存储在指定的集合中。如果指定的集合已经存在，则将其覆盖)
&amp;gt; sinterstore usersThree users usersTwo 
&amp;gt; smembers usersThree // 输出：Lhao

-- SISMEMBER KEY VALUE (判断成员元素是否是集合的成员)
&amp;gt; sismember users Lhao // 输出：1

&amp;gt; sadd fruits apple cherry
&amp;gt; sadd fruitsTwo strawbrerry

-- SMOVE SOURCE DESTINATION MEMBER
// 将指定成员 member 元素从 source 集合移动到 destination 集合。
// SMOVE 是原子性操作。
// 如果 source 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去。
// 当 destination 集合已经包含 member 元素时， SMOVE 命令只是简单地将 source 集合中的 member 元素删除。
// 当 source 或 destination 不是集合类型时，返回一个错误。
&amp;gt; smove fruitsTwo fruits strawbrerry  // 输出：1
&amp;gt; smembers fruits // 输出：cherry、apple、strawbrerry

-- SPOP key [count] (移除集合中的指定 key 的一个或多个随机元素，移除后会返回移除的元素)
&amp;gt; spop fruits // 输出：cherry
&amp;gt; smembers druits // 输出：strawbrerry、apple

-- SRANDMEMBER KEY [count] （返回集合中一个或多个随机数）
&amp;gt; srandmember fruit // 输出：apple 

-- SREM KEY MEMBER1..MEMBERN （移除集合中的一个或多个成员元素，不存在的成员元素会被忽略）
&amp;gt; srem fruits apple // 输出：1
&amp;gt; smembers fruits // 输出：strawbrerry

-- SUNION KEY KEY1..KEYN (返回给定集合的并集。不存在的集合 key 被视为空集)
&amp;gt; flushdb
&amp;gt; sadd fruits apple cherry 
&amp;gt; sadd fruitsTwo apple strawberry
&amp;gt; sunion fruits fruitsTwo // 输出：cherry、strawberry、apple

-- SUNIONSTORE DESTINATION KEY KEY1..KEYN （将给定集合的并集存储在指定的集合 destination 中。如果 destination 已经存在，则将其覆盖）
&amp;gt; sunionstore fruitsThree fruits fruitsTwo
&amp;gt; smembers fruitsThree // 输出：cherry、strawberry、apple

-- SSCAN key cursor [MATCH pattern] [COUNT count] （用于迭代集合中键的元素）
&amp;gt; sscan fruitsThree 0 match a* // (
输出：1) &amp;quot;0&amp;quot;
     2) 1) &amp;quot;apple&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;有序集合-操作&#34;&gt;有序集合 操作&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; &amp;gt; flushdb

 -- ZADD KEY_NAME SCORE1 VALUE1.. SCOREN VALUEN
    // 用于将一个或多个成员元素及其分数值加入到有序集当中。
    // 如果某个成员已经是有序集的成员，那么更新这个成员的分数值，并通过重新插入这个成员元素，来保证该成员在正确的位置上。
    // 分数值可以是整数值或双精度浮点数。
    // 如果有序集合 key 不存在，则创建一个空的有序集并执行 ZADD 操作。
    // 当 key 存在但不是有序集类型时，返回一个错误。
 &amp;gt; zadd myzset 1 &amp;quot;one&amp;quot; // 输出：1
 &amp;gt; zadd myzset 1 &amp;quot;uno&amp;quot;
 &amp;gt; zadd myzset 2 &amp;quot;two&amp;quot; 3 &amp;quot;three&amp;quot;

 -- ZRANGE key start stop [WITHSCORES]
    // 返回有序集中，指定区间内的成员。
    // 其中成员的位置按分数值递增(从小到大)来排序。
    // 具有相同分数值的成员按字典序(lexicographical order )来排列。
    // 如果你需要成员按值递减(从大到小)来排列，请使用 ZREVRANGE 命令。
    // 下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。
    // 你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推
 &amp;gt; zrange myzset 0 -1 WITHSCORES
 // 输出：
     1) &amp;quot;one&amp;quot;
     2) &amp;quot;1&amp;quot;
     3) &amp;quot;uno&amp;quot;
     4) &amp;quot;1&amp;quot;
     5) &amp;quot;two&amp;quot;
     6) &amp;quot;2&amp;quot;
     7) &amp;quot;three&amp;quot;
     8) &amp;quot;3&amp;quot;

 -- ZCARD KEY_NAME （用于计算集合中元素的数量）
 &amp;gt; zcard myzset // 输出：4

 -- ZCOUNT key min max (用于计算有序集合中指定分数区间的成员数量)
 &amp;gt; zcount myzset 1 3 // 输出：4

 -- ZINCRBY key increment member (对有序集合中指定成员的分数加上增量 increment)
 &amp;gt; zincrby myzset 2 &amp;quot;one&amp;quot; // 输出：3
 &amp;gt; zrange myzset 0 -1 WITHSCORES
 // 输出：
     1) &amp;quot;uno&amp;quot;
     2) &amp;quot;1&amp;quot;
     3) &amp;quot;two&amp;quot;
     4) &amp;quot;2&amp;quot;
     5) &amp;quot;one&amp;quot;
     6) &amp;quot;3&amp;quot;
     7) &amp;quot;three&amp;quot;
     8) &amp;quot;3&amp;quot;

 &amp;gt; zadd mid_test 70 Lhao 70 wjh
 &amp;gt; zadd fin_test 80 Lhao 78 wjh

 -- ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX] （计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。）
 &amp;gt; zinterstore sum_point 2 mid_test fin_test
 &amp;gt; zrange sum_point 0 -1 WITHSCORES
 // 输出：
     1) &amp;quot;wjh&amp;quot;
     2) &amp;quot;148&amp;quot;
     3) &amp;quot;Lhao&amp;quot;
     4) &amp;quot;150&amp;quot;

 -- ZLEXCOUNT KEY MIN MAX （计算有序集合中指定字典区间内成员数量）
 &amp;gt; zadd newzset 0 a 0 b 0 c 0 d 0 e 0 f 0 g
 &amp;gt; zlexcount newzset - + // 输出：7
 &amp;gt; zlexcount newzset [b [f // 输出：5

 -- ZRANGEBYLEX key min max [LIMIT offset count] (通过字典区间返回有序集合的成员)
 &amp;gt; zrangebylex newzset - [c
 // 输出：
     1) &amp;quot;b&amp;quot;
     2) &amp;quot;a&amp;quot;
     3) &amp;quot;c&amp;quot;
 &amp;gt; zrangebylex newzset - (c
  // 输出：
     1) &amp;quot;b&amp;quot;
     2) &amp;quot;a&amp;quot;
 &amp;gt; zrangebylex newzset [aaa (g
  // 输出：
     1) &amp;quot;b&amp;quot;
     2) &amp;quot;a&amp;quot;
     3) &amp;quot;c&amp;quot;
     4) &amp;quot;d&amp;quot;
     5) &amp;quot;e&amp;quot;
     6) &amp;quot;f&amp;quot;

 &amp;gt; zadd salary 2500 jack 5000 tom 12000 peter

 -- ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]
    // 返回有序集合中指定分数区间的成员列表。有序集成员按分数值递增(从小到大)次序排列。
    // 具有相同分数值的成员按字典序来排列(该属性是有序集提供的，不需要额外的计算)。
    // 默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)
 &amp;gt; zrangebyscore salary -inf +inf #显示整个有序集
 // 输出：
     1) &amp;quot;jack&amp;quot;
     2) &amp;quot;tom&amp;quot;
     3) &amp;quot;peter&amp;quot;
 &amp;gt; zrangebyscore salary -inf +inf WITHSCORES # 显示整个有序集及成员的 score 值
 // 输出：
     1) &amp;quot;jack&amp;quot;
     2) &amp;quot;2500&amp;quot;
     3) &amp;quot;tom&amp;quot;
     4) &amp;quot;5000&amp;quot;
     5) &amp;quot;peter&amp;quot;
     6) &amp;quot;12000&amp;quot;
 &amp;gt; zrangebyscore salary -inf 5000 WITHSCORES # 显示工资 &amp;lt;=5000 的所有成员
 // 输出：
     1) &amp;quot;jack&amp;quot;
     2) &amp;quot;2500&amp;quot;
     3) &amp;quot;tom&amp;quot;
     4) &amp;quot;5000&amp;quot;
 &amp;gt; zrangebyscore salary (5000 400000 # 显示工资大于 5000 小于等于 400000 的成员
 // 输出：
    1) &amp;quot;peter&amp;quot;

 -- ZRANK key member （返回有序集中指定成员的排名。其中有序集成员按分数值递增(从小到大)顺序排列）
 &amp;gt; zrank salary tom // 输出：1 （ # tom 的薪水排名，第二）

 -- ZREM key member [member ...] (用于移除有序集中的一个或多个成员，不存在的成员将被忽略;当 key 存在但不是有序集类型时，返回一个错误)
 &amp;gt; zrem salary tom // 输出：1
 &amp;gt; zrangebyscore salary -inf +inf WITHSCORES
 // 输出：
     1) &amp;quot;jack&amp;quot;
     2) &amp;quot;2500&amp;quot;
     3) &amp;quot;peter&amp;quot;
     4) &amp;quot;12000&amp;quot;

 &amp;gt; zadd myzset 0 aaaa 0 b 0 c 0 d 0 e 0 foo 0 zap 0 zip 0 ALPHA 0 alpha

 -- ZREMRANGEBYLEX key min max（用于移除有序集合中给定的字典区间的所有成员）
 &amp;gt; zremrangebylex myzset [alpha [omega // 输出：6
 &amp;gt; zrange myzset 0 -1
 // 输出：
     1) &amp;quot;ALPHA&amp;quot;
     2) &amp;quot;aaaa&amp;quot;
     3) &amp;quot;zap&amp;quot;
     4) &amp;quot;zip&amp;quot;

 &amp;gt; zadd salary 5000 tom

 -- ZREMRANGEBYRANK key start stop（用于移除有序集中，指定排名(rank)区间内的所有成员）
 &amp;gt; zremrangebyrank salary 0 1 // 输出：2
 &amp;gt; zrange salary 0 -1 WITHSCORES 
 // 输出：
     1) &amp;quot;peter&amp;quot;
     2) &amp;quot;12000&amp;quot;

 &amp;gt; zadd salary 2500 jack 5000 tom

 -- ZREMRANGEBYSCORE key min max (用于移除有序集中，指定分数（score）区间内的所有成员)
 &amp;gt; zremrangebyscore salary 1500 3500 // 输出：1
 &amp;gt; zrange salary 0 -1 WITHSCORES
 // 输出：
     1) &amp;quot;tom&amp;quot;
     2) &amp;quot;5000&amp;quot;
     3) &amp;quot;peter&amp;quot;
     4) &amp;quot;12000&amp;quot;

 &amp;gt; zadd salary 2500 jack

 -- ZREVRANGE key start stop [WITHSCORES]（返回有序集中，指定区间内的成员；其中成员的位置按分数值递减(从大到小)来排列。具有相同分数值的成员按字典序的逆序(reverse lexicographical order)排列；除了成员按分数值递减的次序排列这一点外， ZREVRANGE 命令的其他方面和 ZRANGE 命令一样）
 &amp;gt; zrevrange salary 0 -1 WITHSCORES
 // 输出：
     1) &amp;quot;peter&amp;quot;
     2) &amp;quot;12000&amp;quot;
     3) &amp;quot;tom&amp;quot;
     4) &amp;quot;5000&amp;quot;
     5) &amp;quot;jack&amp;quot;
     6) &amp;quot;2500&amp;quot;

 -- ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]（返回有序集中指定分数区间内的所有的成员。有序集成员按分数值递减(从大到小)的次序排列）
 &amp;gt; zrevrangebyscore salary +inf -inf # 逆序排列所有成员
 //输出：
     1) &amp;quot;peter&amp;quot;
     2) &amp;quot;tom&amp;quot;
     3) &amp;quot;jack&amp;quot;
 &amp;gt; zrevrangebyscore salary 10000 200 # 逆序排列薪水介于 10000 和 2000 之间的成员
 // 输出：
     1) &amp;quot;tom&amp;quot;
     2) &amp;quot;jack&amp;quot;

 -- ZREVRANK key member（返回有序集中成员的排名。其中有序集成员按分数值递减(从大到小)排序；排名以 0 为底，也就是说， 分数值最大的成员排名为 0 ；使用 ZRANK 命令可以获得成员按分数值递增(从小到大)排列的排名）
 &amp;gt; zrevrank salary peter // 输出：0
 &amp;gt; zrevrank salary tom // 输出：1

 -- ZSCORE key member (返回有序集中，成员的分数值。 如果成员元素不是有序集 key 的成员，或 key 不存在，返回 nil )
 &amp;gt; zscore salary peter // 输出：12000

 &amp;gt; zadd programmer 2000 peter 3500 jack 5000 tom
 &amp;gt; zadd manager 2000 herry 3500 mary 4000 bob

 -- ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]（计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination；默认情况下，结果集中某个成员的分数值是所有给定集下该成员分数值之和）

 &amp;gt; zunionstore salary 2 programmer manager WEIGHTS 1 3 # # 公司决定加薪。。。除了程序员。。。
 &amp;gt; zrange salary 0 -1 WITHSCORES
 // 输出：
      1) &amp;quot;peter&amp;quot;
      2) &amp;quot;2000&amp;quot;
      3) &amp;quot;jack&amp;quot;
      4) &amp;quot;3500&amp;quot;
      5) &amp;quot;tom&amp;quot;
      6) &amp;quot;5000&amp;quot;
      7) &amp;quot;herry&amp;quot;
      8) &amp;quot;6000&amp;quot;
      9) &amp;quot;mary&amp;quot;
     10) &amp;quot;10500&amp;quot;
     11) &amp;quot;bob&amp;quot;
     12) &amp;quot;12000&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;结束语&#34;&gt;结束语&lt;/h3&gt;
&lt;p&gt;这里只是简单的对 redis 的各种类型做了一下介绍以及一些操作方法&lt;/p&gt;
">Redis 基础学习</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/netmusic-qcloud/"" data-c="
          &lt;p&gt;使用腾讯云云函数实现网易云自动打卡和签到功能！&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;在这篇文章中，我将主要介绍如何使用腾讯云中的云函数来实现网易云自动打卡和签到功能。本文中的 PHP 源代码可以在 &lt;a href=&#34;https://github.com/wwxiaoqi/TencentNeteaseCloudPunch&#34;&gt;GitHub&lt;/a&gt; 上找到。&lt;/p&gt;
&lt;p&gt;说明：PHP 里面的 localurl，username，password 需要修改才能正常使用， 在这里提供一些网上公益的 &lt;a href=&#34;https://tahicokey.oss-cn-shanghai.aliyuncs.com/Blog/TencentNeteaseCloudPunch/Netease_API.txt&#34;&gt;API&lt;/a&gt; ，完全性未知，在使用 API 过程中发生的一切事情均与我无关。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文&lt;/h2&gt;
&lt;p&gt;文章的正文分为两个部分：基础集成和原生部署，第一部分是文章的主体，第二部分供喜欢网易云的研究。&lt;/p&gt;
&lt;p&gt;当你按照此文章成功设置完成，将：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拥有网易云自动打卡&lt;/li&gt;
&lt;li&gt;无需手动，完全自动&lt;/li&gt;
&lt;li&gt;定时签到&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;基础集成&#34;&gt;基础集成&lt;/h2&gt;
&lt;p&gt;你需要准备的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;腾讯云账号，且实名验证完成&lt;/li&gt;
&lt;li&gt;一个网易云 API&lt;/li&gt;
&lt;li&gt;网易云音乐账号密码&lt;br&gt;
首先，先打开 &lt;a href=&#34;https://cloud.tencent.com/&#34;&gt;腾讯云&lt;/a&gt; ，找到 &lt;a href=&#34;https://cloud.tencent.com/product/scf&#34;&gt;云函数&lt;/a&gt; 在新建函数页面填写函数基础信息，单击【下一步】，如下图所示：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1592984081483.jpg&#34; alt=&#34;1.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;函数名称：可随便命名&lt;/li&gt;
&lt;li&gt;运行环境：选择 “PHP 7.2”&lt;/li&gt;
&lt;li&gt;创建方式：选择 “空白函数”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接着在函数配置界面中填写其他信息，然后点击【完成】，如下图所示：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1592984087418.jpg&#34; alt=&#34;2.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;此处代码修改为本文的 PHP 源代码&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1592984096560.jpg&#34; alt=&#34;3.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;超时时间修改为 600s&lt;/p&gt;
&lt;h2 id=&#34;基础触发&#34;&gt;基础触发&lt;/h2&gt;
&lt;p&gt;接着配置一下触发方式，点击【保存】，如下图所示：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1592984127329.jpg&#34; alt=&#34;4.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1592984141422.jpg&#34; alt=&#34;5.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;定时任务名称：可随便命名&lt;/li&gt;
&lt;li&gt;触发周期：选择 “自定义触发”&lt;/li&gt;
&lt;li&gt;Cron 表达式：填写 “00 30 6 */1 * * *”&lt;br&gt;
&lt;img src=&#34;https://imcm.xyz/post-images/1592984152914.jpg&#34; alt=&#34;6.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到此处基础部分就已经完成啦，下面是原生部署方式。&lt;/p&gt;
&lt;h2 id=&#34;原生部署&#34;&gt;原生部署&lt;/h2&gt;
&lt;p&gt;你需要准备的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一台支持 Node.js 的服务器&lt;/li&gt;
&lt;li&gt;API 源代码：&lt;a href=&#34;https://github.com/Binaryify/NeteaseCloudMusicApi&#34;&gt;NeteaseCloudMusicApi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;会简单 Linux 基础&lt;br&gt;
首先，先连接 Linux 并安装 Git，nodejs：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pkg install git
pkg install nodejs
pkg install nodejs-current
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后使用 Git 下载 API 源代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone git@github.com:Binaryify/NeteaseCloudMusicApi.git
npm install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在然后运行 app.js：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;node app.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如需要修改默认端口号，可这样实现：&lt;/p&gt;
&lt;p&gt;Mac/Linux：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;PORT=4000 node app.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Windows：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;set PORT=4000 &amp;amp;&amp;amp; node app.js
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;结尾&#34;&gt;结尾&lt;/h2&gt;
&lt;p&gt;这就是本文的全部内容啦，经过一段时间的使用，体验还是非常棒的！&lt;/p&gt;
">使用腾讯云实现网易云自动打卡签到</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/laravel-composer-note/"" data-c="
          &lt;p&gt;记录Composer版本说明和如何在正式环境使用Composer安装Laravel依赖并排除开发环境需要的第三方开发包&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;使用-composer-安装&#34;&gt;使用 Composer 安装：&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ composer require &amp;quot;barryvdh/laravel-debugbar:~3.2&amp;quot; --dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上命令，版本限定符 ~ 意味着我们希望安装 &lt;code&gt;&amp;gt;= 3.2&lt;/code&gt; 并且 &lt;code&gt;&amp;lt; 4.0&lt;/code&gt; 的版本，例如 &lt;code&gt;3.2.1&lt;/code&gt;、 &lt;code&gt;3.11.3&lt;/code&gt;、 &lt;code&gt;3.8&lt;/code&gt;。根据语义化版本的定义，次版本号的变化是新增功能，所以 API 是稳定的，也就是可以安全更新的。&lt;/p&gt;
&lt;h3 id=&#34;什么是语义化版本&#34;&gt;什么是语义化版本？&lt;/h3&gt;
&lt;p&gt;版本格式：主版本号。次版本号。修订号，如 &lt;code&gt;1.0.1&lt;/code&gt;, &lt;code&gt;3.2.39&lt;/code&gt;。版本号递增规则如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主版本号&lt;/strong&gt;：当你做了不兼容的 API 修改&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;次版本号&lt;/strong&gt;：当你做了向下兼容的功能性新增&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;修订号&lt;/strong&gt;：当你做了向下兼容的问题修正。&lt;br&gt;
另外，先行版本号及版本编译信息可以加到 &lt;code&gt;主版本号.次版本号.修订号&lt;/code&gt; 的后面，作为延伸。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般我们使用 3 个部分来表示一个版本，例如：1.4.23，1 为主版本号，4 为次版本号，23 为修订号或者补丁版本号。先行版本如 &lt;code&gt;1.0.0-alpha1&lt;/code&gt; 这样在后面添加修饰符号来表示。&lt;/p&gt;
&lt;p&gt;最后 Composer 安装时 &lt;code&gt;--dev&lt;/code&gt; 参数是指明只在 &lt;strong&gt;开发环境&lt;/strong&gt; 中使用，这样上线代码到 &lt;strong&gt;生产环境&lt;/strong&gt; 时，我们可使用 &lt;code&gt;composer install --no-dev&lt;/code&gt; 命令来排除这些扩展包的安装。&lt;/p&gt;
">Laravel Composer 笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/gyp-no-xcode/"" data-c="
          &lt;p&gt;npm install 安装依赖包报如下错误&lt;/p&gt;
&lt;!-- more --&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1592363327243.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;解决思路&#34;&gt;解决思路&lt;/h3&gt;
&lt;p&gt;Mac升级到High sierra 后，发现执行使用npm 或者yarn 的时候，不时会报&lt;code&gt;gyp: No Xcode or CLT version detected!&lt;/code&gt; 的错误, 原因是缺了xcode 的CLI 工具, 只要执行下面的命令来安装就可以了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo xcode-select --install
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;再执行&#34;&gt;再执行&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; $ xcode-select --install
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;后出现错误&#34;&gt;后出现错误&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;xcode-select: error: command line tools are already installed, use &amp;quot;Software Update&amp;quot; to install updates
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;解决办法&#34;&gt;解决办法&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ sudo rm -rf $(xcode-select -print-path)
$ xcode-select --install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;问题完美解决&lt;br&gt;
如果提示权限不够那么加上sudo&lt;/p&gt;
">gyp: No Xcode or CLT version detected!</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/docker-openwrt/"" data-c="
          &lt;p&gt;今天小苏为大家带来的是（咕很久的）在 Docker 中运行 OpenWrt 做旁路网关的教程~&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;本文转自： &lt;a href=&#34;https://mlapp.cn/376.html&#34;&gt;美丽应用&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;场景1&#34;&gt;场景1&lt;/h3&gt;
&lt;p&gt;众所周知，OpenWrt 是面向嵌入型设备的 Linux 发行版，所以 OpenWrt 系统运行时的资源占用率会很低。而树莓派的硬件性能要比普通路由器要高很多。虽然树莓派在硬件配置上的绝对优势能让 OpenWrt 有更大的施展空间，但相应的，硬件上的优势也带来了资源的浪费（OpenWrt 在树莓派上正常运行时，资源占用率只有不到 1/10）。再加上 OpenWrt 的可扩展性不是很强，所以很多能在 Raspbian/Debian 上能做的事情在 OpenWrt 上往往无法实现。&lt;/p&gt;
&lt;p&gt;所以，可不可以让 OpenWrt 与我们常用的系统共存呢？这样，我们可以享受到 OpenWrt 的功能，又可以让在我们常用的系统中完成一般性的 Linux 工作。&lt;/p&gt;
&lt;p&gt;通过 Docker，完全可以。&lt;/p&gt;
&lt;h3 id=&#34;场景2&#34;&gt;场景2&lt;/h3&gt;
&lt;p&gt;OpenWrt 的功能固然强大，但是树莓派的板载网卡无线吞吐能力实在是无力吐槽，能否将现有路由器与树莓派结合使用，同时发挥现有路由器的信号优势与 OpenWrt 的软件优势呢？&lt;/p&gt;
&lt;p&gt;通过旁路网关，完全可以。&lt;/p&gt;
&lt;h3 id=&#34;旁路网关&#34;&gt;旁路网关&lt;/h3&gt;
&lt;p&gt;那么，什么是旁路网关呢？&lt;/p&gt;
&lt;p&gt;普通的路由器往往集无线信号转发、网关、DNS 服务器等角色为一身，其中的“网关”角色负责路由器内部数据的处理。但因为一般家用的路由器硬件性能很有限，在运行一些比较吃资源的应用（如酸酸乳、去广告等）时，几乎会占满所有硬件资源，导致路由器网络/系统不稳定等诸多问题。既然路由器的硬件性能有限，那可不可以把网关的重任交给硬件性能更好的设备去做，让路由器安安心心地做好它的老本行 – 无线转发呢？&lt;/p&gt;
&lt;p&gt;完全可以。&lt;/p&gt;
&lt;p&gt;所谓的旁路网关，就是在路由器之外的其他硬件设备上搭建一个网关环境，把路由器肩负的网关重任交给其他更适合的设备来做，同时，旁路网关处理完的结果会返回给路由器，由路由器继续进行无线转发。&lt;/p&gt;
&lt;p&gt;这样，每个角色各司其职，路由器肩上的任务轻了，即使是油管 4K 也能轻松跑满网速了，而旁路由（树莓派）也结束了它吃灰的命运。由此资源的充分利用，一举两得。&lt;/p&gt;
&lt;p&gt;在接下来的文章中，我们将在 Docker 容器中运行 OpenWrt，并通过设置，让 Docker 容器中的 OpenWrt 网关接管路由器自身的网关，减轻路由器的负担，同时，由于网关被 OpenWrt 接管，所以 OpenWrt 中的大部分应用都是可用的，比如酸酸乳，V2ray，去广告等。做个不恰当的比喻， OpenWrt 网关接管路由器自身的网关后，你可以理解为路由器是 OpenWrt 的一块外置网卡。&lt;/p&gt;
&lt;h3 id=&#34;镜像介绍&#34;&gt;镜像介绍&lt;/h3&gt;
&lt;p&gt;小苏为大家提供的 OpenWrt 镜像所用系统为基于 Lean 大源码编译的 32位/ IPV4 Only 固件，基本功能与之前的自编译固件相同，并且 Docker 镜像将跟随自编译固件的更新而更新。自编译固件的详细介绍请见：&lt;br&gt;
&lt;a href=&#34;https://mlapp.cn/369.html&#34;&gt;https://mlapp.cn/369.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但值得注意的是，Docker 固件没有无线及无线相关功能。在以后的文章中，小苏将给大家分享 OpenWrt 镜像的制作步骤，敬请期待~（Q：喂！你挖的坑还不够多吗？A：咕咕咕！）。&lt;/p&gt;
&lt;h3 id=&#34;重要说明&#34;&gt;重要说明&lt;/h3&gt;
&lt;p&gt;1.&lt;strong&gt;此教程中提到的 Docker 镜像只适用于树莓派 2B/3B/3B+/4B，在其他设备上理论上不能正常使用&lt;/strong&gt;。但文中所述内容对其他设备应该有参考意义。&lt;/p&gt;
&lt;p&gt;2.在 Docker 中运行 OpenWrt ，树莓派将工作在旁路网关模式下，在这种工作模式下，树莓派的板载无线网卡不会工作（同时在 OpenWrt 的控制面板中也找不到有关 WIFI 的设置）。所以，需要将树莓派与路由器通过网线连接来使用。&lt;/p&gt;
&lt;h3 id=&#34;前期准备&#34;&gt;前期准备&lt;/h3&gt;
&lt;p&gt;既然需要在 Docker 中运行 OpenWrt ，那么首先需要在树莓派的现有系统上安装 Docker，在不同发行版上安装 Docker 的教程有很多，大家可以自行在搜索引擎中搜索相关内容以完成 Docker 的安装。&lt;/p&gt;
&lt;p&gt;如果你的设备是 3B/3B+/4B，小苏推荐使用“树莓派爱好者基地”编译的 64 位 Debian，此版本 Debian 可以充分发挥 64 位 CPU 的性能，同时默认开启 Docker，KVM 等功能，其中，Docker 功能开箱即用，非常方便。&lt;/p&gt;
&lt;p&gt;如果你的设备是树莓派2B，那么你可能需要在其他发行版上手动安装 Docker 了，但是小苏提供的 Docker 镜像是支持 2B~4B 设备的，换句话说，只要在其他发行版上成功安装了 Docker，也是可以用我提供的 OpenWrt 镜像的。&lt;/p&gt;
&lt;p&gt;为了方便叙述以及为大家提供一个参考的宿主机环境，下文内容基于“树莓派爱好者基地”编译的 64 位 Debian。当然，如果你在你使用的发行版上安装了 Docker，步骤是一样的。&lt;/p&gt;
&lt;p&gt;“树莓派爱好者基地”专版64位 Debian 功能介绍（内含下载链接）：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/openfans-community-offical/Debian-Pi-Aarch64/blob/master/README_zh.md&#34;&gt;https://github.com/openfans-community-offical/Debian-Pi-Aarch64&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载时推荐选择“无桌面基础系统加强版”（如下图），如果你有图形界面需求，也可以选择带图形界面的其他版本镜像。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1591772689336.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;下载镜像烧写到树莓派的 SD 卡并上电开机后，系统会自动完成扩展 SD 卡空间的操作，这个过程大约需要3~5分钟（期间会重启几次）。估摸着时间差不多以后，用网线将树莓派的板载网口与路由器的 Lan 口连接，之后连接树莓派的 SSH：&lt;/p&gt;
&lt;p&gt;用户名：pi&lt;br&gt;
密码：raspberry&lt;/p&gt;
&lt;p&gt;准备工作到此结束。&lt;/p&gt;
&lt;h3 id=&#34;步骤开始&#34;&gt;步骤开始&lt;/h3&gt;
&lt;p&gt;成功登陆到树莓派的 SSH 后，在拉取镜像之前，我们还需要进行一些额外的工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h4 id=&#34;打开网卡混杂模式&#34;&gt;打开网卡混杂模式&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo ip link set eth0 promisc on
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;h4 id=&#34;创建网络须结合实际网络情况不能照抄命令&#34;&gt;创建网络(须结合实际网络情况，不能照抄命令)&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker network create -d macvlan --subnet=192.168.123.0/24 --gateway=192.168.123.1 -o parent=eth0 macnet
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这一条命令需要根据树莓派所处的网络环境来做修改，可以使用 sudo ifconfig命令来查看树莓派 eth0 网卡获得的 IP 地址，如果树莓派获得的 IP 地址为 192.168.2.154，那么说明树莓派处在 192.168.2.x网段，相应的，命令中的192.168.123.0和192.168.123.1需要被替换成 192.168.2.0和192.168.2.1：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker network create -d macvlan --subnet=192.168.2.0/24 --gateway=192.168.2.1 -o parent=eth0 macnet
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时，我们使用 docker network ls命令可以看到网络macnet已建立成功：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
10e676133746        bridge              bridge              local
f5308b94e8fa        host                host                local
16745ea66852        macnet              macvlan             local
5e72e41ea02a        none                null                local
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;h4 id=&#34;拉取镜像&#34;&gt;拉取镜像&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;若身处国内，为提高拉取速度，请拉取阿里云仓库中的镜像：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker pull registry.cn-shanghai.aliyuncs.com/suling/openwrt:latest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同时小苏也提供存放在 Docker 官方仓库 中的镜像：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker pull sulinggg/openwrt:latest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;镜像拉取完成后，我们可以执行docker images命令查看现存镜像：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker images
REPOSITORY                                              TAG                 IMAGE ID            CREATED             SIZE
registry.cn-shanghai.aliyuncs.com/suling/openwrt        latest              4f4bc5dca2d9        3 hours ago         112MB
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可见，镜像已成功拉取到本地。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;h4 id=&#34;创建并启动容器&#34;&gt;创建并启动容器&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run --restart always --name openwrt -d --network macnet --privileged registry.cn-shanghai.aliyuncs.com/suling/openwrt:latest /sbin/init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中：&lt;br&gt;
--restart always参数表示容器退出时始终重启，使服务尽量保持始终可用；&lt;br&gt;
--name openwrt参数定义了容器的名称；&lt;br&gt;
-d参数定义使容器运行在 Daemon 模式；&lt;br&gt;
--network macnet参数定义将容器加入 maxnet网络；&lt;br&gt;
--privileged 参数定义容器运行在特权模式下；&lt;br&gt;
registry.cn-shanghai.aliyuncs.com/suling/openwrt:latest为 Docker 镜像名，因容器托管在阿里云 Docker 镜像仓库内，所以在镜像名中含有阿里云仓库信息；&lt;br&gt;
/sbin/init定义容器启动后执行的命令。&lt;br&gt;
启动容器后，我们可以使用 docker ps -a命令查看当前运行的容器：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
a26cee7cade6        openwrt:latest      &amp;quot;/sbin/init&amp;quot;        3 hours ago         Up 3 hours                              openwrt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;若容器运行信息STATUS列为 UP状态，则说明容器运行正常。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;
&lt;h4 id=&#34;进入容器并修改相关参数&#34;&gt;进入容器并修改相关参数&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(须结合实际网络情况，不能照抄配置)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker exec -it openwrt bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中：&lt;br&gt;
openwrt为容器名称；&lt;br&gt;
bash为进入容器后执行的命令。&lt;br&gt;
执行此命令后我们便进入 OpenWrt 的命令行界面，首先，我们需要编辑 OpenWrt 的网络配置文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /etc/config/network
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们需要更改 Lan 口设置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;config interface &#39;lan&#39;
        option type &#39;bridge&#39;
        option ifname &#39;eth0&#39;
        option proto &#39;static&#39;
        option ipaddr &#39;192.168.123.100&#39;
        option netmask &#39;255.255.255.0&#39;
        option ip6assign &#39;60&#39;
        option gateway &#39;192.168.123.1&#39;
        option broadcast &#39;192.168.123.255&#39;
        option dns &#39;192.168.123.1&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中：&lt;br&gt;
所有的 192.168.123.x 需要根据树莓派所处网段修改，option gateway和option dns填写路由器的 IP，若树莓派获得的 IP 为 192.168.2.154，路由器 IP 为192.168.2.1，则需要这样修改：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;config interface &#39;lan&#39;
        option type &#39;bridge&#39;
        option ifname &#39;eth0&#39;
        option proto &#39;static&#39;
        option ipaddr &#39;192.168.2.100&#39;
        option netmask &#39;255.255.255.0&#39;
        option ip6assign &#39;60&#39;
        option gateway &#39;192.168.2.1&#39;
        option broadcast &#39;192.168.2.255&#39;
        option dns &#39;192.168.2.1&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;option ipaddr 项目定义了 OpenWrt 的 IP 地址，在完成网段设置后，IP最后一段可根据自己的爱好修改（前提是符合规则且不和现有已分配 IP 冲突）。&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;
&lt;h4 id=&#34;重启网络&#34;&gt;重启网络&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/etc/init.d/network restart
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;
&lt;h4 id=&#34;进入控制面板&#34;&gt;进入控制面板&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在浏览器中输入第 5 步option ipaddr 项目中的 IP 进入 Luci 控制面板，若option ipaddr 的参数为 192.168.123.100，则可以在浏览器输入 http://192.168.123.100进入控制面板。&lt;/p&gt;
&lt;p&gt;用户名：root&lt;br&gt;
密码：password&lt;/p&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;
&lt;h4 id=&#34;关闭-dhcp-服务&#34;&gt;关闭 DHCP 服务&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 “网络 - 接口 - Lan - 修改” 界面中，勾选下方的 “忽略此接口（不在此接口提供 DHCP 服务）”，并“保存&amp;amp;应用”。&lt;br&gt;
&lt;img src=&#34;https://imcm.xyz/post-images/1591772717735.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;
&lt;h4 id=&#34;主路由-dhcp-设置&#34;&gt;主路由 DHCP 设置&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;进入路由器后台中，将主路由的 DHCP 的默认网关和 DNS 服务器设置为第 5 步中option ipaddr 项目中的 IP。&lt;br&gt;
&lt;img src=&#34;https://imcm.xyz/post-images/1591772738952.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;10&#34;&gt;
&lt;li&gt;
&lt;h4 id=&#34;重新连接路由器&#34;&gt;重新连接路由器&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;完成以上操作后，断开设备（如手机，电脑）与路由器的连接，重新连接路由器，连接路由器的设备将获取到我们设置到的 IP。&lt;/p&gt;
&lt;h3 id=&#34;其他修复&#34;&gt;其他修复&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h4 id=&#34;关闭-wlan-硬件加速&#34;&gt;关闭 WLAN 硬件加速&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;设置旁路路由后，若出现访问国内网站网速慢，不稳定的情况（多见于 Pandavan 及其改版固件，如华硕老毛子固件），请在路由器的控制面板中关闭有关 WLAN 的硬件加速，比如选择“Offload TCP/UDP for LAN”（若未出现此现象请忽略）：&lt;br&gt;
&lt;img src=&#34;https://imcm.xyz/post-images/1591772753376.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;h4 id=&#34;宿主机网络修复&#34;&gt;宿主机网络修复&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;OpenWrt 容器运行后，宿主机内可能无法正常连接外部网络，需要修改宿主机的 /etc/network/interfaces 文件以修复：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(须结合实际网络情况，不能照抄配置)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cp /etc/network/interfaces /etc/network/interfaces.bak # 备份文件
vim /etc/network/interfaces # 使用 vim 编辑文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以“树莓派爱好者基地”64 位 Debian 为例，向文件末尾添加：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;auto eth0
iface eth0 inet manual

auto macvlan
iface macvlan inet static
  address 192.168.123.200
  netmask 255.255.255.0
  gateway 192.168.123.1
  dns-nameservers 192.168.123.1
  pre-up ip link add macvlan link eth0 type macvlan mode bridge
  post-down ip link del macvlan link eth0 type macvlan mode bridge
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，所有的 192.168.123.x都需要按照树莓派所处网段更改，gateway和dns-nameservers填写路由器的 IP，若树莓派获得的 IP 为 192.168.2.154，路由器 IP 为192.168.2.1，则需要这样修改：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;auto eth0
iface eth0 inet manual

auto macvlan
iface macvlan inet static
  address 192.168.2.200
  netmask 255.255.255.0
  gateway 192.168.2.1
  dns-nameservers 192.168.2.1
  pre-up ip link add macvlan link eth0 type macvlan mode bridge
  post-down ip link del macvlan link eth0 type macvlan mode bridge
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改后重启树莓派，之后树莓派的局域网 IP 地址将会固定为/etc/network/interfaces文件中address参数中的地址。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;h4 id=&#34;手动指定网关&#34;&gt;手动指定网关&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果路由器固件不支持自定义 DHCP 服务的网关及 DNS 地址（常见于路由器官方固件），或者只希望局域网下的个别设备接入旁路网关时，须在接入设备上做以下配置：&lt;/p&gt;
&lt;h5 id=&#34;安卓&#34;&gt;安卓：&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1591772765001.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;需要在安卓的 WIFI 设置内将 IP 获取方式更改为“静态”或“手动”，其中：&lt;br&gt;
“IP 地址”项目需要更改为网段内不冲突的地址；&lt;br&gt;
“网关”或“路由器”项目需要更改为旁路网关 IP 地址；&lt;br&gt;
“前缀长度”项目填写“24”；&lt;br&gt;
“DNS”项目需要更改为旁路网关 IP 地址（两个 DNS 输入框填写一个就可以）。&lt;/p&gt;
&lt;p&gt;完成并提交设置后，关闭 WIFI 开关再打开，连接设置的 WIFI 热点，若当前网络参数为设定值，则证明设置成功。&lt;/p&gt;
&lt;h5 id=&#34;windows&#34;&gt;Windows:&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1591772774844.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在无线热点的“属性”界面下，点击 “IP 设置 - 编辑”按钮，在弹出框中更改 IP 分配模式为“手动”，打开 IPV4 的开关，根据所处网段及上文安卓的相关设置填写相关参数即可。&lt;/p&gt;
&lt;h3 id=&#34;注意事项&#34;&gt;注意事项&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;文章所述方案适用于光猫或路由器已完成宽带拨号的网络环境，未测试也不推荐使用 Docker 内的 OpenWrt 进行宽带拨号；&lt;/li&gt;
&lt;li&gt;OpenWrt 容器跟随树莓派系统启动，无需手动干预；&lt;/li&gt;
&lt;li&gt;由于容器内系统内核共享宿主机内核，所以在 Luci 面板的 “内核版本”项与宿主机内核版本一致；&lt;/li&gt;
&lt;li&gt;在对容器进行停止或删除操作时，树莓派可能会发生卡顿现象，SSH 可能会断开，1~2 分钟后会恢复正常，目前原因不明；&lt;/li&gt;
&lt;li&gt;经测试，发现 Adblock 不工作，UnblockNeteaseMusic 需要自行设置代理，除此之外容器中的 OpenWrt 多数应用工作正常，如有发现不能正常工作的应用请评论反馈~&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考资料&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/coolsnowwolf/lede&#34;&gt;OpenWrt By Lean · coolsnowwolf/lede - GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.right.com.cn/forum/thread-588747-1-1.html&#34;&gt;【小狮子编译贴】抛砖引玉，为打造N1路由神器 - 恩山无线论坛&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.right.com.cn/forum/thread-1048535-1-1.html&#34;&gt;docker openwrt 踩坑的几个小问题解决过程分享 - 恩山无线论坛&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.right.com.cn/forum/thread-506510-1-1.html&#34;&gt;N1刷入LEAN OPENWRT做旁路网关，导致访问国内网站卡顿 - 恩山无线论坛&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
">在Docker 中运行 OpenWrt 旁路网关</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/chown-git/"" data-c="
          &lt;p&gt;git 中可以加入忽略文件权限的配置，在 git 根目录运行如下命令：&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;当前版本库忽略文件权限&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config core.filemode false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;复制所有版本库忽略文件权限&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global core.fileMode false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就设置了忽略文件权限。&lt;/p&gt;
&lt;p&gt;查看 git 的配置文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat .git/config
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时候再更新代码就 OK 了。&lt;/p&gt;
">Git 忽略文件目录权限或文件拥有者的改变</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/mac-backup-pi/"" data-c="
          &lt;p&gt;在树莓派的SD卡中初始写入了一个img系统镜像，在安装各种软件以后我们有必要对树莓派的分区进行类似GHOST的备份&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;备份系统&#34;&gt;备份系统&lt;/h3&gt;
&lt;p&gt;将TF插入mac后，打开mac的“终端”&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#查询盘符
diskutil list 
# 下面图片中的dev/disk2既对应的树莓派的TF卡
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1591677273477.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
终端运行diskutil list 后显示的内容&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 使用dd进行备份，同时使用gzip将备份文件进行压缩
sudo dd if=/dev/rdiskx bs=1m | gzip &amp;gt; /path/to/backupImage.gz
#将“/dev/rdiskx ”改成您 Micro SD 卡的所在位置， if 參數是指定資料來源 (也就是 Micro #SD 卡)   of 則是指定備份影像檔的儲存路徑與檔案名稱 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;回车后，读卡器会显示在读取数据灯在闪烁，备份过程有点长，根据卡的大小，可能会在1小时左右。&lt;/p&gt;
&lt;h3 id=&#34;恢复系统&#34;&gt;恢复系统&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;★ 將壓縮的備份影像檔回復至 Micro SD 卡中
gzip -dc /path/to/backupImage.gz | sudo dd of=/dev/rdiskx bs=1m
※ /dev/rdiskx 請改成您 Micro SD 卡的所在位置
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果系统显示resource busy,表明需要先将TF卡从系统中卸载。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#列出盘符名称，这里的名称显示和之前的不一样
df -f
#卸载
sudo diskutil unmount /dev/disk2s1
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imcm.xyz/post-images/1591677296376.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">备份树莓派系统（MacOS)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/gitignore-mac/"" data-c="
          &lt;p&gt;最近在 Mac 中使用 Git 上传项目时，发现 GitHub 仓库的每个文件夹下都生成了一个 .DS_Store 的文件，好奇查了一下这个文件格式，在网上搜索了一下解决办法，这里记录一下怎么删除 .DS_Store 文件以及如何在后续使用 Git时忽略掉 .DS_Store 文件。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;ds_store&#34;&gt;.DS_Store&lt;/h2&gt;
&lt;p&gt;.DS_Store 是 Mac OS 保存文件夹的自定义属性的隐藏文件，如文件的图标位置或背景色，删除后会自动生成，包含了一些文件的个人信息，如果不处理的话，可能会有一些你不一定希望别人看到的信息。&lt;/p&gt;
&lt;h3 id=&#34;解决办法1创建一个-gitignore-文件来忽略-ds_store&#34;&gt;解决办法1:创建一个 .gitignore 文件来忽略 .DS_Store&lt;/h3&gt;
&lt;p&gt;首先需要删除项目文件夹下已经生成的 .DS_Store 文件。&lt;/p&gt;
&lt;p&gt;终端切换到项目文件夹，输入 git status 来查看是否有 .DS_Store 文件，如果有相关文件，终端输入下面的命令将它删除。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建一个名为.gitignore的文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;touch .gitignore
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打开创建好的 .gitignore文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;open .gitignore
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入 .DS_Store ，然后换行继续输入 /.DS_Store ，command +s保存&lt;/p&gt;
&lt;p&gt;更新项目&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git add --all
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提交到远程仓库&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git commit -m &#39;.DS_Store ignore&#39;
git push
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的办法只能对这个项目文件夹起作用，其它的 Git 项目文件夹要想忽略，还要重新搞一遍，所以可以做一盒全局忽略。&lt;/p&gt;
&lt;h3 id=&#34;解决办法2创建全局-gitignore-文件来忽略-ds_store&#34;&gt;解决办法2:创建全局 .gitignore 文件来忽略 .DS_Store&lt;/h3&gt;
&lt;p&gt;创建 .gitignore_global 文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;touch .gitignore_global 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打开创建好的 .gitignore_global 文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Open .gitignore_global
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入 .DS_Store ，然后换行继续输入 /.DS_Store ，command +s保存&lt;/p&gt;
&lt;p&gt;打开 .gitconfig&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;open .gitconfig
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 ~/.gitconfig 中引入 .gitignore_global&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[core]
​    excludesfile = /Users/w/.gitignore_global
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后更新提交项目即可&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：user/后面填写你的电脑的用户名&lt;/p&gt;
&lt;/blockquote&gt;
">删除Mac下Git上传项目代码时产生的.DS_Store文件</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/markdown/"" data-c="
          &lt;h2 id=&#34;主要内容&#34;&gt;主要内容&lt;/h2&gt;
&lt;h4 id=&#34;-markdown是什么&#34;&gt;- Markdown&lt;em&gt;是什么&lt;/em&gt;？&lt;/h4&gt;
&lt;h4 id=&#34;-谁创造了它&#34;&gt;- &lt;em&gt;谁&lt;/em&gt;创造了它？&lt;/h4&gt;
&lt;h4 id=&#34;-为什么要使用它&#34;&gt;- &lt;em&gt;为什么&lt;/em&gt;要使用它？&lt;/h4&gt;
&lt;h4 id=&#34;-怎么使用&#34;&gt;- &lt;em&gt;怎么&lt;/em&gt;使用？&lt;/h4&gt;
&lt;h4 id=&#34;-谁在用&#34;&gt;- &lt;em&gt;谁&lt;/em&gt;在用？&lt;/h4&gt;
&lt;h4 id=&#34;-尝试一下&#34;&gt;- 尝试一下&lt;/h4&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文&lt;/h2&gt;
&lt;h3 id=&#34;1-markdown是什么&#34;&gt;1. Markdown&lt;em&gt;是什么&lt;/em&gt;？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Markdown&lt;/strong&gt;是一种轻量级&lt;strong&gt;标记语言&lt;/strong&gt;，它以纯文本形式(&lt;em&gt;易读、易写、易更改&lt;/em&gt;)编写文档，并最终以HTML格式发布。&lt;br&gt;
&lt;strong&gt;Markdown&lt;/strong&gt;也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。&lt;/p&gt;
&lt;h3 id=&#34;2-谁创造了它&#34;&gt;2. &lt;em&gt;谁&lt;/em&gt;创造了它？&lt;/h3&gt;
&lt;p&gt;它由&lt;a href=&#34;http://www.aaronsw.com/&#34;&gt;&lt;strong&gt;Aaron Swartz&lt;/strong&gt;&lt;/a&gt;和&lt;strong&gt;John Gruber&lt;/strong&gt;共同设计，&lt;strong&gt;Aaron Swartz&lt;/strong&gt;就是那位于去年（&lt;em&gt;2013年1月11日&lt;/em&gt;）自杀,有着&lt;strong&gt;开挂&lt;/strong&gt;一般人生经历的程序员。维基百科对他的&lt;a href=&#34;http://zh.wikipedia.org/wiki/%E4%BA%9A%E4%BC%A6%C2%B7%E6%96%AF%E6%B2%83%E8%8C%A8&#34;&gt;介绍&lt;/a&gt;是：&lt;strong&gt;软件工程师、作家、政治组织者、互联网活动家、维基百科人&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;他有着足以让你跪拜的人生经历：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;14岁&lt;/strong&gt;参与RSS 1.0规格标准的制订。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2004&lt;/strong&gt;年入读&lt;strong&gt;斯坦福&lt;/strong&gt;，之后退学。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2005&lt;/strong&gt;年创建&lt;a href=&#34;http://infogami.org/&#34;&gt;Infogami&lt;/a&gt;，之后与&lt;a href=&#34;http://www.reddit.com/&#34;&gt;Reddit&lt;/a&gt;合并成为其合伙人。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2010&lt;/strong&gt;年创立求进会（Demand Progress），积极参与禁止网络盗版法案（SOPA）活动，最终该提案被撤回。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2011&lt;/strong&gt;年7月19日，因被控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2013&lt;/strong&gt;年1月自杀身亡。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://github.com/younghz/Markdown/raw/master/resource/Aaron_Swartz.jpg&#34; alt=&#34;Aaron Swartz&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;天才都有早逝的归途。&lt;/p&gt;
&lt;h3 id=&#34;3-为什么要使用它&#34;&gt;3. &lt;em&gt;为什么&lt;/em&gt;要使用它？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;它是易读（看起来舒服）、易写（语法简单）、易更改&lt;strong&gt;纯文本&lt;/strong&gt;。处处体现着&lt;strong&gt;极简主义&lt;/strong&gt;的影子。&lt;/li&gt;
&lt;li&gt;兼容HTML，可以转换为HTML格式发布。&lt;/li&gt;
&lt;li&gt;跨平台使用。&lt;/li&gt;
&lt;li&gt;越来越多的网站支持Markdown。&lt;/li&gt;
&lt;li&gt;更方便清晰地组织你的电子邮件。（Markdown-here, Airmail）&lt;/li&gt;
&lt;li&gt;摆脱Word（我不是认真的）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-怎么使用&#34;&gt;4. &lt;em&gt;怎么&lt;/em&gt;使用？&lt;/h3&gt;
&lt;p&gt;如果不算&lt;strong&gt;扩展&lt;/strong&gt;，Markdown的语法绝对&lt;strong&gt;简单&lt;/strong&gt;到让你爱不释手。&lt;/p&gt;
&lt;p&gt;Markdown语法主要分为如下几大部分：&lt;br&gt;
&lt;strong&gt;标题&lt;/strong&gt;，&lt;strong&gt;段落&lt;/strong&gt;，&lt;strong&gt;区块引用&lt;/strong&gt;，&lt;strong&gt;代码区块&lt;/strong&gt;，&lt;strong&gt;强调&lt;/strong&gt;，&lt;strong&gt;列表&lt;/strong&gt;，&lt;strong&gt;分割线&lt;/strong&gt;，&lt;strong&gt;链接&lt;/strong&gt;，&lt;strong&gt;图片&lt;/strong&gt;，&lt;strong&gt;反斜杠 &lt;code&gt;\&lt;/code&gt;&lt;/strong&gt;，&lt;strong&gt;符号&#39;`&#39;&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;41-标题&#34;&gt;4.1 标题&lt;/h4&gt;
&lt;p&gt;两种形式：&lt;br&gt;
1）使用&lt;code&gt;=&lt;/code&gt;和&lt;code&gt;-&lt;/code&gt;标记一级和二级标题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一级标题&lt;br&gt;
&lt;code&gt;=========&lt;/code&gt;&lt;br&gt;
二级标题&lt;br&gt;
&lt;code&gt;---------&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;h1 id=&#34;一级标题&#34;&gt;一级标题&lt;/h1&gt;
&lt;h2 id=&#34;二级标题&#34;&gt;二级标题&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;2）使用&lt;code&gt;#&lt;/code&gt;，可表示1-6级标题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;# 一级标题&lt;br&gt;
## 二级标题&lt;br&gt;
### 三级标题&lt;br&gt;
#### 四级标题&lt;br&gt;
##### 五级标题&lt;br&gt;
###### 六级标题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;h1 id=&#34;一级标题-2&#34;&gt;一级标题&lt;/h1&gt;
&lt;h2 id=&#34;二级标题-2&#34;&gt;二级标题&lt;/h2&gt;
&lt;h3 id=&#34;三级标题&#34;&gt;三级标题&lt;/h3&gt;
&lt;h4 id=&#34;四级标题&#34;&gt;四级标题&lt;/h4&gt;
&lt;h5 id=&#34;五级标题&#34;&gt;五级标题&lt;/h5&gt;
&lt;h6 id=&#34;六级标题&#34;&gt;六级标题&lt;/h6&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;42-段落&#34;&gt;4.2 段落&lt;/h4&gt;
&lt;p&gt;段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用&lt;strong&gt;两个以上&lt;/strong&gt;空格加上回车（引用中换行省略回车）。&lt;/p&gt;
&lt;h4 id=&#34;43-区块引用&#34;&gt;4.3 区块引用&lt;/h4&gt;
&lt;p&gt;在段落的每行或者只在第一行使用符号&lt;code&gt;&amp;gt;&lt;/code&gt;,还可使用多个嵌套引用，如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;gt; 区块引用&lt;br&gt;
&amp;gt;&amp;gt; 嵌套引用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;区块引用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;嵌套引用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;44-代码区块&#34;&gt;4.4 代码区块&lt;/h4&gt;
&lt;p&gt;代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如&lt;br&gt;
普通段落：&lt;/p&gt;
&lt;p&gt;void main()&lt;br&gt;
{&lt;br&gt;
printf(&amp;quot;Hello, Markdown.&amp;quot;);&lt;br&gt;
}&lt;/p&gt;
&lt;p&gt;代码区块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void main()
{
    printf(&amp;quot;Hello, Markdown.&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:需要和普通段落之间存在空行。&lt;/p&gt;
&lt;h4 id=&#34;45-强调&#34;&gt;4.5 强调&lt;/h4&gt;
&lt;p&gt;在强调内容两侧分别加上&lt;code&gt;*&lt;/code&gt;或者&lt;code&gt;_&lt;/code&gt;，如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;*斜体*，_斜体_&lt;br&gt;
**粗体**，__粗体__&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;斜体&lt;/em&gt;，&lt;em&gt;斜体&lt;/em&gt;&lt;br&gt;
&lt;strong&gt;粗体&lt;/strong&gt;，&lt;strong&gt;粗体&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;46-列表&#34;&gt;4.6 列表&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;·&lt;/code&gt;、&lt;code&gt;+&lt;/code&gt;、或&lt;code&gt;-&lt;/code&gt;标记无序列表，如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-（+*） 第一项&lt;br&gt;
-（+*） 第二项&lt;br&gt;
- （+*）第三项&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：标记后面最少有一个_空格_或_制表符_。若不在引用区块中，必须和前方段落之间存在空行。&lt;/p&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;第一项&lt;/li&gt;
&lt;li&gt;第二项&lt;/li&gt;
&lt;li&gt;第三项&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;有序列表的标记方式是将上述的符号换成数字,并辅以&lt;code&gt;.&lt;/code&gt;，如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1 . 第一项&lt;br&gt;
2 . 第二项&lt;br&gt;
3 . 第三项&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;第一项&lt;/li&gt;
&lt;li&gt;第二项&lt;/li&gt;
&lt;li&gt;第三项&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;47-分割线&#34;&gt;4.7 分割线&lt;/h4&gt;
&lt;p&gt;分割线最常使用就是三个或以上&lt;code&gt;*&lt;/code&gt;，还可以使用&lt;code&gt;-&lt;/code&gt;和&lt;code&gt;_&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;48-链接&#34;&gt;4.8 链接&lt;/h4&gt;
&lt;p&gt;链接可以由两种形式生成：&lt;strong&gt;行内式&lt;/strong&gt;和&lt;strong&gt;参考式&lt;/strong&gt;。&lt;br&gt;
&lt;strong&gt;行内式&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[younghz的Markdown库](https:😕/github.com/younghz/Markdown &amp;quot;Markdown&amp;quot;)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https:://github.com/younghz/Markdown&#34; title=&#34;Markdown&#34;&gt;younghz的Markdown库&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;参考式&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[younghz的Markdown库1][1]&lt;br&gt;
[younghz的Markdown库2][2]&lt;br&gt;
[1]:https:😕/github.com/younghz/Markdown &amp;quot;Markdown&amp;quot;&lt;br&gt;
[2]:https:😕/github.com/younghz/Markdown &amp;quot;Markdown&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https:://github.com/younghz/Markdown&#34; title=&#34;Markdown&#34;&gt;younghz的Markdown库1&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https:://github.com/younghz/Markdown&#34; title=&#34;Markdown&#34;&gt;younghz的Markdown库2&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：上述的&lt;code&gt;[1]:https:://github.com/younghz/Markdown &amp;quot;Markdown&amp;quot;&lt;/code&gt;不出现在区块中。&lt;/p&gt;
&lt;h4 id=&#34;49-图片&#34;&gt;4.9 图片&lt;/h4&gt;
&lt;p&gt;添加图片的形式和链接相似，只需在链接的基础上前方加一个&lt;code&gt;！&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;410-反斜杠&#34;&gt;4.10 反斜杠&lt;code&gt;\&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;相当于&lt;strong&gt;反转义&lt;/strong&gt;作用。使符号成为普通符号。&lt;/p&gt;
&lt;h4 id=&#34;411-符号&#34;&gt;4.11 符号&#39;`&#39;&lt;/h4&gt;
&lt;p&gt;起到标记作用。如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;`ctrl+a`&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;ctrl+a&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;5-谁在用&#34;&gt;5. &lt;em&gt;谁&lt;/em&gt;在用？&lt;/h4&gt;
&lt;p&gt;Markdown的使用者：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GitHub&lt;/li&gt;
&lt;li&gt;简书&lt;/li&gt;
&lt;li&gt;Stack Overflow&lt;/li&gt;
&lt;li&gt;Apollo&lt;/li&gt;
&lt;li&gt;Moodle&lt;/li&gt;
&lt;li&gt;Reddit&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;6-尝试一下&#34;&gt;6. 尝试一下&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Chrome&lt;/strong&gt;下的插件诸如&lt;code&gt;stackedit&lt;/code&gt;与&lt;code&gt;markdown-here&lt;/code&gt;等非常方便，也不用担心平台受限。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在线&lt;/strong&gt;的dillinger.io评价也不错&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Windowns&lt;/strong&gt;下的MarkdownPad也用过，不过免费版的体验不是很好。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mac&lt;/strong&gt;下的Mou是国人贡献的，口碑很好。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Linux&lt;/strong&gt;下的ReText不错。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;当然，最终境界永远都是笔下是语法，心中格式化 😃。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。&lt;br&gt;
虽然有人想出面搞一个所谓的标准化的Markdown，[没想到还惹怒了健在的创始人John Gruber]&lt;br&gt;
(http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/ )。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;以上基本是所有traditonal markdown的语法。&lt;/p&gt;
&lt;h3 id=&#34;其它&#34;&gt;其它：&lt;/h3&gt;
&lt;p&gt;列表的使用(非traditonal markdown)：&lt;/p&gt;
&lt;p&gt;用&lt;code&gt;|&lt;/code&gt;表示表格纵向边界，表头和表内容用&lt;code&gt;-&lt;/code&gt;隔开，并可用&lt;code&gt;:&lt;/code&gt;进行对齐设置，两边都有&lt;code&gt;:&lt;/code&gt;则表示居中，若不加&lt;code&gt;:&lt;/code&gt;则默认左对齐。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;代码库&lt;/th&gt;
&lt;th&gt;链接&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;MarkDown&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/younghz/Markdown&#34; title=&#34;Markdown&#34;&gt;https://github.com/younghz/Markdown&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;MarkDownCopy&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/younghz/Markdown&#34; title=&#34;Markdown&#34;&gt;https://github.com/younghz/Markdown&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;关于其它扩展语法可参见具体工具的使用说明。&lt;/p&gt;
">Markdown 基本语法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://imcm.xyz/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h3&gt;
&lt;h4 id=&#34;使用gridea部署在云上的小站-记录下生活小事&#34;&gt;使用&lt;a href=&#34;https://gridea.dev&#34;&gt;Gridea&lt;/a&gt;部署在云上的小站。记录下生活小事！&lt;/h4&gt;
&lt;h3 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h3&gt;
&lt;h4 id=&#34;无名一个小小的coder&#34;&gt;无名一个小小的Coder&lt;/h4&gt;
&lt;h3 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h3&gt;
&lt;h4 id=&#34;linux算吗&#34;&gt;Linux算吗？&lt;/h4&gt;
&lt;h3 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h3&gt;
&lt;h4 id=&#34;github菜鸟一个就不分享了&#34;&gt;Github：菜鸟一个就不分享了&lt;/h4&gt;
&lt;h4 id=&#34;qq就不告诉你&#34;&gt;QQ：就不告诉你&lt;/h4&gt;
">关于</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="https://cdn.jsdelivr.net/gh/firstisan/firstisan.github.io@master/media/js/motion.js"></script>


<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>





</html>