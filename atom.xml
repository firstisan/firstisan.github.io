<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://imcm.xyz</id>
    <title>IMCM</title>
    <updated>2020-06-29T07:41:57.773Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://imcm.xyz"/>
    <link rel="self" href="https://imcm.xyz/atom.xml"/>
    <subtitle>摒弃世俗浮躁，追求技术精湛</subtitle>
    <logo>https://imcm.xyz/images/avatar.png</logo>
    <icon>https://imcm.xyz/favicon.ico</icon>
    <rights>All rights reserved 2020, IMCM</rights>
    <entry>
        <title type="html"><![CDATA[Laravel Admin 自定义 JavaScript 的正确方式？]]></title>
        <id>https://imcm.xyz/laravel-admin-pjax/</id>
        <link href="https://imcm.xyz/laravel-admin-pjax/">
        </link>
        <updated>2020-06-29T12:47:29.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://laravel-admin.org/">Laravel Admin</a> 使用的是 Pjax ，所以自定义 JS 时候需要按照 Pjax 的事件周期来。</p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://laravel-admin.org/">Laravel Admin</a> 使用的是 Pjax ，所以自定义 JS 时候需要按照 Pjax 的事件周期来。</p>
<!-- more -->
<p>Pjax 事件请见 <a href="https://github.com/defunkt/jquery-pjax#usage">jquery-pjax</a></p>
<h3 id="第一步">第一步</h3>
<p>加载 JS 文件</p>
<p>app/Admin/bootstrap.php</p>
<pre><code class="language-PHP">Admin::js('/js/admin-extended.js');
</code></pre>
<h3 id="第二步">第二步</h3>
<p>public/js/admin-extended.js</p>
<pre><code class="language-PHP">(function($){
    var AdminExtended = {
        init: function(){
            var self = this;

            // Pjax 所有事件请见：https://github.com/defunkt/jquery-pjax#usage

            $(document).on('pjax:start', function() {

            });

            //  after replacing content
            $(document).on('pjax:end', function() {

                // Pjax 模式里页面加载成功后的初始化
                self.siteBootUp();
            });

            // always fires after ajax, regardless of result
            $(document).on('pjax:complete', function() {

            });


            // 正常页面加载成功后的初始化
            self.siteBootUp();
        },

        siteBootUp: function(){
            var self = this;

            self.replaceEnglish();
        },

        replaceEnglish: function(){
            // 创建页面
            $('.file-drop-zone-title').text(&quot;拖动文件到此上传...&quot;);

            // 左边搜索框
            $('.sidebar-form .input-group input.form-control.autocomplete').attr(&quot;placeholder&quot;, '搜索...');
        },

    };
    window.AdminExtended = AdminExtended;
})(jQuery);

$(document).ready(function()
{
    AdminExtended.init();
});
</code></pre>
<p>本文转自： <a href="https://learnku.com/articles/42041">learnku.com</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[搭建Vue脚手架以及创建项目]]></title>
        <id>https://imcm.xyz/vue-introduction/</id>
        <link href="https://imcm.xyz/vue-introduction/">
        </link>
        <updated>2020-06-28T10:36:55.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="知识背景">知识背景</h3>
]]></summary>
        <content type="html"><![CDATA[<h3 id="知识背景">知识背景</h3>
<!-- more -->
<blockquote>
<p>什么是node.js</p>
</blockquote>
<p>nodo.js式基于chrome v8的js运行环境<br>
使js可以当作一门后端语言<br>
特征：基于事件驱动，非阻塞式IO模型<br>
知乎上解释的很好：https://www.zhihu.com/question/33578075</p>
<blockquote>
<p>什么是npm</p>
</blockquote>
<p>npm 全称【node package management】是node.js内置的软件包管理器<br>
说明：https://www.jianshu.com/p/c36666b306aa</p>
<blockquote>
<p>什么是webpack</p>
</blockquote>
<p>webpack是一个开源前端打包工具，Webpack 提供了前端开发缺乏的模块化开发方式，将各种静态资源视为模块，并从它生成优化过的代码。要使用Webpack 前须先安装Node.js。</p>
<blockquote>
<p>与Vue之间的关系</p>
</blockquote>
<p>我们通过vue.js开发项目通常使用npm做包管理器，npm运行依赖node.js；<br>
构建一个vue项目的时候，推荐使用npm，这时候我们需要安装node.js。<br>
一些说明：<br>
https://www.cnblogs.com/jianxian/p/10734204.html<br>
https://www.jianshu.com/p/9967c253da5b<br>
https://www.cnblogs.com/Py-king/p/11669976.html</p>
<h3 id="部署环境">部署环境</h3>
<ol>
<li>
<p>安装 node.js<br>
官网安装：https://nodejs.org/en/download/<br>
windoes zip版安装过程：https://www.cnblogs.com/lxg0/p/9472851.html<br>
本次安装以mac 10.15.4为例，win下去掉命令前的“sudo”</p>
</li>
<li>
<p>查看版本<br>
打开终端分别输入</p>
</li>
</ol>
<pre><code class="language-shell">//查看node版本
node -v
//查看npm版本
npm -v
</code></pre>
<ol start="3">
<li>安装淘宝镜像（可选）</li>
</ol>
<p>因为大天朝的网络环境，国内可能连接不到，建议安装一下淘宝镜像。<br>
--verbose 打印详细信息</p>
<pre><code class="language-shell">sudo npm install -g cnpm --registry=https://registry.npm.taobao.org --verbose
</code></pre>
<ol start="4">
<li>安装webpack<br>
“-g”全局安装</li>
</ol>
<pre><code class="language-shell">//安装（官方镜像）
sudo npm install webpack webpack-cli -g
//安装（淘宝镜像）
sudo cnpm install webpack webpack-cli -g
//查看版本
webpack -v
</code></pre>
<ol start="5">
<li>安装vue-cli</li>
</ol>
<pre><code class="language-shell">//安装（官方镜像）
sudo npm install -g vue-cli
//安装（淘宝镜像）
sudo cnpm install -g vue-cli
//查看版本
//注意这里是大写的“V”
vue -V
</code></pre>
<h3 id="创建项目">创建项目</h3>
<ol>
<li>
<p>项目位置<br>
打开cmd cd到硬盘的某个路径，这个路径就是接下来项目的存放路径。</p>
</li>
<li>
<p>创建</p>
</li>
</ol>
<pre><code class="language-shell">vue init webpack demo（项目名，小写）
Project name（项目名：默认“demo”）
Project description （项目介绍：默认 A Vue.js project）
Author （作者名）
Vue build （Use arrow keys）
Runtime + Compiler：recommended for most users（运行加编译）
Runtime—only：about 6KB lighter min+gzip，but templaters（or any Vue-spcific HTML）are ONLY allowed in .Vue files - render functions are required elsewhere（仅运行）
Install vue-router ? （Y/n）（安装Vue路由？）
Use ESLint to lint your code ? （Y/n）（使用ESlint对代码进行校验？）
Set up unit tests （Y/n）（使用单元测试？）
Setup e2e tests with Nightwatch？ （Y/n）（使用e2e测试？）
Should we run npm install fr you after the project has been created?（recommended）（Use arrow keys）
Yes，use Npm
Yes，use Yarn
No，I whill handle that myself
如果npm可以正常使用，选第一项
如果使用淘宝镜像选最后一个
根据提示
cd demo
cnpm install （or if using yarn ：yarn）
npm run dev
</code></pre>
<h3 id="项目文件解释">项目文件解释</h3>
<ul>
<li>build（webpack 编译任务配置文件: 开发环境与生产环境）</li>
<li>config（项目的配置文件）</li>
<li>config&gt;index.js（项目的基础的配置信息）</li>
<li>config&gt;dev.env.js（开发环境的配置信息）</li>
<li>config&gt;pro.env.js（线上环境的配置信息）</li>
<li>node_modules（项目所有依赖的包文件，比如vue-router、vuex等插件都会下载到这个文件夹里面）</li>
<li>src（工作目录，主要写代码的地方）</li>
<li>static（静态资源）</li>
<li>.babelrc（语法解析器）</li>
<li>.editorconfig（帮助配置编辑器 里 自动化 的语法）</li>
<li>.gitignore（用来过滤一些版本控制的文件，比如node_modules文件夹）</li>
<li>.postcssrc.js（是对postcss的一个配置项）</li>
<li>index.html（入口文件）</li>
<li>package.json（项目文件，记载着一些命令和依赖还有简要的项目描述信息）</li>
<li>package-lock.json（package的锁文件，可以帮助确定安装第三包的具体版本，保持编程团队的统一）</li>
<li>README.md（项目说明介绍）</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis 基础学习]]></title>
        <id>https://imcm.xyz/redis-basic/</id>
        <link href="https://imcm.xyz/redis-basic/">
        </link>
        <updated>2020-06-26T03:27:42.000Z</updated>
        <summary type="html"><![CDATA[<p>redis 基础知识巩固一下</p>
]]></summary>
        <content type="html"><![CDATA[<p>redis 基础知识巩固一下</p>
<!-- more -->
<h3 id="启动">启动</h3>
<ol>
<li>启动：redis-server.exe redis.windows.conf/redis-server</li>
<li>连接：redis-cli.exe -h 127.0.0.1 -p 6379</li>
</ol>
<h3 id="redis-命令">redis 命令</h3>
<ol>
<li>启动客户端后利用 redis-cli 连接本地服务</li>
<li>ping 检测 redis 服务是否启动</li>
<li>执行远程 redis 服务：redis-cli -h host -p port -a password</li>
</ol>
<h3 id="数据类型">数据类型</h3>
<ul>
<li>
<p>string （字符串）</p>
</li>
<li>
<p>hash （哈希）</p>
<ul>
<li>key：value （键值对集合），适合存储对象</li>
</ul>
</li>
<li>
<p>list （列表）</p>
<ul>
<li>简单的字符串列表，可以添加元素到列表的头部和尾部</li>
</ul>
</li>
<li>
<p>set （集合）</p>
<ul>
<li>string 类型的无序集合</li>
<li>集合是通过哈希表实现的</li>
</ul>
</li>
<li>
<p>zset （有序集合）</p>
<ul>
<li>zset 和 set 一样也是 string 类型元素的集合，且不允许重复的成员</li>
<li>不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序</li>
<li>zset 的成员是唯一的，但分数 (score) 却可以重复</li>
</ul>
</li>
</ul>
<h3 id="操作指南">操作指南</h3>
<ul>
<li>key 操作</li>
</ul>
<pre><code class="language-shell">-- SET KEY_NAME VALUE（设置给定 key 的值。如果 key 已经存储其他值， SET 就覆写旧值，且无视类型）
&gt; set name Lhao

-- GET KEY_NAME （获取指定 key 的值。如果 key 不存在，返回 nil 。如果key 储存的值不是字符串类型，返回一   个错误）
&gt; get name // 输出：Lhao

-- DUMP KEY_NAME （序列化 name，输出序列化之后的值）
&gt; dump name // 输出：&quot;\x00\x04Lhao\t\x00\xd3JL\xcf\xafsi\x8f&quot;

-- EXISTS KEY_NAME （判断 key 是否存在）
&gt; exists name // 输出：1

-- Expire KEY_NAME TIME_IN_SECONDS (设置有效时间，过期之后则删除，单位：s , 可对已存在的 key 进行操作)
&gt; expire name 10 // 输出：1

-- Expireat KEY_NAME TIME_IN_UNIX_TIMESTAMP (指定过期时间戳)
&gt; set name Lhao // 上面设置了过期时间，已经没了 ，哈哈
&gt; expireat name 1551341040 // 输出：1

-- KEYS PATTERN (用于查找所有符合给定模式 pattern 的 key )
&gt; set name Lhao
&gt; keys * //（返回所有键名）输出：name
&gt; set naes haha
&gt; keys na* // 输出：name、naes

-- SELECT index (切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值)
&gt; select 0 

-- MOVE KEY_NAME DESTINATION_DATABASE (将当前数据库的 key 移动到给定的数据库 db 当)
&gt; move name 1 // (移动 name 到 1 数据库中)
&gt; exists name // 输出：0
&gt; select 1
&gt; exists name // 输出：1

&gt; expire name 10

-- TTL KEY_NAME (以秒为单位返回 key 的剩余过期时间)
&gt; ttl name // 输出：8

-- PERSIST KEY_NAME (移除给定 key 的过期时间，使得 key 永不过期)
&gt; persist name // 输出：1
&gt; ttl name // 输出：-1 （表示不过期）

-- DEL KEY_NAME (删除已存在的键。不存在的 key 会被忽略)
&gt; del name // 输出：1

&gt; set name Lhao
&gt; set age 24

-- RANDOMKEY (从当前数据库中随机返回一个 key)
&gt; randomkey // 输出：age

-- FLUSHDB (清空当前数据库中的所有 key)
&gt; flushdb

&gt; set name Lhao

-- RENAME OLD_KEY_NAME NEW_KEY_NAME (修改 key 的名称)
&gt; rename name newname
&gt; get name // 输出：nli (不存在)
&gt; set namecopy wjh
&gt; rename newname namecopy
&gt; get namecopy // 输出：Lhao

&gt; set name Lhao

-- RENAMENX OLD_KEY_NAME NEW_KEY_NAME (用于在新的 key 不存在时修改 key 的名称)
&gt; renamenx namecopy name // 输出：0 (此时修改 key 名不成功)

-- TYPE KEY_NAME (返回 key 所储存的值的类型)
&gt; type name // 输出：string
</code></pre>
<h3 id="字符串-操作">字符串 操作</h3>
<blockquote>
<p><a href="https://www.zhihu.com/question/27672245">知乎：setbit\getbit 用法</a></p>
</blockquote>
<pre><code class="language-shell">&gt; flushdb

&gt; set title &quot;my name is Lhao&quot;
&gt; get title // 输出：my name is Lhao

-- GETRANGE KEY_NAME start end （用于获取存储在指定 key 中字符串的子字符串。字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)）
&gt; getrange title 0 4 // 输出：my na

-- GETSET KEY_NAME VALUE (用于设置指定 key 的值，并返回 key 的旧值)
&gt; getset title &quot;new title&quot; // 输出：my name is Lhao
&gt; get title // 输出：new title

-- MGET KEY1 KEY2 .. KEYN (返回所有(一个或多个)给定 key 的值。 如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil )
&gt; mget title name 
// 输出：
 1) (nil)
 2) &quot;new title&quot;

-- SETEX KEY_NAME TIMEOUT VALUE (为指定的 key 设置值及其过期时间。如果 key 已经存在， SETEX 命令将会替换旧的值)
&gt; setex name 60 liuhao

&gt; del name

-- SETNX KEY_NAME VALUE（SET if Not eXists） 命令在指定的 key 不存在时，为 key 设置指定的值
&gt; setnx name Lhao // 输出：1
&gt; setnx title Lhao // 输出：0

-- SETRANGE KEY_NAME OFFSET VALUE （用指定的字符串覆盖给定 key 所储存的字符串值，覆盖的位置从偏移量 offset 开始）
&gt; setrange name 3 Lhao // 输出：7
&gt; get name // 输出：LhaLhao

-- STRLEN KEY_NAME (用于获取指定 key 所储存的字符串值的长度。当 key 储存的不是字符串值时，返回一个错误)
&gt; strlen name // 输出：7

-- 用于同时设置一个或多个 key-value 对 (MSET key1 value1 key2 value2 .. keyN valueN )
&gt; mset name Lhao age 24 // 输出：ok
&gt; mget name age 
// 输出：
 1) &quot;Lhao&quot;
 2) &quot;24&quot;

-- MSETNX key1 value1 key2 value2 .. keyN valueN （用于所有给定 key 都不存在时，同时设置一个或多个 key-value 对）
&gt; msetnx name Lhao age 24 // 输出：0
&gt; msetnx name Lhao25 sex men //输出：0
&gt; get sex // 输出：nli

-- INCR KEY_NAME 
// 将 key 中储存的数字值增一。
// 如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。
// 如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。
// 本操作的值限制在 64 位(bit)有符号数字表示之内。
&gt; incr name // 输出：(error) ERR value is not an integer or out of range
&gt; incr money // 输出：1

-- DECRBY KEY_NAME DECREMENT_AMOUNT (将 key 中储存的数字加上指定的增量值)
&gt; incrby money 80 // 输出：81

-- DECR KEY_NAME （将 key 中储存的数字值减一）
&gt; decr money // 输出：80

-- DECRBY KEY_NAME DECREMENT_AMOUNT （将 key 所储存的值减去指定的减量值）
&gt; decrby money 10 // 输出：70

-- APPEND KEY_NAME NEW_VALUE
// 为指定的 key 追加值。
// 如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。
// 如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样。
&gt; append name &quot; love&quot; //  输出：8
&gt; get name // 输出：Lhaolove
</code></pre>
<h3 id="哈希-操作">哈希 操作</h3>
<pre><code class="language-shell">&gt; flushdb

-- HSET KEY_NAME FIELD VALUE (用于为哈希表中的字段赋值;如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作;如果字段已经存在于哈希表中，旧值将被覆盖)
&gt; hset user name Lhao // 输出：1

-- HGET KEY_NAME FIELD_NAME (用于返回哈希表中指定字段的值)
&gt; hget user name // 输出：Lhao

&gt; hset user name wjh // 输出：0
&gt; hget user name // 输出：wjh

-- HMSET KEY_NAME FIELD1 VALUE1 ...FIELDN VALUEN (用于同时将多个 field-value (字段-值)对设置到哈希表中)
&gt; hmset user name Lhao age 24 // 输出：ok
&gt; hmget user name age
// 输出：
 1) &quot;Lhao&quot;
 2) &quot;24&quot;

-- HDEL KEY_NAME FIELD1.. FIELDN（用于删除哈希表 key 中的一个或多个指定字段，不存在的字段将被忽略）
&gt; hdel user name // 输出：1

-- HEXISTS KEY_NAME FIELD_NAME (用于查看哈希表的指定字段是否存在)
&gt; hexists user name // 输出：0

-- HGETALL KEY_NAME (用于返回哈希表中，所有的字段和值;在返回值里，紧跟每个字段名(field name)之后是字段的值(value)，所以返回值的长度是哈希表大小的两倍)
&gt; hgetall user
// 输出：
 1) &quot;age&quot;
 2) &quot;24&quot;

-- HINCRBY KEY_NAME FIELD_NAME INCR_BY_NUMBER（用于为哈希表中的字段值加上指定增量值）
&gt; hincrby user age 1 // 输出：25

-- HKEYS key (用于获取哈希表中的所有域（field）)
&gt; hkeys user
// 输出：
1) &quot;age&quot;

-- HLEN KEY_NAME （用于获取哈希表中字段的数量）
&gt; hlen user //  输出：1

-- HSETNX KEY_NAME FIELD VALUE（用于为哈希表中不存在的的字段赋值）
&gt; hsetnx user name hao // 输出：1
&gt; hsetnx user age 24 // 输出：0

-- HVALS KEY_NAME FIELD VALUE（返回哈希表所有域(field)的值）
&gt; hvals user 
// 输出：
1) &quot;25&quot;
2) &quot;Lhao&quot;
</code></pre>
<h3 id="列表-操作">列表 操作</h3>
<pre><code class="language-shell">&gt; flushdb

-- LPUSH KEY_NAME VALUE1.. VALUEN （将一个或多个值插入到列表头部。 如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。 当 key 存在但不是列表类型时，返回一个错误。）
&gt; lpush users Lhao wjh // 输出：2

-- LRANGE KEY_NAME START END (返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推)
&gt; lrange users 0 0 // 输出：wjh
&gt; lrange users 0 -1 // 输出：wjh、Lhao 

-- BLPOP LIST1 LIST2 .. LISTN TIMEOUT （移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止）
&gt; blpop users 10 
// 输出：
1) &quot;users&quot;
2) &quot;wjh&quot;
&gt; lrange users 0 -1 // 输出：Lhao

-- BRPOPLPUSH LIST1 ANOTHER_LIST TIMEOUT （从列表中弹出第一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。）
&gt; brpoplpush users users_two 10 // 输出：Lhao
&gt; lrange users 0 -1 // 输出：(empty list or set)
&gt; lrange users_two 0 -1 // 输出：Lhao

&gt; lpush users wjh Lhao

-- LINDEX KEY_NAME INDEX_POSITION (用于通过索引获取列表中的元素。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。)
&gt; lindex users 0 // 输出：lhao
&gt; lindex users -1 // 输出：wjh

&gt; del users

-- RPUSH KEY_NAME VALUE1..VALUEN (用于将一个或多个值插入到列表的尾部(最右边);如果列表不存在，一个空列表会被创建并执行 RPUSH 操作。 当列表存在但不是列表类型时，返回一个错误)
&gt; rpush users Lhao wjh
&gt; lrange 0 -1 // 输出：Lhao wjh

-- LINSERT key BEFORE|AFTER pivot value (用于在列表的元素前或者后插入元素。当指定元素不存在于列表中时，不执行任何操作;当列表不存在时，被视为空列表，不执行任何操作;如果 key 不是列表类型，返回一个错误)
&gt; linsert users before wjh love // 输出：3
&gt; lrange 0 -1 // 输出：Lhao love wjh

-- LLEN KEY_NAME (用于返回列表的长度。 如果列表 key 不存在，则 key 被解释为一个空列表，返回 0 。 如果 key 不是列表类型，返回一个错误)
&gt; llen users // 输出：3

-- Lpop KEY_NAME (用于移除并返回列表的第一个元素)
&gt; lpop users // 输出：Lhao
&gt; lrange users 0 -1 // 输出：love wjh

-- LPUSHX KEY_NAME VALUE1.. VALUEN (将一个值插入到已存在的列表头部，列表不存在时操作无效)
&gt; lpushx users Lhao // 输出：3
&gt; lrange users 0 -1 // 输出：Lhao love wjh
&gt; lpushx user you // 输出：0
&gt; lpush users Lhao Lhao // 输出：5
&gt; lrange users 0 -1 // 输出：Lhao Lhao Lhao love wjh

-- LREM KEY_NAME COUNT VALUE
// 根据参数 COUNT 的值，移除列表中与参数 VALUE 相等的元素
// count &gt; 0 : 从表头开始向表尾搜索，移除与 VALUE 相等的元素，数量为 COUNT 。
// count &lt; 0 : 从表尾开始向表头搜索，移除与 VALUE 相等的元素，数量为 COUNT 的绝对值。
// count = 0 : 移除表中所有与 VALUE 相等的值。

&gt; lrem users 2 Lhao // 输出：2
&gt; lrange users 0 -1 // 输出：Lhao love wjh 

-- LSET KEY_NAME INDEX VALUE (通过索引来设置元素的值;当索引参数超出范围，或对一个空列表进行 LSET 时，返回一个错误)
&gt; lset users 0 liuhao // 输出：ok
&gt; lrange users 0 -1 // 输出：liuhao love wjh

&gt; lpush fruit apple cherry strawbrerry

-- LTRIM KEY_NAME START STOP (对一个列表进行修剪(trim)，就是说，让列表只保留指定 区间内的元素，不在指定区间之内的元素都将被删除;下标 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。)
&gt; ltrim fruit 1 -1 // 输出：ok
&gt; lrange fruit 0 -1 // 输出：cherry apple

-- RPOP KEY_NAME （用于移除列表的最后一个元素，返回值为移除的元素）
&gt; rpop fruit // 输出：apple
&gt; lrange fruit 0 -1 // 输出：cherry

&gt; lpush fruit apple cherry // 输出：3

-- RPOPLPUSH SOURCE_KEY_NAME DESTINATION_KEY_NAME （用于移除列表的最后一个元素，并将该元素添加到另一个列表并返回）
&gt; rpoplpush fruit users // 输出：cherry
&gt; lrange users 0 -1 // 输出：cherry、apple
</code></pre>
<h3 id="集合-操作">集合 操作</h3>
<pre><code class="language-shell">&gt; flushdb

-- SADD KEY_NAME VALUE1..VALUEN（将一个或多个成员元素加入到集合中，已经存在于集合的成员元素将被忽略；假如集合 key 不存在，则创建一个只包含添加的元素作成员的集合；当集合 key 不是集合类型时，返回一个错误。）
&gt; sadd users wjh Lhao // 输出：2
&gt; sadd users wjh // 输出：0 

-- SMEMBERS key （返回集合中的所有的成员。 不存在的集合 key 被视为空集合）
&gt; smembers users // 输出：wjh Lhao

-- SCARD KEY_NAME (返回集合中元素的数量)
&gt; scard users // 输出：2 

&gt; sadd usersTwo abing laoxia 
&gt; smembers usersTwo // 输出：abing laoxia

-- SDIFF FIRST_KEY OTHER_KEY1..OTHER_KEYN (返回给定集合之间的差集。不存在的集合 key 将视为空集；差集的结果来自前面的 FIRST_KEY ,而不是后面的 OTHER_KEY1，也不是整个 FIRST_KEY OTHER_KEY1..OTHER_KEYN 的差集)
&gt; sdiff users usersTwo // 输出：wjh Lhao
&gt; sadd usersTwo Lhao
&gt; sdiff users usersTwo // 输出：wjh

-- SDIFFSTORE DESTINATION_KEY KEY1..KEYN (将给定集合之间的差集存储在指定的集合中。如果指定的集合 key 已存在，则会被覆盖)
&gt; sdiffstore usersThree users usersTwo // 输出：1
&gt; smembers usersThree // 输出：wjh

&gt; del users usersTwo usersThree

&gt; sadd users wjh Lhao
&gt; sadd usersTwo Lhao abing laoxia

-- SINTER KEY KEY1..KEYN (返回给定所有给定集合的交集。 不存在的集合 key 被视为空集。 当给定集合当中有一个空集时，结果也为空集(根据集合运算定律))
&gt; sinter users usersTwo // 输出：Lhao

-- SINTERSTORE DESTINATION_KEY KEY KEY1..KEYN (将给定集合之间的交集存储在指定的集合中。如果指定的集合已经存在，则将其覆盖)
&gt; sinterstore usersThree users usersTwo 
&gt; smembers usersThree // 输出：Lhao

-- SISMEMBER KEY VALUE (判断成员元素是否是集合的成员)
&gt; sismember users Lhao // 输出：1

&gt; sadd fruits apple cherry
&gt; sadd fruitsTwo strawbrerry

-- SMOVE SOURCE DESTINATION MEMBER
// 将指定成员 member 元素从 source 集合移动到 destination 集合。
// SMOVE 是原子性操作。
// 如果 source 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去。
// 当 destination 集合已经包含 member 元素时， SMOVE 命令只是简单地将 source 集合中的 member 元素删除。
// 当 source 或 destination 不是集合类型时，返回一个错误。
&gt; smove fruitsTwo fruits strawbrerry  // 输出：1
&gt; smembers fruits // 输出：cherry、apple、strawbrerry

-- SPOP key [count] (移除集合中的指定 key 的一个或多个随机元素，移除后会返回移除的元素)
&gt; spop fruits // 输出：cherry
&gt; smembers druits // 输出：strawbrerry、apple

-- SRANDMEMBER KEY [count] （返回集合中一个或多个随机数）
&gt; srandmember fruit // 输出：apple 

-- SREM KEY MEMBER1..MEMBERN （移除集合中的一个或多个成员元素，不存在的成员元素会被忽略）
&gt; srem fruits apple // 输出：1
&gt; smembers fruits // 输出：strawbrerry

-- SUNION KEY KEY1..KEYN (返回给定集合的并集。不存在的集合 key 被视为空集)
&gt; flushdb
&gt; sadd fruits apple cherry 
&gt; sadd fruitsTwo apple strawberry
&gt; sunion fruits fruitsTwo // 输出：cherry、strawberry、apple

-- SUNIONSTORE DESTINATION KEY KEY1..KEYN （将给定集合的并集存储在指定的集合 destination 中。如果 destination 已经存在，则将其覆盖）
&gt; sunionstore fruitsThree fruits fruitsTwo
&gt; smembers fruitsThree // 输出：cherry、strawberry、apple

-- SSCAN key cursor [MATCH pattern] [COUNT count] （用于迭代集合中键的元素）
&gt; sscan fruitsThree 0 match a* // (
输出：1) &quot;0&quot;
     2) 1) &quot;apple&quot;
)
</code></pre>
<h4 id="有序集合-操作">有序集合 操作</h4>
<pre><code class="language-shell"> &gt; flushdb

 -- ZADD KEY_NAME SCORE1 VALUE1.. SCOREN VALUEN
    // 用于将一个或多个成员元素及其分数值加入到有序集当中。
    // 如果某个成员已经是有序集的成员，那么更新这个成员的分数值，并通过重新插入这个成员元素，来保证该成员在正确的位置上。
    // 分数值可以是整数值或双精度浮点数。
    // 如果有序集合 key 不存在，则创建一个空的有序集并执行 ZADD 操作。
    // 当 key 存在但不是有序集类型时，返回一个错误。
 &gt; zadd myzset 1 &quot;one&quot; // 输出：1
 &gt; zadd myzset 1 &quot;uno&quot;
 &gt; zadd myzset 2 &quot;two&quot; 3 &quot;three&quot;

 -- ZRANGE key start stop [WITHSCORES]
    // 返回有序集中，指定区间内的成员。
    // 其中成员的位置按分数值递增(从小到大)来排序。
    // 具有相同分数值的成员按字典序(lexicographical order )来排列。
    // 如果你需要成员按值递减(从大到小)来排列，请使用 ZREVRANGE 命令。
    // 下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。
    // 你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推
 &gt; zrange myzset 0 -1 WITHSCORES
 // 输出：
     1) &quot;one&quot;
     2) &quot;1&quot;
     3) &quot;uno&quot;
     4) &quot;1&quot;
     5) &quot;two&quot;
     6) &quot;2&quot;
     7) &quot;three&quot;
     8) &quot;3&quot;

 -- ZCARD KEY_NAME （用于计算集合中元素的数量）
 &gt; zcard myzset // 输出：4

 -- ZCOUNT key min max (用于计算有序集合中指定分数区间的成员数量)
 &gt; zcount myzset 1 3 // 输出：4

 -- ZINCRBY key increment member (对有序集合中指定成员的分数加上增量 increment)
 &gt; zincrby myzset 2 &quot;one&quot; // 输出：3
 &gt; zrange myzset 0 -1 WITHSCORES
 // 输出：
     1) &quot;uno&quot;
     2) &quot;1&quot;
     3) &quot;two&quot;
     4) &quot;2&quot;
     5) &quot;one&quot;
     6) &quot;3&quot;
     7) &quot;three&quot;
     8) &quot;3&quot;

 &gt; zadd mid_test 70 Lhao 70 wjh
 &gt; zadd fin_test 80 Lhao 78 wjh

 -- ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX] （计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。）
 &gt; zinterstore sum_point 2 mid_test fin_test
 &gt; zrange sum_point 0 -1 WITHSCORES
 // 输出：
     1) &quot;wjh&quot;
     2) &quot;148&quot;
     3) &quot;Lhao&quot;
     4) &quot;150&quot;

 -- ZLEXCOUNT KEY MIN MAX （计算有序集合中指定字典区间内成员数量）
 &gt; zadd newzset 0 a 0 b 0 c 0 d 0 e 0 f 0 g
 &gt; zlexcount newzset - + // 输出：7
 &gt; zlexcount newzset [b [f // 输出：5

 -- ZRANGEBYLEX key min max [LIMIT offset count] (通过字典区间返回有序集合的成员)
 &gt; zrangebylex newzset - [c
 // 输出：
     1) &quot;b&quot;
     2) &quot;a&quot;
     3) &quot;c&quot;
 &gt; zrangebylex newzset - (c
  // 输出：
     1) &quot;b&quot;
     2) &quot;a&quot;
 &gt; zrangebylex newzset [aaa (g
  // 输出：
     1) &quot;b&quot;
     2) &quot;a&quot;
     3) &quot;c&quot;
     4) &quot;d&quot;
     5) &quot;e&quot;
     6) &quot;f&quot;

 &gt; zadd salary 2500 jack 5000 tom 12000 peter

 -- ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]
    // 返回有序集合中指定分数区间的成员列表。有序集成员按分数值递增(从小到大)次序排列。
    // 具有相同分数值的成员按字典序来排列(该属性是有序集提供的，不需要额外的计算)。
    // 默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)
 &gt; zrangebyscore salary -inf +inf #显示整个有序集
 // 输出：
     1) &quot;jack&quot;
     2) &quot;tom&quot;
     3) &quot;peter&quot;
 &gt; zrangebyscore salary -inf +inf WITHSCORES # 显示整个有序集及成员的 score 值
 // 输出：
     1) &quot;jack&quot;
     2) &quot;2500&quot;
     3) &quot;tom&quot;
     4) &quot;5000&quot;
     5) &quot;peter&quot;
     6) &quot;12000&quot;
 &gt; zrangebyscore salary -inf 5000 WITHSCORES # 显示工资 &lt;=5000 的所有成员
 // 输出：
     1) &quot;jack&quot;
     2) &quot;2500&quot;
     3) &quot;tom&quot;
     4) &quot;5000&quot;
 &gt; zrangebyscore salary (5000 400000 # 显示工资大于 5000 小于等于 400000 的成员
 // 输出：
    1) &quot;peter&quot;

 -- ZRANK key member （返回有序集中指定成员的排名。其中有序集成员按分数值递增(从小到大)顺序排列）
 &gt; zrank salary tom // 输出：1 （ # tom 的薪水排名，第二）

 -- ZREM key member [member ...] (用于移除有序集中的一个或多个成员，不存在的成员将被忽略;当 key 存在但不是有序集类型时，返回一个错误)
 &gt; zrem salary tom // 输出：1
 &gt; zrangebyscore salary -inf +inf WITHSCORES
 // 输出：
     1) &quot;jack&quot;
     2) &quot;2500&quot;
     3) &quot;peter&quot;
     4) &quot;12000&quot;

 &gt; zadd myzset 0 aaaa 0 b 0 c 0 d 0 e 0 foo 0 zap 0 zip 0 ALPHA 0 alpha

 -- ZREMRANGEBYLEX key min max（用于移除有序集合中给定的字典区间的所有成员）
 &gt; zremrangebylex myzset [alpha [omega // 输出：6
 &gt; zrange myzset 0 -1
 // 输出：
     1) &quot;ALPHA&quot;
     2) &quot;aaaa&quot;
     3) &quot;zap&quot;
     4) &quot;zip&quot;

 &gt; zadd salary 5000 tom

 -- ZREMRANGEBYRANK key start stop（用于移除有序集中，指定排名(rank)区间内的所有成员）
 &gt; zremrangebyrank salary 0 1 // 输出：2
 &gt; zrange salary 0 -1 WITHSCORES 
 // 输出：
     1) &quot;peter&quot;
     2) &quot;12000&quot;

 &gt; zadd salary 2500 jack 5000 tom

 -- ZREMRANGEBYSCORE key min max (用于移除有序集中，指定分数（score）区间内的所有成员)
 &gt; zremrangebyscore salary 1500 3500 // 输出：1
 &gt; zrange salary 0 -1 WITHSCORES
 // 输出：
     1) &quot;tom&quot;
     2) &quot;5000&quot;
     3) &quot;peter&quot;
     4) &quot;12000&quot;

 &gt; zadd salary 2500 jack

 -- ZREVRANGE key start stop [WITHSCORES]（返回有序集中，指定区间内的成员；其中成员的位置按分数值递减(从大到小)来排列。具有相同分数值的成员按字典序的逆序(reverse lexicographical order)排列；除了成员按分数值递减的次序排列这一点外， ZREVRANGE 命令的其他方面和 ZRANGE 命令一样）
 &gt; zrevrange salary 0 -1 WITHSCORES
 // 输出：
     1) &quot;peter&quot;
     2) &quot;12000&quot;
     3) &quot;tom&quot;
     4) &quot;5000&quot;
     5) &quot;jack&quot;
     6) &quot;2500&quot;

 -- ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]（返回有序集中指定分数区间内的所有的成员。有序集成员按分数值递减(从大到小)的次序排列）
 &gt; zrevrangebyscore salary +inf -inf # 逆序排列所有成员
 //输出：
     1) &quot;peter&quot;
     2) &quot;tom&quot;
     3) &quot;jack&quot;
 &gt; zrevrangebyscore salary 10000 200 # 逆序排列薪水介于 10000 和 2000 之间的成员
 // 输出：
     1) &quot;tom&quot;
     2) &quot;jack&quot;

 -- ZREVRANK key member（返回有序集中成员的排名。其中有序集成员按分数值递减(从大到小)排序；排名以 0 为底，也就是说， 分数值最大的成员排名为 0 ；使用 ZRANK 命令可以获得成员按分数值递增(从小到大)排列的排名）
 &gt; zrevrank salary peter // 输出：0
 &gt; zrevrank salary tom // 输出：1

 -- ZSCORE key member (返回有序集中，成员的分数值。 如果成员元素不是有序集 key 的成员，或 key 不存在，返回 nil )
 &gt; zscore salary peter // 输出：12000

 &gt; zadd programmer 2000 peter 3500 jack 5000 tom
 &gt; zadd manager 2000 herry 3500 mary 4000 bob

 -- ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]（计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination；默认情况下，结果集中某个成员的分数值是所有给定集下该成员分数值之和）

 &gt; zunionstore salary 2 programmer manager WEIGHTS 1 3 # # 公司决定加薪。。。除了程序员。。。
 &gt; zrange salary 0 -1 WITHSCORES
 // 输出：
      1) &quot;peter&quot;
      2) &quot;2000&quot;
      3) &quot;jack&quot;
      4) &quot;3500&quot;
      5) &quot;tom&quot;
      6) &quot;5000&quot;
      7) &quot;herry&quot;
      8) &quot;6000&quot;
      9) &quot;mary&quot;
     10) &quot;10500&quot;
     11) &quot;bob&quot;
     12) &quot;12000&quot;
</code></pre>
<h3 id="结束语">结束语</h3>
<p>这里只是简单的对 redis 的各种类型做了一下介绍以及一些操作方法</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用腾讯云实现网易云自动打卡签到]]></title>
        <id>https://imcm.xyz/netmusic-qcloud/</id>
        <link href="https://imcm.xyz/netmusic-qcloud/">
        </link>
        <updated>2020-06-24T07:27:04.000Z</updated>
        <summary type="html"><![CDATA[<p>使用腾讯云云函数实现网易云自动打卡和签到功能！</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用腾讯云云函数实现网易云自动打卡和签到功能！</p>
<!-- more -->
<p>在这篇文章中，我将主要介绍如何使用腾讯云中的云函数来实现网易云自动打卡和签到功能。本文中的 PHP 源代码可以在 <a href="https://github.com/wwxiaoqi/TencentNeteaseCloudPunch">GitHub</a> 上找到。</p>
<p>说明：PHP 里面的 localurl，username，password 需要修改才能正常使用， 在这里提供一些网上公益的 <a href="https://tahicokey.oss-cn-shanghai.aliyuncs.com/Blog/TencentNeteaseCloudPunch/Netease_API.txt">API</a> ，完全性未知，在使用 API 过程中发生的一切事情均与我无关。</p>
<h2 id="正文">正文</h2>
<p>文章的正文分为两个部分：基础集成和原生部署，第一部分是文章的主体，第二部分供喜欢网易云的研究。</p>
<p>当你按照此文章成功设置完成，将：</p>
<ul>
<li>拥有网易云自动打卡</li>
<li>无需手动，完全自动</li>
<li>定时签到</li>
</ul>
<h2 id="基础集成">基础集成</h2>
<p>你需要准备的是：</p>
<ul>
<li>腾讯云账号，且实名验证完成</li>
<li>一个网易云 API</li>
<li>网易云音乐账号密码<br>
首先，先打开 <a href="https://cloud.tencent.com/">腾讯云</a> ，找到 <a href="https://cloud.tencent.com/product/scf">云函数</a> 在新建函数页面填写函数基础信息，单击【下一步】，如下图所示：</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://imcm.xyz/post-images/1592984081483.jpg" alt="1.jpg" loading="lazy"></figure>
<ul>
<li>函数名称：可随便命名</li>
<li>运行环境：选择 “PHP 7.2”</li>
<li>创建方式：选择 “空白函数”</li>
</ul>
<p>接着在函数配置界面中填写其他信息，然后点击【完成】，如下图所示：</p>
<figure data-type="image" tabindex="2"><img src="https://imcm.xyz/post-images/1592984087418.jpg" alt="2.jpg" loading="lazy"></figure>
<p>此处代码修改为本文的 PHP 源代码</p>
<figure data-type="image" tabindex="3"><img src="https://imcm.xyz/post-images/1592984096560.jpg" alt="3.jpg" loading="lazy"></figure>
<p>超时时间修改为 600s</p>
<h2 id="基础触发">基础触发</h2>
<p>接着配置一下触发方式，点击【保存】，如下图所示：</p>
<figure data-type="image" tabindex="4"><img src="https://imcm.xyz/post-images/1592984127329.jpg" alt="4.jpg" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://imcm.xyz/post-images/1592984141422.jpg" alt="5.jpg" loading="lazy"></figure>
<ul>
<li>定时任务名称：可随便命名</li>
<li>触发周期：选择 “自定义触发”</li>
<li>Cron 表达式：填写 “00 30 6 */1 * * *”<br>
<img src="https://imcm.xyz/post-images/1592984152914.jpg" alt="6.jpg" loading="lazy"></li>
</ul>
<p>到此处基础部分就已经完成啦，下面是原生部署方式。</p>
<h2 id="原生部署">原生部署</h2>
<p>你需要准备的是：</p>
<ul>
<li>一台支持 Node.js 的服务器</li>
<li>API 源代码：<a href="https://github.com/Binaryify/NeteaseCloudMusicApi">NeteaseCloudMusicApi</a></li>
<li>会简单 Linux 基础<br>
首先，先连接 Linux 并安装 Git，nodejs：</li>
</ul>
<pre><code class="language-shell">pkg install git
pkg install nodejs
pkg install nodejs-current
</code></pre>
<p>然后使用 Git 下载 API 源代码：</p>
<pre><code class="language-shell">git clone git@github.com:Binaryify/NeteaseCloudMusicApi.git
npm install
</code></pre>
<p>在然后运行 app.js：</p>
<pre><code class="language-shell">node app.js
</code></pre>
<p>如需要修改默认端口号，可这样实现：</p>
<p>Mac/Linux：</p>
<pre><code class="language-shell">PORT=4000 node app.js
</code></pre>
<p>Windows：</p>
<pre><code class="language-shell">set PORT=4000 &amp;&amp; node app.js
</code></pre>
<h2 id="结尾">结尾</h2>
<p>这就是本文的全部内容啦，经过一段时间的使用，体验还是非常棒的！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel Composer 笔记]]></title>
        <id>https://imcm.xyz/laravel-composer-note/</id>
        <link href="https://imcm.xyz/laravel-composer-note/">
        </link>
        <updated>2020-06-20T07:33:42.000Z</updated>
        <summary type="html"><![CDATA[<p>记录Composer版本说明和如何在正式环境使用Composer安装Laravel依赖并排除开发环境需要的第三方开发包</p>
]]></summary>
        <content type="html"><![CDATA[<p>记录Composer版本说明和如何在正式环境使用Composer安装Laravel依赖并排除开发环境需要的第三方开发包</p>
<!-- more -->
<h3 id="使用-composer-安装">使用 Composer 安装：</h3>
<pre><code class="language-shell">$ composer require &quot;barryvdh/laravel-debugbar:~3.2&quot; --dev
</code></pre>
<p>以上命令，版本限定符 ~ 意味着我们希望安装 <code>&gt;= 3.2</code> 并且 <code>&lt; 4.0</code> 的版本，例如 <code>3.2.1</code>、 <code>3.11.3</code>、 <code>3.8</code>。根据语义化版本的定义，次版本号的变化是新增功能，所以 API 是稳定的，也就是可以安全更新的。</p>
<h3 id="什么是语义化版本">什么是语义化版本？</h3>
<p>版本格式：主版本号。次版本号。修订号，如 <code>1.0.1</code>, <code>3.2.39</code>。版本号递增规则如下：</p>
<ul>
<li><strong>主版本号</strong>：当你做了不兼容的 API 修改</li>
<li><strong>次版本号</strong>：当你做了向下兼容的功能性新增</li>
<li><strong>修订号</strong>：当你做了向下兼容的问题修正。<br>
另外，先行版本号及版本编译信息可以加到 <code>主版本号.次版本号.修订号</code> 的后面，作为延伸。</li>
</ul>
<p>一般我们使用 3 个部分来表示一个版本，例如：1.4.23，1 为主版本号，4 为次版本号，23 为修订号或者补丁版本号。先行版本如 <code>1.0.0-alpha1</code> 这样在后面添加修饰符号来表示。</p>
<p>最后 Composer 安装时 <code>--dev</code> 参数是指明只在 <strong>开发环境</strong> 中使用，这样上线代码到 <strong>生产环境</strong> 时，我们可使用 <code>composer install --no-dev</code> 命令来排除这些扩展包的安装。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[gyp: No Xcode or CLT version detected!]]></title>
        <id>https://imcm.xyz/gyp-no-xcode/</id>
        <link href="https://imcm.xyz/gyp-no-xcode/">
        </link>
        <updated>2020-06-17T03:02:39.000Z</updated>
        <summary type="html"><![CDATA[<p>npm install 安装依赖包报如下错误</p>
]]></summary>
        <content type="html"><![CDATA[<p>npm install 安装依赖包报如下错误</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://imcm.xyz/post-images/1592363327243.png" alt="" loading="lazy"></figure>
<h3 id="解决思路">解决思路</h3>
<p>Mac升级到High sierra 后，发现执行使用npm 或者yarn 的时候，不时会报<code>gyp: No Xcode or CLT version detected!</code> 的错误, 原因是缺了xcode 的CLI 工具, 只要执行下面的命令来安装就可以了。</p>
<pre><code class="language-shell">sudo xcode-select --install
</code></pre>
<h4 id="再执行">再执行</h4>
<pre><code class="language-shell"> $ xcode-select --install
</code></pre>
<h4 id="后出现错误">后出现错误</h4>
<pre><code class="language-shell">xcode-select: error: command line tools are already installed, use &quot;Software Update&quot; to install updates
</code></pre>
<h3 id="解决办法">解决办法</h3>
<pre><code class="language-shell">$ sudo rm -rf $(xcode-select -print-path)
$ xcode-select --install
</code></pre>
<p>问题完美解决<br>
如果提示权限不够那么加上sudo</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在Docker 中运行 OpenWrt 旁路网关]]></title>
        <id>https://imcm.xyz/docker-openwrt/</id>
        <link href="https://imcm.xyz/docker-openwrt/">
        </link>
        <updated>2020-06-16T06:46:40.000Z</updated>
        <summary type="html"><![CDATA[<p>今天小苏为大家带来的是（咕很久的）在 Docker 中运行 OpenWrt 做旁路网关的教程~</p>
]]></summary>
        <content type="html"><![CDATA[<p>今天小苏为大家带来的是（咕很久的）在 Docker 中运行 OpenWrt 做旁路网关的教程~</p>
<!-- more -->
<p>本文转自： <a href="https://mlapp.cn/376.html">美丽应用</a></p>
<h3 id="场景1">场景1</h3>
<p>众所周知，OpenWrt 是面向嵌入型设备的 Linux 发行版，所以 OpenWrt 系统运行时的资源占用率会很低。而树莓派的硬件性能要比普通路由器要高很多。虽然树莓派在硬件配置上的绝对优势能让 OpenWrt 有更大的施展空间，但相应的，硬件上的优势也带来了资源的浪费（OpenWrt 在树莓派上正常运行时，资源占用率只有不到 1/10）。再加上 OpenWrt 的可扩展性不是很强，所以很多能在 Raspbian/Debian 上能做的事情在 OpenWrt 上往往无法实现。</p>
<p>所以，可不可以让 OpenWrt 与我们常用的系统共存呢？这样，我们可以享受到 OpenWrt 的功能，又可以让在我们常用的系统中完成一般性的 Linux 工作。</p>
<p>通过 Docker，完全可以。</p>
<h3 id="场景2">场景2</h3>
<p>OpenWrt 的功能固然强大，但是树莓派的板载网卡无线吞吐能力实在是无力吐槽，能否将现有路由器与树莓派结合使用，同时发挥现有路由器的信号优势与 OpenWrt 的软件优势呢？</p>
<p>通过旁路网关，完全可以。</p>
<h3 id="旁路网关">旁路网关</h3>
<p>那么，什么是旁路网关呢？</p>
<p>普通的路由器往往集无线信号转发、网关、DNS 服务器等角色为一身，其中的“网关”角色负责路由器内部数据的处理。但因为一般家用的路由器硬件性能很有限，在运行一些比较吃资源的应用（如酸酸乳、去广告等）时，几乎会占满所有硬件资源，导致路由器网络/系统不稳定等诸多问题。既然路由器的硬件性能有限，那可不可以把网关的重任交给硬件性能更好的设备去做，让路由器安安心心地做好它的老本行 – 无线转发呢？</p>
<p>完全可以。</p>
<p>所谓的旁路网关，就是在路由器之外的其他硬件设备上搭建一个网关环境，把路由器肩负的网关重任交给其他更适合的设备来做，同时，旁路网关处理完的结果会返回给路由器，由路由器继续进行无线转发。</p>
<p>这样，每个角色各司其职，路由器肩上的任务轻了，即使是油管 4K 也能轻松跑满网速了，而旁路由（树莓派）也结束了它吃灰的命运。由此资源的充分利用，一举两得。</p>
<p>在接下来的文章中，我们将在 Docker 容器中运行 OpenWrt，并通过设置，让 Docker 容器中的 OpenWrt 网关接管路由器自身的网关，减轻路由器的负担，同时，由于网关被 OpenWrt 接管，所以 OpenWrt 中的大部分应用都是可用的，比如酸酸乳，V2ray，去广告等。做个不恰当的比喻， OpenWrt 网关接管路由器自身的网关后，你可以理解为路由器是 OpenWrt 的一块外置网卡。</p>
<h3 id="镜像介绍">镜像介绍</h3>
<p>小苏为大家提供的 OpenWrt 镜像所用系统为基于 Lean 大源码编译的 32位/ IPV4 Only 固件，基本功能与之前的自编译固件相同，并且 Docker 镜像将跟随自编译固件的更新而更新。自编译固件的详细介绍请见：<br>
<a href="https://mlapp.cn/369.html">https://mlapp.cn/369.html</a></p>
<p>但值得注意的是，Docker 固件没有无线及无线相关功能。在以后的文章中，小苏将给大家分享 OpenWrt 镜像的制作步骤，敬请期待~（Q：喂！你挖的坑还不够多吗？A：咕咕咕！）。</p>
<h3 id="重要说明">重要说明</h3>
<p>1.<strong>此教程中提到的 Docker 镜像只适用于树莓派 2B/3B/3B+/4B，在其他设备上理论上不能正常使用</strong>。但文中所述内容对其他设备应该有参考意义。</p>
<p>2.在 Docker 中运行 OpenWrt ，树莓派将工作在旁路网关模式下，在这种工作模式下，树莓派的板载无线网卡不会工作（同时在 OpenWrt 的控制面板中也找不到有关 WIFI 的设置）。所以，需要将树莓派与路由器通过网线连接来使用。</p>
<h3 id="前期准备">前期准备</h3>
<p>既然需要在 Docker 中运行 OpenWrt ，那么首先需要在树莓派的现有系统上安装 Docker，在不同发行版上安装 Docker 的教程有很多，大家可以自行在搜索引擎中搜索相关内容以完成 Docker 的安装。</p>
<p>如果你的设备是 3B/3B+/4B，小苏推荐使用“树莓派爱好者基地”编译的 64 位 Debian，此版本 Debian 可以充分发挥 64 位 CPU 的性能，同时默认开启 Docker，KVM 等功能，其中，Docker 功能开箱即用，非常方便。</p>
<p>如果你的设备是树莓派2B，那么你可能需要在其他发行版上手动安装 Docker 了，但是小苏提供的 Docker 镜像是支持 2B~4B 设备的，换句话说，只要在其他发行版上成功安装了 Docker，也是可以用我提供的 OpenWrt 镜像的。</p>
<p>为了方便叙述以及为大家提供一个参考的宿主机环境，下文内容基于“树莓派爱好者基地”编译的 64 位 Debian。当然，如果你在你使用的发行版上安装了 Docker，步骤是一样的。</p>
<p>“树莓派爱好者基地”专版64位 Debian 功能介绍（内含下载链接）：</p>
<p><a href="https://github.com/openfans-community-offical/Debian-Pi-Aarch64/blob/master/README_zh.md">https://github.com/openfans-community-offical/Debian-Pi-Aarch64</a></p>
<p>下载时推荐选择“无桌面基础系统加强版”（如下图），如果你有图形界面需求，也可以选择带图形界面的其他版本镜像。</p>
<figure data-type="image" tabindex="1"><img src="https://imcm.xyz/post-images/1591772689336.png" alt="" loading="lazy"></figure>
<p>下载镜像烧写到树莓派的 SD 卡并上电开机后，系统会自动完成扩展 SD 卡空间的操作，这个过程大约需要3~5分钟（期间会重启几次）。估摸着时间差不多以后，用网线将树莓派的板载网口与路由器的 Lan 口连接，之后连接树莓派的 SSH：</p>
<p>用户名：pi<br>
密码：raspberry</p>
<p>准备工作到此结束。</p>
<h3 id="步骤开始">步骤开始</h3>
<p>成功登陆到树莓派的 SSH 后，在拉取镜像之前，我们还需要进行一些额外的工作：</p>
<ol>
<li>
<h4 id="打开网卡混杂模式">打开网卡混杂模式</h4>
</li>
</ol>
<pre><code class="language-shell">sudo ip link set eth0 promisc on
</code></pre>
<ol start="2">
<li>
<h4 id="创建网络须结合实际网络情况不能照抄命令">创建网络(须结合实际网络情况，不能照抄命令)</h4>
</li>
</ol>
<pre><code class="language-shell">docker network create -d macvlan --subnet=192.168.123.0/24 --gateway=192.168.123.1 -o parent=eth0 macnet
</code></pre>
<p>这一条命令需要根据树莓派所处的网络环境来做修改，可以使用 sudo ifconfig命令来查看树莓派 eth0 网卡获得的 IP 地址，如果树莓派获得的 IP 地址为 192.168.2.154，那么说明树莓派处在 192.168.2.x网段，相应的，命令中的192.168.123.0和192.168.123.1需要被替换成 192.168.2.0和192.168.2.1：</p>
<pre><code class="language-shell">docker network create -d macvlan --subnet=192.168.2.0/24 --gateway=192.168.2.1 -o parent=eth0 macnet
</code></pre>
<p>此时，我们使用 docker network ls命令可以看到网络macnet已建立成功：</p>
<pre><code class="language-shell">$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
10e676133746        bridge              bridge              local
f5308b94e8fa        host                host                local
16745ea66852        macnet              macvlan             local
5e72e41ea02a        none                null                local
</code></pre>
<ol start="3">
<li>
<h4 id="拉取镜像">拉取镜像</h4>
</li>
</ol>
<p>若身处国内，为提高拉取速度，请拉取阿里云仓库中的镜像：</p>
<pre><code class="language-shell">docker pull registry.cn-shanghai.aliyuncs.com/suling/openwrt:latest
</code></pre>
<p>同时小苏也提供存放在 Docker 官方仓库 中的镜像：</p>
<pre><code class="language-shell">docker pull sulinggg/openwrt:latest
</code></pre>
<p>镜像拉取完成后，我们可以执行docker images命令查看现存镜像：</p>
<pre><code class="language-shell">$ docker images
REPOSITORY                                              TAG                 IMAGE ID            CREATED             SIZE
registry.cn-shanghai.aliyuncs.com/suling/openwrt        latest              4f4bc5dca2d9        3 hours ago         112MB
</code></pre>
<p>可见，镜像已成功拉取到本地。</p>
<ol start="4">
<li>
<h4 id="创建并启动容器">创建并启动容器</h4>
</li>
</ol>
<pre><code class="language-shell">docker run --restart always --name openwrt -d --network macnet --privileged registry.cn-shanghai.aliyuncs.com/suling/openwrt:latest /sbin/init
</code></pre>
<p>其中：<br>
--restart always参数表示容器退出时始终重启，使服务尽量保持始终可用；<br>
--name openwrt参数定义了容器的名称；<br>
-d参数定义使容器运行在 Daemon 模式；<br>
--network macnet参数定义将容器加入 maxnet网络；<br>
--privileged 参数定义容器运行在特权模式下；<br>
registry.cn-shanghai.aliyuncs.com/suling/openwrt:latest为 Docker 镜像名，因容器托管在阿里云 Docker 镜像仓库内，所以在镜像名中含有阿里云仓库信息；<br>
/sbin/init定义容器启动后执行的命令。<br>
启动容器后，我们可以使用 docker ps -a命令查看当前运行的容器：</p>
<pre><code class="language-shell">$ docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
a26cee7cade6        openwrt:latest      &quot;/sbin/init&quot;        3 hours ago         Up 3 hours                              openwrt
</code></pre>
<p>若容器运行信息STATUS列为 UP状态，则说明容器运行正常。</p>
<ol start="5">
<li>
<h4 id="进入容器并修改相关参数">进入容器并修改相关参数</h4>
</li>
</ol>
<p>(须结合实际网络情况，不能照抄配置)</p>
<pre><code class="language-shell">docker exec -it openwrt bash
</code></pre>
<p>其中：<br>
openwrt为容器名称；<br>
bash为进入容器后执行的命令。<br>
执行此命令后我们便进入 OpenWrt 的命令行界面，首先，我们需要编辑 OpenWrt 的网络配置文件：</p>
<pre><code class="language-shell">vim /etc/config/network
</code></pre>
<p>我们需要更改 Lan 口设置：</p>
<pre><code class="language-shell">config interface 'lan'
        option type 'bridge'
        option ifname 'eth0'
        option proto 'static'
        option ipaddr '192.168.123.100'
        option netmask '255.255.255.0'
        option ip6assign '60'
        option gateway '192.168.123.1'
        option broadcast '192.168.123.255'
        option dns '192.168.123.1'
</code></pre>
<p>其中：<br>
所有的 192.168.123.x 需要根据树莓派所处网段修改，option gateway和option dns填写路由器的 IP，若树莓派获得的 IP 为 192.168.2.154，路由器 IP 为192.168.2.1，则需要这样修改：</p>
<pre><code class="language-shell">config interface 'lan'
        option type 'bridge'
        option ifname 'eth0'
        option proto 'static'
        option ipaddr '192.168.2.100'
        option netmask '255.255.255.0'
        option ip6assign '60'
        option gateway '192.168.2.1'
        option broadcast '192.168.2.255'
        option dns '192.168.2.1'
</code></pre>
<p>option ipaddr 项目定义了 OpenWrt 的 IP 地址，在完成网段设置后，IP最后一段可根据自己的爱好修改（前提是符合规则且不和现有已分配 IP 冲突）。</p>
<ol start="6">
<li>
<h4 id="重启网络">重启网络</h4>
</li>
</ol>
<pre><code class="language-shell">/etc/init.d/network restart
</code></pre>
<ol start="7">
<li>
<h4 id="进入控制面板">进入控制面板</h4>
</li>
</ol>
<p>在浏览器中输入第 5 步option ipaddr 项目中的 IP 进入 Luci 控制面板，若option ipaddr 的参数为 192.168.123.100，则可以在浏览器输入 http://192.168.123.100进入控制面板。</p>
<p>用户名：root<br>
密码：password</p>
<ol start="8">
<li>
<h4 id="关闭-dhcp-服务">关闭 DHCP 服务</h4>
</li>
</ol>
<p>在 “网络 - 接口 - Lan - 修改” 界面中，勾选下方的 “忽略此接口（不在此接口提供 DHCP 服务）”，并“保存&amp;应用”。<br>
<img src="https://imcm.xyz/post-images/1591772717735.png" alt="" loading="lazy"></p>
<ol start="9">
<li>
<h4 id="主路由-dhcp-设置">主路由 DHCP 设置</h4>
</li>
</ol>
<p>进入路由器后台中，将主路由的 DHCP 的默认网关和 DNS 服务器设置为第 5 步中option ipaddr 项目中的 IP。<br>
<img src="https://imcm.xyz/post-images/1591772738952.png" alt="" loading="lazy"></p>
<ol start="10">
<li>
<h4 id="重新连接路由器">重新连接路由器</h4>
</li>
</ol>
<p>完成以上操作后，断开设备（如手机，电脑）与路由器的连接，重新连接路由器，连接路由器的设备将获取到我们设置到的 IP。</p>
<h3 id="其他修复">其他修复</h3>
<ol>
<li>
<h4 id="关闭-wlan-硬件加速">关闭 WLAN 硬件加速</h4>
</li>
</ol>
<p>设置旁路路由后，若出现访问国内网站网速慢，不稳定的情况（多见于 Pandavan 及其改版固件，如华硕老毛子固件），请在路由器的控制面板中关闭有关 WLAN 的硬件加速，比如选择“Offload TCP/UDP for LAN”（若未出现此现象请忽略）：<br>
<img src="https://imcm.xyz/post-images/1591772753376.png" alt="" loading="lazy"></p>
<ol start="2">
<li>
<h4 id="宿主机网络修复">宿主机网络修复</h4>
</li>
</ol>
<p>OpenWrt 容器运行后，宿主机内可能无法正常连接外部网络，需要修改宿主机的 /etc/network/interfaces 文件以修复：</p>
<p><strong>(须结合实际网络情况，不能照抄配置)</strong></p>
<pre><code class="language-shell">cp /etc/network/interfaces /etc/network/interfaces.bak # 备份文件
vim /etc/network/interfaces # 使用 vim 编辑文件
</code></pre>
<p>以“树莓派爱好者基地”64 位 Debian 为例，向文件末尾添加：</p>
<pre><code class="language-shell">auto eth0
iface eth0 inet manual

auto macvlan
iface macvlan inet static
  address 192.168.123.200
  netmask 255.255.255.0
  gateway 192.168.123.1
  dns-nameservers 192.168.123.1
  pre-up ip link add macvlan link eth0 type macvlan mode bridge
  post-down ip link del macvlan link eth0 type macvlan mode bridge
</code></pre>
<p>其中，所有的 192.168.123.x都需要按照树莓派所处网段更改，gateway和dns-nameservers填写路由器的 IP，若树莓派获得的 IP 为 192.168.2.154，路由器 IP 为192.168.2.1，则需要这样修改：</p>
<pre><code class="language-shell">auto eth0
iface eth0 inet manual

auto macvlan
iface macvlan inet static
  address 192.168.2.200
  netmask 255.255.255.0
  gateway 192.168.2.1
  dns-nameservers 192.168.2.1
  pre-up ip link add macvlan link eth0 type macvlan mode bridge
  post-down ip link del macvlan link eth0 type macvlan mode bridge
</code></pre>
<p>修改后重启树莓派，之后树莓派的局域网 IP 地址将会固定为/etc/network/interfaces文件中address参数中的地址。</p>
<ol start="3">
<li>
<h4 id="手动指定网关">手动指定网关</h4>
</li>
</ol>
<p>如果路由器固件不支持自定义 DHCP 服务的网关及 DNS 地址（常见于路由器官方固件），或者只希望局域网下的个别设备接入旁路网关时，须在接入设备上做以下配置：</p>
<h5 id="安卓">安卓：</h5>
<figure data-type="image" tabindex="2"><img src="https://imcm.xyz/post-images/1591772765001.png" alt="" loading="lazy"></figure>
<p>需要在安卓的 WIFI 设置内将 IP 获取方式更改为“静态”或“手动”，其中：<br>
“IP 地址”项目需要更改为网段内不冲突的地址；<br>
“网关”或“路由器”项目需要更改为旁路网关 IP 地址；<br>
“前缀长度”项目填写“24”；<br>
“DNS”项目需要更改为旁路网关 IP 地址（两个 DNS 输入框填写一个就可以）。</p>
<p>完成并提交设置后，关闭 WIFI 开关再打开，连接设置的 WIFI 热点，若当前网络参数为设定值，则证明设置成功。</p>
<h5 id="windows">Windows:</h5>
<figure data-type="image" tabindex="3"><img src="https://imcm.xyz/post-images/1591772774844.png" alt="" loading="lazy"></figure>
<p>在无线热点的“属性”界面下，点击 “IP 设置 - 编辑”按钮，在弹出框中更改 IP 分配模式为“手动”，打开 IPV4 的开关，根据所处网段及上文安卓的相关设置填写相关参数即可。</p>
<h3 id="注意事项">注意事项</h3>
<ol>
<li>文章所述方案适用于光猫或路由器已完成宽带拨号的网络环境，未测试也不推荐使用 Docker 内的 OpenWrt 进行宽带拨号；</li>
<li>OpenWrt 容器跟随树莓派系统启动，无需手动干预；</li>
<li>由于容器内系统内核共享宿主机内核，所以在 Luci 面板的 “内核版本”项与宿主机内核版本一致；</li>
<li>在对容器进行停止或删除操作时，树莓派可能会发生卡顿现象，SSH 可能会断开，1~2 分钟后会恢复正常，目前原因不明；</li>
<li>经测试，发现 Adblock 不工作，UnblockNeteaseMusic 需要自行设置代理，除此之外容器中的 OpenWrt 多数应用工作正常，如有发现不能正常工作的应用请评论反馈~</li>
</ol>
<p>参考资料</p>
<ol>
<li><a href="https://github.com/coolsnowwolf/lede">OpenWrt By Lean · coolsnowwolf/lede - GitHub</a></li>
<li><a href="https://www.right.com.cn/forum/thread-588747-1-1.html">【小狮子编译贴】抛砖引玉，为打造N1路由神器 - 恩山无线论坛</a></li>
<li><a href="https://www.right.com.cn/forum/thread-1048535-1-1.html">docker openwrt 踩坑的几个小问题解决过程分享 - 恩山无线论坛</a></li>
<li><a href="https://www.right.com.cn/forum/thread-506510-1-1.html">N1刷入LEAN OPENWRT做旁路网关，导致访问国内网站卡顿 - 恩山无线论坛</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git 忽略文件目录权限或文件拥有者的改变]]></title>
        <id>https://imcm.xyz/chown-git/</id>
        <link href="https://imcm.xyz/chown-git/">
        </link>
        <updated>2020-06-13T09:12:49.000Z</updated>
        <summary type="html"><![CDATA[<p>git 中可以加入忽略文件权限的配置，在 git 根目录运行如下命令：</p>
]]></summary>
        <content type="html"><![CDATA[<p>git 中可以加入忽略文件权限的配置，在 git 根目录运行如下命令：</p>
<!-- more -->
<p>当前版本库忽略文件权限</p>
<pre><code class="language-shell">git config core.filemode false
</code></pre>
<p>复制所有版本库忽略文件权限</p>
<pre><code class="language-shell">git config --global core.fileMode false
</code></pre>
<p>这样就设置了忽略文件权限。</p>
<p>查看 git 的配置文件：</p>
<pre><code class="language-shell">cat .git/config
</code></pre>
<p>这时候再更新代码就 OK 了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[备份树莓派系统（MacOS)]]></title>
        <id>https://imcm.xyz/mac-backup-pi/</id>
        <link href="https://imcm.xyz/mac-backup-pi/">
        </link>
        <updated>2020-06-11T04:29:57.000Z</updated>
        <summary type="html"><![CDATA[<p>在树莓派的SD卡中初始写入了一个img系统镜像，在安装各种软件以后我们有必要对树莓派的分区进行类似GHOST的备份</p>
]]></summary>
        <content type="html"><![CDATA[<p>在树莓派的SD卡中初始写入了一个img系统镜像，在安装各种软件以后我们有必要对树莓派的分区进行类似GHOST的备份</p>
<!-- more -->
<h3 id="备份系统">备份系统</h3>
<p>将TF插入mac后，打开mac的“终端”</p>
<pre><code class="language-shell">#查询盘符
diskutil list 
# 下面图片中的dev/disk2既对应的树莓派的TF卡
</code></pre>
<p><img src="https://imcm.xyz/post-images/1591677273477.jpeg" alt="" loading="lazy"><br>
终端运行diskutil list 后显示的内容</p>
<pre><code class="language-shell"># 使用dd进行备份，同时使用gzip将备份文件进行压缩
sudo dd if=/dev/rdiskx bs=1m | gzip &gt; /path/to/backupImage.gz
#将“/dev/rdiskx ”改成您 Micro SD 卡的所在位置， if 參數是指定資料來源 (也就是 Micro #SD 卡)   of 則是指定備份影像檔的儲存路徑與檔案名稱 
</code></pre>
<p>回车后，读卡器会显示在读取数据灯在闪烁，备份过程有点长，根据卡的大小，可能会在1小时左右。</p>
<h3 id="恢复系统">恢复系统</h3>
<pre><code class="language-shell">★ 將壓縮的備份影像檔回復至 Micro SD 卡中
gzip -dc /path/to/backupImage.gz | sudo dd of=/dev/rdiskx bs=1m
※ /dev/rdiskx 請改成您 Micro SD 卡的所在位置
</code></pre>
<p>如果系统显示resource busy,表明需要先将TF卡从系统中卸载。</p>
<pre><code class="language-shell">#列出盘符名称，这里的名称显示和之前的不一样
df -f
#卸载
sudo diskutil unmount /dev/disk2s1
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://imcm.xyz/post-images/1591677296376.jpeg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[删除Mac下Git上传项目代码时产生的.DS_Store文件]]></title>
        <id>https://imcm.xyz/gitignore-mac/</id>
        <link href="https://imcm.xyz/gitignore-mac/">
        </link>
        <updated>2020-06-09T02:43:35.000Z</updated>
        <summary type="html"><![CDATA[<p>最近在 Mac 中使用 Git 上传项目时，发现 GitHub 仓库的每个文件夹下都生成了一个 .DS_Store 的文件，好奇查了一下这个文件格式，在网上搜索了一下解决办法，这里记录一下怎么删除 .DS_Store 文件以及如何在后续使用 Git时忽略掉 .DS_Store 文件。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近在 Mac 中使用 Git 上传项目时，发现 GitHub 仓库的每个文件夹下都生成了一个 .DS_Store 的文件，好奇查了一下这个文件格式，在网上搜索了一下解决办法，这里记录一下怎么删除 .DS_Store 文件以及如何在后续使用 Git时忽略掉 .DS_Store 文件。</p>
<!-- more -->
<h2 id="ds_store">.DS_Store</h2>
<p>.DS_Store 是 Mac OS 保存文件夹的自定义属性的隐藏文件，如文件的图标位置或背景色，删除后会自动生成，包含了一些文件的个人信息，如果不处理的话，可能会有一些你不一定希望别人看到的信息。</p>
<h3 id="解决办法1创建一个-gitignore-文件来忽略-ds_store">解决办法1:创建一个 .gitignore 文件来忽略 .DS_Store</h3>
<p>首先需要删除项目文件夹下已经生成的 .DS_Store 文件。</p>
<p>终端切换到项目文件夹，输入 git status 来查看是否有 .DS_Store 文件，如果有相关文件，终端输入下面的命令将它删除。</p>
<pre><code class="language-shell">find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch
</code></pre>
<p>创建一个名为.gitignore的文件</p>
<pre><code class="language-shell">touch .gitignore
</code></pre>
<p>打开创建好的 .gitignore文件</p>
<pre><code class="language-shell">open .gitignore
</code></pre>
<p>输入 .DS_Store ，然后换行继续输入 /.DS_Store ，command +s保存</p>
<p>更新项目</p>
<pre><code class="language-shell">git add --all
</code></pre>
<p>提交到远程仓库</p>
<pre><code class="language-shell">git commit -m '.DS_Store ignore'
git push
</code></pre>
<p>上面的办法只能对这个项目文件夹起作用，其它的 Git 项目文件夹要想忽略，还要重新搞一遍，所以可以做一盒全局忽略。</p>
<h3 id="解决办法2创建全局-gitignore-文件来忽略-ds_store">解决办法2:创建全局 .gitignore 文件来忽略 .DS_Store</h3>
<p>创建 .gitignore_global 文件</p>
<pre><code class="language-shell">touch .gitignore_global 
</code></pre>
<p>打开创建好的 .gitignore_global 文件</p>
<pre><code class="language-shell">Open .gitignore_global
</code></pre>
<p>输入 .DS_Store ，然后换行继续输入 /.DS_Store ，command +s保存</p>
<p>打开 .gitconfig</p>
<pre><code class="language-shell">open .gitconfig
</code></pre>
<p>在 ~/.gitconfig 中引入 .gitignore_global</p>
<pre><code>[core]
​    excludesfile = /Users/w/.gitignore_global
</code></pre>
<p>然后更新提交项目即可</p>
<blockquote>
<p>注意：user/后面填写你的电脑的用户名</p>
</blockquote>
]]></content>
    </entry>
</feed>