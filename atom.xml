<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://imcm.xyz</id>
    <title>IMCM</title>
    <updated>2020-12-23T02:20:08.589Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://imcm.xyz"/>
    <link rel="self" href="https://imcm.xyz/atom.xml"/>
    <subtitle>&lt;span id=&quot;jinrishici-sentence&quot;&gt;正在加载今日诗词....&lt;/span&gt;
&lt;script src=&quot;https://sdk.jinrishici.com/v2/browser/jinrishici.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</subtitle>
    <logo>https://imcm.xyz/images/avatar.png</logo>
    <icon>https://imcm.xyz/favicon.ico</icon>
    <rights>All rights reserved 2020, IMCM</rights>
    <entry>
        <title type="html"><![CDATA[<转>新手入门 Github Webhooks 完美自动化部署教程]]></title>
        <id>https://imcm.xyz/Github-webhook/</id>
        <link href="https://imcm.xyz/Github-webhook/">
        </link>
        <updated>2020-12-22T14:26:59.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>之前使用GitHub Actions可以在提交代码后自动上传到腾讯云COS存储桶,实现静态网站完美自动化部署.那么非静态的网站或者项目需要自动化部署到VPS服务器上就可以使用GitHub Webhooks来实现.作为纯属新手来说,网上查阅了十几篇相关教程,都没法部署成功,最后总算找到了问题关键点,决定整理成文章分享出来,希望能帮助到新手用户.</p>
<blockquote>
<p>Webhook支持php,js等多种方式,可以实现简单的部署,也可以实现复杂的自动化构建等功能,本文介绍适合新手用户的php方式,来自动化部署网站.</p>
</blockquote>
<h3 id="webhook简单原理">Webhook简单原理</h3>
<p>对于入门新手来说,Webhook可以理解为当你在本地完成代码工作后,Push提交到GitHub,GitHub检测到Push后,使用Webhook发送一条命令到你的VPS服务器上的Webhook.php文件,服务器检测到命令后根据webhook.php中的配置在服务器上执行Pull命令,同步GitHub上的代码到服务器.实现了简单的自动化部署工作.节省了你再次上传至服务器的多余操作.</p>
<h3 id="部署流程">部署流程</h3>
<h4 id="启用shell_exec">启用shell_exec</h4>
<p>编辑php.ini</p>
<pre><code class="language-shell">vim /usr/local/php/etc/php.ini
</code></pre>
<p>查找shell_exec,在disable_functions中删除shell_exec字段.<br>
<img src="https://imcm.xyz/post-images/1608622210723.jpg" alt="" loading="lazy"></p>
<p>重启php.ini保存设置</p>
<pre><code class="language-shell">/etc/init.d/php-fpm restart
</code></pre>
<h4 id="配置站点目录权限">配置站点目录权限</h4>
<p>由于Webhook的推送请求是通过http/https方式发送至服务器,根据webhook.php中的命令执行git pull的实为运行php的用户,根据以下命令可以查执行php用户为www.</p>
<pre><code class="language-shell">ps aux | grep php
</code></pre>
<p>确保仓库所在的站点目录所有者为www</p>
<pre><code class="language-shell">chown -R www:www /home/wwwroot
</code></pre>
<h4 id="切换为www账户">切换为www账户</h4>
<p>以root账户登陆服务器,修改www的登录权限.</p>
<pre><code class="language-shell">vim /etc/passwd
</code></pre>
<p>找到</p>
<pre><code class="language-shell">www:x:1003:1003::/home/www:/sbin/nologin
</code></pre>
<p>修为改</p>
<pre><code class="language-shell">www:x:1003:1003::/home/www:/bin/bash
</code></pre>
<h4 id="为www创建ssh公钥">为www创建ssh公钥</h4>
<p>切换为www登陆</p>
<pre><code class="language-shell">su www
</code></pre>
<p>创建ssh公钥</p>
<pre><code class="language-shell">ssh-keygen -t rsa
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://imcm.xyz/post-images/1608622389755.jpg" alt="" loading="lazy"></figure>
<p>获取你的公钥id_rsa.pub</p>
<pre><code class="language-shell">cat /home/www/.ssh/id_rsa.pub
</code></pre>
<h4 id="登陆github配置ssh公钥">登陆GitHub配置ssh公钥</h4>
<p>登陆GitHub - 进入仓库 - Settings - Deploy keys - Add Deploy keys<br>
粘贴刚才创建的公钥</p>
<figure data-type="image" tabindex="2"><img src="https://imcm.xyz/post-images/1608622410820.jpg" alt="" loading="lazy"></figure>
<h4 id="首次git-clone仓库">首次git clone仓库</h4>
<p>验证ssh公钥配置成功</p>
<pre><code class="language-shell">ssh -T git@github.com
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://imcm.xyz/post-images/1608622477397.jpg" alt="" loading="lazy"></figure>
<p>首次clone仓库成功</p>
<pre><code class="language-shell">git clone git@github.com:xxxxxx/xxxxxxx.git
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://imcm.xyz/post-images/1608622485033.jpg" alt="" loading="lazy"></figure>
<h4 id="配置webhookphp">配置webhook.php</h4>
<p>在项目网站根目录创建webhook.php获得外网链接为https://yourdoamin.com/webhook.php<br>
粘贴以下代码,只需要更改keySecret和wwwRoot即可.</p>
<pre><code class="language-php">&lt;?php

// 自行创建一个验证密码
$keySecret = 'xxxxxx';

// 修改为你自己的仓库绝对路径
$wwwRoot = [
    '/home/wwwroot/xxxx',
];

// 保存运行脚本的日志
$logFile = 'log/webhook.log';

// 执行git命令
$gitCommand = 'git pull';

// 判断是否开启秘钥认证(已实现gitee和github)
if (isset($keySecret) &amp;&amp; !empty($keySecret)) {
    list($headers, $gitType) = [[], null];
    foreach ($_SERVER as $key =&gt; $value) {
        'HTTP_' == substr($key, 0, 5) &amp;&amp; $headers[str_replace('_', '-', substr($key, 5))] = $value;
        if (empty($gitType) &amp;&amp; strpos($key, 'GITEE') !== false) {
            $gitType = 'GITEE';
        }
        if (empty($gitType) &amp;&amp; strpos($key, 'GITHUB') !== false) {
            $gitType = 'GITHUB';
        }
    }
    if ($gitType == 'GITEE') {
        if (!isset($headers['X-GITEE-TOKEN']) || $headers['X-GITEE-TOKEN'] != $keySecret) {
            die('GITEE - 请求失败，秘钥有误');
        }
    } elseif ($gitType == 'GITHUB') {
        $json_content = file_get_contents('php://input');
        $signature = &quot;sha1=&quot; . hash_hmac('sha1', $json_content, $keySecret);
        if ($signature != $headers['X-HUB-SIGNATURE']) {
            die('GITHUB - 请求失败，秘钥有误');
        }
    } else {
        die('请求错误，未知git类型');
    }
}

!is_array($wwwRoot) &amp;&amp; $wwwRoot = [$wwwRoot];
foreach ($wwwRoot as $vo) {
    $shell = sprintf(&quot;cd %s &amp;&amp; git pull 2&gt;&amp;1&quot;, $vo);
    $output = shell_exec($shell);
    $log = sprintf(&quot;[%s] %s \n&quot;, date('Y-m-d H:i:s', time()) . ' - ' . $vo, $output);
    echo $log;
    file_put_contents($logFile, $log, FILE_APPEND);
}
</code></pre>
<h4 id="github-webhooks配置">GitHub Webhooks配置</h4>
<p>登陆GitHub - 进入仓库 - Settings - Webhooks - Add webhook<br>
Payload URL 输入刚才获取的webhook.php的外网链接.<br>
Content type 保持默认<br>
Secret 输入刚才配置webhook.php创建的验证密码<br>
Add webhook 完成创建<br>
<img src="https://imcm.xyz/post-images/1608622528975.jpg" alt="" loading="lazy"></p>
<h4 id="恢复关闭www登陆">恢复关闭www登陆</h4>
<p>exit退出www登陆切回root,在次关闭www登陆.</p>
<pre><code class="language-shell">vim /etc/passwd
</code></pre>
<p>恢复为</p>
<pre><code class="language-shell">www:x:1003:1003::/home/www:/sbin/nologin
</code></pre>
<h4 id="自动化部署成功">自动化部署成功</h4>
<p>本地push代码到GitHub后,可以看到返回信息提示服务器pull成功.<br>
<img src="https://imcm.xyz/post-images/1608622569768.jpg" alt="" loading="lazy"></p>
<h3 id="关键点和相关错误">关键点和相关错误</h3>
<h4 id="权限">权限</h4>
<p>网上很多教程都没有提到权限问题,所以对于新手小白来说,就会不知道为什么不成功.而少数提到权限的教程,也没有非常详细指导用户如何配置.所以如果部署有问题,请检查权限问题,新手用户可以严格按照本教程先部署成功,在来自行修改你需要的配置.</p>
<h4 id="webhookphp">webhook.php</h4>
<p>webhook.php的代码网上也有很多种,有些能用有些无法使用,本文提供的是经过测试可用的,大家也可以自行搜索或者编辑.</p>
<h4 id="service-timeout">Service Timeout</h4>
<p>当遇到push大量代码时,服务器pull需要更长的时间,所以webhook返回给GitHub的信息如下图会出现Service Timeout超时错误,但实际上服务器也成功执行了pull,你可以登陆服务器检查来确认,同时也可以根据你的项目实际情况自行修改webhook.php执行配置.<br>
<img src="https://imcm.xyz/post-images/1608622604663.jpg" alt="" loading="lazy"></p>
<h4 id="证书错误">证书错误</h4>
<p>有可能会出现下图中的证书错误提示,请更换证书,测试时使用的Let's Encrypt的泛域名证书就会报错,博主更换为腾讯云申请的单域名证书就可以了.<br>
<img src="https://imcm.xyz/post-images/1608622614276.jpg" alt="" loading="lazy"></p>
<h3 id="结语">结语</h3>
<p>特别感谢以下两篇文章给予了关于www权限和webhook.php两个关键点的帮助:<br>
<a href="https://learnku.com/articles/34320">gitee 和 GitHub 的 webhook 的使用，实现服务器代码的自动更新</a><br>
<a href="https://www.jianshu.com/p/00bc0323e83f">gitlab之webhook自动部署</a></p>
<p>本文转自:<a href="https://www.ioiox.com/archives/72.html">IOIOX</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux 解决“libssl.so.1.0.0 or libcrypto.so.1.0.0 no version information available”的问题]]></title>
        <id>https://imcm.xyz/libcrypto-ssh-waring/</id>
        <link href="https://imcm.xyz/libcrypto-ssh-waring/">
        </link>
        <updated>2020-12-21T11:30:39.000Z</updated>
        <summary type="html"><![CDATA[<p>相信很多人在使用 ssh 或者 curl 等等命令的时候都出现过“libssl.so.1.0.0 and libcrypto.so.1.0.0 no version information available”的问题，我也遇到这个问题很久了，一直懒得搭理它，因为ssh出现这个问题之后还能继续使用，直到前几天使用 nodejs 的时候又出现了这个问题严重影响了nodejs 的使用，我才决定要修复一下这个问题。</p>
]]></summary>
        <content type="html"><![CDATA[<p>相信很多人在使用 ssh 或者 curl 等等命令的时候都出现过“libssl.so.1.0.0 and libcrypto.so.1.0.0 no version information available”的问题，我也遇到这个问题很久了，一直懒得搭理它，因为ssh出现这个问题之后还能继续使用，直到前几天使用 nodejs 的时候又出现了这个问题严重影响了nodejs 的使用，我才决定要修复一下这个问题。</p>
<!-- more -->
<h3 id="解决方法一">解决方法一</h3>
<p>先来个最简单的解决方法。我出现的错误具体是这样的：</p>
<pre><code class="language-shell">ssh: /usr/local/openssl/lib/libcrypto.so.1.0.0: no version information available (required by ssh)
ssh: /usr/local/openssl/lib/libcrypto.so.1.0.0: no version information available (required by ssh)
</code></pre>
<p>我在 /usr目录下搜索了一下这个libcrypto.so.1.0.0 和 libcrypto.so.1.0.0：</p>
<pre><code class="language-shell">imcm@mac-mini:~$ sudo find /usr -name libcrypto.so.1.0.0
[sudo] imcm 的密码： 
/usr/lib/x86_64-linux-gnu/libcrypto.so.1.0.0
/usr/local/openssl/lib/libcrypto.so.1.0.0
</code></pre>
<p>在网上看到有人说是因为引用了不受系统承认的版本，那我就试着把 /usr/local/openssl/lib/ 目录下的libcrypto.so.1.0.0 和 libcrypto.so.1.0.0删掉(为了保险起见，我做了移动)：</p>
<pre><code class="language-shell">sudo mv /usr/local/openssl/lib/libcrypto.so.1.0.0 /usr/local/openssl/lib/libcrypto.so.1.0.0.bk
sudo mv /usr/local/openssl/lib/libssl.so.1.0.0 /usr/local/openssl/lib/libssl.so.1.0.0.bk
</code></pre>
<p>然后，case closed！问题解决 :(滑稽)</p>
<h3 id="解决方法二">解决方法二</h3>
<p>还有一种解决方法，是重新编译 openssl，指定全局的库路径。由于这个方法我没有试过(在主用机上搞这些有风险 :(懒得理) )，这里就直接给出原链接：https://stackoverflow.com/questions/18390833/no-version-information-available，需要 FQ 才能打开，在这里搬运一下：</p>
<p>下载 1.0.0. 版本的 openssl 源码，在解压后的根目录里新建一个”openssl.ld”文件，文件内容如下：</p>
<pre><code class="language-shell">OPENSSL_1.0.0 {
    global:
    *;
};
</code></pre>
<p>接着执行：</p>
<pre><code class="language-shell">make clean
./config --prefix=/usr/local --openssldir=/usr/local/openssl shared -Wl,--version-script=openssl.ld -Wl,-Bsymbolic-functions
make
make test
make install
ldconfig
</code></pre>
<p>大致上就是这样，我的建议还是如果不懂就不要轻易试这个方法，方法一都已经能解决大部分的问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux手动升级OpenSSL]]></title>
        <id>https://imcm.xyz/linux-update-openssl/</id>
        <link href="https://imcm.xyz/linux-update-openssl/">
        </link>
        <updated>2020-12-10T12:49:21.000Z</updated>
        <summary type="html"><![CDATA[<p>2020年12月08日，OpenSSL官方发布安全公告，披露CVE-2020-1971 OpenSSL GENERAL_NAME_cmp 拒绝服务漏洞。当两个GENERAL_NAME都包含同一个EDIPARTYNAME时，由于GENERAL_NAME_cmp函数未能正确处理，从而导致空指针引用，并可能导致拒绝服务。</p>
]]></summary>
        <content type="html"><![CDATA[<p>2020年12月08日，OpenSSL官方发布安全公告，披露CVE-2020-1971 OpenSSL GENERAL_NAME_cmp 拒绝服务漏洞。当两个GENERAL_NAME都包含同一个EDIPARTYNAME时，由于GENERAL_NAME_cmp函数未能正确处理，从而导致空指针引用，并可能导致拒绝服务。</p>
<!-- more -->
<h3 id="查看现有版本">查看现有版本</h3>
<!-- more -->
<pre><code class="language-shell">openssl version
</code></pre>
<p>输出：</p>
<pre><code class="language-shell">OpenSSL 1.0.2g 1 Mar 2016
</code></pre>
<h3 id="备份旧版本">备份旧版本</h3>
<pre><code class="language-shell">mv /usr/bin/openssl /usr/bin/openssl.old
mv /usr/include/openssl /usr/include/openssl.old
</code></pre>
<h3 id="更新openssl">更新OpenSSL</h3>
<ol>
<li>下载</li>
</ol>
<pre><code class="language-shell">wget https://www.openssl.org/source/openssl-1.1.1i.tar.gz
</code></pre>
<ol start="2">
<li>解压</li>
</ol>
<pre><code class="language-shell">tar -zxvf openssl-1.1.1i.tar.gz
</code></pre>
<ol start="3">
<li>编译安装</li>
</ol>
<pre><code class="language-shell">cd openssl-1.1.1i
./config
make &amp;&amp; make install
</code></pre>
<ol start="4">
<li>设置软连接</li>
</ol>
<pre><code class="language-shell">ln -s /usr/local/openssl/bin/openssl /usr/bin/openssl
ln -s /usr/local/openssl/include/openssl /usr/include/openssl
</code></pre>
<ol start="5">
<li>设置动态地址库</li>
</ol>
<pre><code class="language-shell">echo '/usr/local/openssl/lib' &gt; /etc/ld.so.conf.d/openssl-ld.conf
</code></pre>
<h3 id="再次查看版本">再次查看版本</h3>
<pre><code class="language-shell">openssl version
</code></pre>
<p>输出：</p>
<pre><code class="language-shell">OpenSSL 1.1.1i 8 Dec 2020 (Library: OpenSSL 1.1.1d 10 Sep 2019)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[术语对照表]]></title>
        <id>https://imcm.xyz/net-info/</id>
        <link href="https://imcm.xyz/net-info/">
        </link>
        <updated>2020-09-15T03:41:37.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="osi">OSI</h2>
<p>开放式系统互联通信参考模型（英语：Open System Interconnection Reference Model，缩写为 OSI），简称为OSI模型（OSI model），一种概念模型，由国际标准化组织提出，一个试图使各种计算机在世界范围内互连为网络的标准框架</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="osi">OSI</h2>
<p>开放式系统互联通信参考模型（英语：Open System Interconnection Reference Model，缩写为 OSI），简称为OSI模型（OSI model），一种概念模型，由国际标准化组织提出，一个试图使各种计算机在世界范围内互连为网络的标准框架</p>
<!-- more -->
<h2 id="tcpip">TCP/IP</h2>
<p>互联网协议套件（英语：Internet Protocol Suite，缩写IPS）是一个网络通信模型，以及一整个网络传输协议家族，为网际网络的基础通信架构。它常被通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP</p>
<h2 id="dns">DNS</h2>
<p>'域名系统（英文：Domain Name System，缩写： 'DNS）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网</p>
<h2 id="udp">UDP</h2>
<p>用户数据包协议（英语：User Datagram Protocol，缩写：UDP），又称用户数据包协议，是一个简单的面向数据报的传输层协议</p>
<h2 id="icmp">ICMP</h2>
<p>互联网控制消息协议（英语：Internet Control Message Protocol，缩写：ICMP）是互联网协议族的核心协议之一。它用于TCP/IP网络中发送控制消息，提供可能发生在通信环境中的各种问题反馈，通过这些信息，使管理者可以对所发生的问题作出诊断，然后采取适当的措施解决</p>
<h2 id="tcp">TCP</h2>
<p>传输控制协议（英语：Transmission Control Protocol，缩写：TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议</p>
<h2 id="arq">ARQ</h2>
<p>自动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层的错误纠正协议之一。它包括停止等待ARQ协议和连续ARQ协议，错误侦测（Error Detection）、正面确认（Positive Acknowledgment）、逾时重传（Retransmission after Timeout）与负面确认继以重传（Negative Acknowledgment and Retransmission）等机制</p>
<h2 id="syn">SYN</h2>
<p>同步序列编号（Synchronize Sequence Numbers）</p>
<h2 id="ack">ACK</h2>
<p>ACK (Acknowledgement）即是确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误</p>
<h2 id="tcb">TCB</h2>
<p>传输控制块 TCB(Transmission Control Block)存储了每一个连接中的一些重要信息，如：TCP 连接表，指向发送和接收缓存的指针，指向重传队列的指针，当前的发送和接收序号等等</p>
<h2 id="http">HTTP</h2>
<p>超文本传输协议（英语：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议</p>
<h2 id="ssltls">SSL/TLS</h2>
<p>传输层安全性协议（英语：Transport Layer Security，缩写作 TLS），及其前身安全套接层（Secure Sockets Layer，缩写作 SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障</p>
<h2 id="adt">ADT</h2>
<p>抽象数据类型（Abstract Data Type，ADT）是计算机科学中具有类似行为的特定类别的数据结构的数学模型；或者具有类似语义的一种或多种程序设计语言的数据类型。抽象数据类型是间接定义的，通过其上的可执行的操作以及这些操作的效果的数学约束（与可能的代价）</p>
<h2 id="php">PHP</h2>
<p>PHP（全称：PHP：Hypertext Preprocessor，即“PHP：超文本预处理器”）是一种开源的通用计算机脚本语言，尤其适用于网络开发并可嵌入 HTML 中使用</p>
<h2 id="fpm">FPM</h2>
<p>FPM(FastCGI Process Manager, FPM)是 PHP FastCGI 运行模式的一个进程管理器</p>
<h2 id="mvc">MVC</h2>
<p>MVC模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）</p>
<h2 id="orm">ORM</h2>
<p>对象关系映射（英语：Object Relational Mapping，简称ORM，或O/RM，或O/R mapping），是一种程序设计技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换</p>
<h2 id="pdo">PDO</h2>
<p>PDO（PHP Data Objects） PHP 数据对象，是 PHP 应用中的一个数据库抽象层规范。PDO提供了一个统一的 API 接口可以使得你的 PHP 应用不去关心具体要 连接的数据库服务器系统类型</p>
<h2 id="oop">OOP</h2>
<p>面向对象编程（Object Oriented Programming，OOP，面向对象程序设计）是一种计算机编程架构</p>
<h2 id="dom">DOM</h2>
<p>文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM</p>
<h2 id="cors">CORS</h2>
<h2 id="json">JSON</h2>
<p>JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式</p>
<h2 id="jsonp">JSONP</h2>
<p>JSONP(JSON with Padding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题</p>
<h2 id="rdb">RDB</h2>
<p>RDB(Redis Database)，在指定时间间隔对 Redis 内存数据进行快照存储</p>
<h2 id="aof">AOF</h2>
<p>只追加文件(append-only file，AOF)，在执行写命令时，将被执行的写命令复制到磁盘里面</p>
<h2 id="ipc">IPC</h2>
<p>进程间通信（IPC，Inter-Process Communication），指至少两个进程或线程间传送数据或信号的一些技术或方法</p>
<h2 id="qps">QPS</h2>
<p>每秒查询率 QPS(Query Per Second) 是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准</p>
<h2 id="tps">TPS</h2>
<p>Transactions Per Second（每秒传输的事物处理个数），即服务器每秒处理的事务数</p>
<h2 id="xss">XSS</h2>
<p>跨站脚本（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响</p>
<h2 id="csrf">CSRF</h2>
<p>跨站请求伪造（英语：Cross-site request forgery），通常缩写为 CSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法</p>
<h2 id="ddos">DDOS</h2>
<p>DDOS 又称为分布式拒绝服务，全称是 Distributed Denial of Service。DDOS 本是利用合理的请求造成资源过载，导致服务不可用</p>
<h2 id="oop-2">OOP</h2>
<p>面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针</p>
<h2 id="sso">SSO</h2>
<p>单点登录（英语：Single sign-on，缩写为 SSO），又译为单一签入，一种对于许多相互关连，但是又是各自独立的软件系统，提供访问控制的属性。当拥有这项属性时，当用户登录时，就可以获取所有系统的访问权限，不用对每个单一系统都逐一登录</p>
<h2 id="rest">REST</h2>
<p>表现层状态转换（英语：Representational State Transfer，缩写：REST）是一种万维网软件架构风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息</p>
<h2 id="jwt">JWT</h2>
<p>JSON Web Token 是一种跨域认证解决方案</p>
<h2 id="lvs">LVS</h2>
<p>Linux 虚拟服务器（Linux Virtual Server，LVS）是一个虚拟的服务器集群系统，用于实现负载均衡</p>
<p>以上内容均摘录自维基百科、百度百科</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP 5 String 函数]]></title>
        <id>https://imcm.xyz/php-5-array/</id>
        <link href="https://imcm.xyz/php-5-array/">
        </link>
        <updated>2020-09-10T03:10:45.000Z</updated>
        <summary type="html"><![CDATA[<p>PHP String 函数是 PHP 核心的组成部分。无需安装即可使用这些函数。</p>
]]></summary>
        <content type="html"><![CDATA[<p>PHP String 函数是 PHP 核心的组成部分。无需安装即可使用这些函数。</p>
<!-- more -->
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>addcslashes()</td>
<td>返回在指定的字符前添加反斜杠的字符串。</td>
</tr>
<tr>
<td>addslashes()</td>
<td>返回在预定义的字符前添加反斜杠的字符串。</td>
</tr>
<tr>
<td>bin2hex()</td>
<td>把 ASCII 字符的字符串转换为十六进制值。</td>
</tr>
<tr>
<td>chop()</td>
<td>移除字符串右侧的空白字符或其他字符。</td>
</tr>
<tr>
<td>chr()</td>
<td>从指定 ASCII 值返回字符。</td>
</tr>
<tr>
<td>chunk_split()</td>
<td>把字符串分割为一连串更小的部分。</td>
</tr>
<tr>
<td>convert_cyr_string()</td>
<td>把字符串由一种 Cyrillic 字符集转换成另一种。</td>
</tr>
<tr>
<td>convert_uudecode()</td>
<td>对 uuencode 编码的字符串进行解码。</td>
</tr>
<tr>
<td>convert_uuencode()</td>
<td>使用 uuencode 算法对字符串进行编码。</td>
</tr>
<tr>
<td>count_chars()</td>
<td>返回字符串所用字符的信息。</td>
</tr>
<tr>
<td>crc32()</td>
<td>计算一个字符串的 32 位 CRC（循环冗余校验）。</td>
</tr>
<tr>
<td>crypt()</td>
<td>单向的字符串加密法（hashing）。</td>
</tr>
<tr>
<td>echo()</td>
<td>输出一个或多个字符串。</td>
</tr>
<tr>
<td>explode()</td>
<td>把字符串打散为数组。</td>
</tr>
<tr>
<td>fprintf()</td>
<td>把格式化的字符串写入到指定的输出流。</td>
</tr>
<tr>
<td>get_html_translation_table()</td>
<td>返回 htmlspecialchars() 和 htmlentities() 使用的翻译表。</td>
</tr>
<tr>
<td>hebrev()</td>
<td>把希伯来（Hebrew）文本转换为可见文本。</td>
</tr>
<tr>
<td>hebrevc()</td>
<td>把希伯来（Hebrew）文本转换为可见文本，并把新行（\n）转换为 <br>。</td>
</tr>
<tr>
<td>hex2bin()</td>
<td>把十六进制值的字符串转换为 ASCII 字符。</td>
</tr>
<tr>
<td>html_entity_decode()</td>
<td>把 HTML 实体转换为字符。</td>
</tr>
<tr>
<td>htmlentities()</td>
<td>把字符转换为 HTML 实体。</td>
</tr>
<tr>
<td>htmlspecialchars_decode()</td>
<td>把一些预定义的 HTML 实体转换为字符。</td>
</tr>
<tr>
<td>htmlspecialchars()</td>
<td>把一些预定义的字符转换为 HTML 实体。</td>
</tr>
<tr>
<td>implode()</td>
<td>返回一个由数组元素组合成的字符串。</td>
</tr>
<tr>
<td>join()</td>
<td>implode() 的别名。</td>
</tr>
<tr>
<td>lcfirst()</td>
<td>把字符串中的首字符转换为小写。</td>
</tr>
<tr>
<td>levenshtein()</td>
<td>返回两个字符串之间的 Levenshtein 距离。</td>
</tr>
<tr>
<td>localeconv()</td>
<td>返回本地数字及货币格式信息。</td>
</tr>
<tr>
<td>ltrim()</td>
<td>移除字符串左侧的空白字符或其他字符。</td>
</tr>
<tr>
<td>md5()</td>
<td>计算字符串的 MD5 散列。</td>
</tr>
<tr>
<td>md5_file()</td>
<td>计算文件的 MD5 散列。</td>
</tr>
<tr>
<td>metaphone()</td>
<td>计算字符串的 metaphone 键。</td>
</tr>
<tr>
<td>money_format()</td>
<td>返回格式化为货币字符串的字符串。</td>
</tr>
<tr>
<td>nl_langinfo()</td>
<td>返回指定的本地信息。</td>
</tr>
<tr>
<td>nl2br()</td>
<td>在字符串中的每个新行之前插入 HTML 换行符。</td>
</tr>
<tr>
<td>number_format()</td>
<td>通过千位分组来格式化数字。</td>
</tr>
<tr>
<td>ord()</td>
<td>返回字符串中第一个字符的 ASCII 值。</td>
</tr>
<tr>
<td>parse_str()</td>
<td>把查询字符串解析到变量中。</td>
</tr>
<tr>
<td>print()</td>
<td>输出一个或多个字符串。</td>
</tr>
<tr>
<td>printf()</td>
<td>输出格式化的字符串。</td>
</tr>
<tr>
<td>quoted_printable_decode()</td>
<td>把 quoted-printable 字符串转换为 8 位字符串。</td>
</tr>
<tr>
<td>quoted_printable_encode()</td>
<td>把 8 位字符串转换为 quoted-printable 字符串。</td>
</tr>
<tr>
<td>quotemeta()</td>
<td>引用元字符。</td>
</tr>
<tr>
<td>rtrim()</td>
<td>移除字符串右侧的空白字符或其他字符。</td>
</tr>
<tr>
<td>setlocale()</td>
<td>设置地区信息（地域信息）。</td>
</tr>
<tr>
<td>sha1()</td>
<td>计算字符串的 SHA-1 散列。</td>
</tr>
<tr>
<td>sha1_file()</td>
<td>计算文件的 SHA-1 散列。</td>
</tr>
<tr>
<td>similar_text()</td>
<td>计算两个字符串的相似度。</td>
</tr>
<tr>
<td>soundex()</td>
<td>计算字符串的 soundex 键。</td>
</tr>
<tr>
<td>sprintf()</td>
<td>把格式化的字符串写入一个变量中。</td>
</tr>
<tr>
<td>sscanf()</td>
<td>根据指定的格式解析来自一个字符串的输入。</td>
</tr>
<tr>
<td>str_getcsv()</td>
<td>把 CSV 字符串解析到数组中。</td>
</tr>
<tr>
<td>str_ireplace()</td>
<td>替换字符串中的一些字符（大小写不敏感）。</td>
</tr>
<tr>
<td>str_pad()</td>
<td>把字符串填充为新的长度。</td>
</tr>
<tr>
<td>str_repeat()</td>
<td>把字符串重复指定的次数。</td>
</tr>
<tr>
<td>str_replace()</td>
<td>替换字符串中的一些字符（大小写敏感）。</td>
</tr>
<tr>
<td>str_rot13()</td>
<td>对字符串执行 ROT13 编码。</td>
</tr>
<tr>
<td>str_shuffle()</td>
<td>随机地打乱字符串中的所有字符。</td>
</tr>
<tr>
<td>str_split()</td>
<td>把字符串分割到数组中。</td>
</tr>
<tr>
<td>str_word_count()</td>
<td>计算字符串中的单词数。</td>
</tr>
<tr>
<td>strcasecmp()</td>
<td>比较两个字符串（大小写不敏感）。</td>
</tr>
<tr>
<td>strchr()</td>
<td>查找字符串在另一字符串中的第一次出现。（strstr() 的别名。）</td>
</tr>
<tr>
<td>strcmp()</td>
<td>比较两个字符串（大小写敏感）。</td>
</tr>
<tr>
<td>strcoll()</td>
<td>比较两个字符串（根据本地设置）。</td>
</tr>
<tr>
<td>strcspn()</td>
<td>返回在找到任何指定的字符之前，在字符串查找的字符数。</td>
</tr>
<tr>
<td>strip_tags()</td>
<td>剥去字符串中的 HTML 和 PHP 标签。</td>
</tr>
<tr>
<td>stripcslashes()</td>
<td>删除由 addcslashes() 函数添加的反斜杠。</td>
</tr>
<tr>
<td>stripslashes()</td>
<td>删除由 addslashes() 函数添加的反斜杠。</td>
</tr>
<tr>
<td>stripos()</td>
<td>返回字符串在另一字符串中第一次出现的位置（大小写不敏感）。</td>
</tr>
<tr>
<td>stristr()</td>
<td>查找字符串在另一字符串中第一次出现的位置（大小写不敏感）。</td>
</tr>
<tr>
<td>strlen()</td>
<td>返回字符串的长度。中文字符串的处理使用 mb_strlen() 函数。</td>
</tr>
<tr>
<td>strnatcasecmp()</td>
<td>使用一种&quot;自然排序&quot;算法来比较两个字符串（大小写不敏感）。</td>
</tr>
<tr>
<td>strnatcmp()</td>
<td>使用一种&quot;自然排序&quot;算法来比较两个字符串（大小写敏感）。</td>
</tr>
<tr>
<td>strncasecmp()</td>
<td>前 n 个字符的字符串比较（大小写不敏感）。</td>
</tr>
<tr>
<td>strncmp()</td>
<td>前 n 个字符的字符串比较（大小写敏感）。</td>
</tr>
<tr>
<td>strpbrk()</td>
<td>在字符串中搜索指定字符中的任意一个。</td>
</tr>
<tr>
<td>strpos()</td>
<td>返回字符串在另一字符串中第一次出现的位置（大小写敏感）。</td>
</tr>
<tr>
<td>strrchr()</td>
<td>查找字符串在另一个字符串中最后一次出现。</td>
</tr>
<tr>
<td>strrev()</td>
<td>反转字符串。</td>
</tr>
<tr>
<td>strripos()</td>
<td>查找字符串在另一字符串中最后一次出现的位置(大小写不敏感)。</td>
</tr>
<tr>
<td>strrpos()</td>
<td>查找字符串在另一字符串中最后一次出现的位置(大小写敏感)。</td>
</tr>
<tr>
<td>strspn()</td>
<td>返回在字符串中包含的特定字符的数目。</td>
</tr>
<tr>
<td>strstr()</td>
<td>查找字符串在另一字符串中的第一次出现（大小写敏感）。</td>
</tr>
<tr>
<td>strtok()</td>
<td>把字符串分割为更小的字符串。</td>
</tr>
<tr>
<td>strtolower()</td>
<td>把字符串转换为小写字母。</td>
</tr>
<tr>
<td>strtoupper()</td>
<td>把字符串转换为大写字母。</td>
</tr>
<tr>
<td>strtr()</td>
<td>转换字符串中特定的字符。</td>
</tr>
<tr>
<td>substr()</td>
<td>返回字符串的一部分。</td>
</tr>
<tr>
<td>mb_substr()</td>
<td>返回中文字符串的一部分。</td>
</tr>
<tr>
<td>substr_compare()</td>
<td>从指定的开始位置（二进制安全和选择性区分大小写）比较两个字符串。</td>
</tr>
<tr>
<td>substr_count()</td>
<td>计算子串在字符串中出现的次数。</td>
</tr>
<tr>
<td>substr_replace()</td>
<td>把字符串的一部分替换为另一个字符串。</td>
</tr>
<tr>
<td>trim()</td>
<td>移除字符串两侧的空白字符和其他字符。</td>
</tr>
<tr>
<td>ucfirst()</td>
<td>把字符串中的首字符转换为大写。</td>
</tr>
<tr>
<td>ucwords()</td>
<td>把字符串中每个单词的首字符转换为大写。</td>
</tr>
<tr>
<td>vfprintf()</td>
<td>把格式化的字符串写到指定的输出流。</td>
</tr>
<tr>
<td>vprintf()</td>
<td>输出格式化的字符串。</td>
</tr>
<tr>
<td>vsprintf()</td>
<td>把格式化字符串写入变量中。</td>
</tr>
<tr>
<td>wordwrap()</td>
<td>按照指定长度对字符串进行折行处理。</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux/Mac下统计当前文件夹下的文件个数、目录个数]]></title>
        <id>https://imcm.xyz/linuxmac-list-fields/</id>
        <link href="https://imcm.xyz/linuxmac-list-fields/">
        </link>
        <updated>2020-08-31T13:09:40.000Z</updated>
        <summary type="html"><![CDATA[<p>这篇文章主要介绍了Linux下统计当前文件夹下的文件个数、目录个数,本文使用ls命令配合管理、grep命令实现统计需求</p>
]]></summary>
        <content type="html"><![CDATA[<p>这篇文章主要介绍了Linux下统计当前文件夹下的文件个数、目录个数,本文使用ls命令配合管理、grep命令实现统计需求</p>
<!-- more -->
<h3 id="1-统计当前文件夹下文件的个数">1. 统计当前文件夹下文件的个数</h3>
<pre><code class="language-shell">ls -l |grep &quot;^-&quot;|wc -l
</code></pre>
<h3 id="2-统计当前文件夹下目录的个数">2.  统计当前文件夹下目录的个数</h3>
<pre><code class="language-shell">ls -l |grep &quot;^d&quot;|wc -l
</code></pre>
<h3 id="3-统计当前文件夹下文件的个数包括子文件夹里的">3. 统计当前文件夹下文件的个数，包括子文件夹里的</h3>
<pre><code class="language-shell">ls -lR|grep &quot;^-&quot;|wc -l
</code></pre>
<h3 id="4-统计文件夹下目录的个数包括子文件夹里的">4. 统计文件夹下目录的个数，包括子文件夹里的</h3>
<pre><code class="language-shell">ls -lR|grep &quot;^d&quot;|wc -l
</code></pre>
<h3 id="5-说明">5. 说明</h3>
<ul>
<li>代码如下:</li>
</ul>
<pre><code class="language-shell">ls -l
</code></pre>
<p>长列表输出当前文件夹下文件信息(注意这里的文件，不同于一般的文件，可能是目录、链接、设备文件等)</p>
<ul>
<li>代码如下:</li>
</ul>
<pre><code class="language-shell">grep &quot;^-&quot;
</code></pre>
<p>这里将长列表输出信息过滤一部分，只保留一般文件，如果只保留目录就是 ^d</p>
<ul>
<li>代码如下:</li>
</ul>
<pre><code class="language-shell">wc -l
</code></pre>
<p>统计输出信息的行数，因为已经过滤得只剩一般文件了，所以统计结果就是一般文件信息的行数，又由于一行信息对应一个文件，所以也就是文件的个数。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker CE 镜像源]]></title>
        <id>https://imcm.xyz/docker-pi/</id>
        <link href="https://imcm.xyz/docker-pi/">
        </link>
        <updated>2020-08-28T14:46:12.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="1-使用官方安装脚本自动安装-仅适用于公网环境">1. 使用官方安装脚本自动安装 （仅适用于公网环境）</h3>
]]></summary>
        <content type="html"><![CDATA[<h3 id="1-使用官方安装脚本自动安装-仅适用于公网环境">1. 使用官方安装脚本自动安装 （仅适用于公网环境）</h3>
<!-- more -->
<pre><code class="language-shell">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun
</code></pre>
<h3 id="2-手动安装帮助-阿里云ecs可以通过内网安装见注释部分内容">2. 手动安装帮助 (阿里云ECS可以通过内网安装，见注释部分内容)</h3>
<h4 id="ubuntu-1404-1604-使用apt-get进行安装">Ubuntu 14.04 16.04 (使用apt-get进行安装)</h4>
<pre><code class="language-shell"># step 1: 安装必要的一些系统工具
sudo apt-get update
sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common
# step 2: 安装GPG证书
curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -
# Step 3: 写入软件源信息
sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;
# Step 4: 更新并安装 Docker-CE
sudo apt-get -y update
sudo apt-get -y install docker-ce

注意：其他注意事项在下面的注释中
# 安装指定版本的Docker-CE:
# Step 1: 查找Docker-CE的版本:
# apt-cache madison docker-ce
#   docker-ce | 17.03.1~ce-0~ubuntu-xenial | http://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages
#   docker-ce | 17.03.0~ce-0~ubuntu-xenial | http://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages
# Step 2: 安装指定版本的Docker-CE: (VERSION 例如上面的 17.03.1~ce-0~ubuntu-xenial)
# sudo apt-get -y install docker-ce=[VERSION]

# 通过经典网络、VPC网络内网安装时，用以下命令替换Step 2、Step 3中的命令
# 经典网络：
# curl -fsSL http://mirrors.aliyuncs.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -
# sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyuncs.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;
# VPC网络：
# curl -fsSL http://mirrors.cloud.aliyuncs.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -
# sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.cloud.aliyuncs.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;
</code></pre>
<h4 id="centos-7-使用yum进行安装">CentOS 7 (使用yum进行安装)</h4>
<pre><code class="language-shell"># step 1: 安装必要的一些系统工具
sudo yum install -y yum-utils device-mapper-persistent-data lvm2
# Step 2: 添加软件源信息
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
# Step 3: 更新并安装 Docker-CE
sudo yum makecache fast
sudo yum -y install docker-ce
# Step 4: 开启Docker服务
sudo service docker start

注意：其他注意事项在下面的注释中
# 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，你可以通过以下方式开启。同理可以开启各种测试版本等。
# vim /etc/yum.repos.d/docker-ce.repo
#   将 [docker-ce-test] 下方的 enabled=0 修改为 enabled=1
#
# 安装指定版本的Docker-CE:
# Step 1: 查找Docker-CE的版本:
# yum list docker-ce.x86_64 --showduplicates | sort -r
#   Loading mirror speeds from cached hostfile
#   Loaded plugins: branch, fastestmirror, langpacks
#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            docker-ce-stable
#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            @docker-ce-stable
#   docker-ce.x86_64            17.03.0.ce-1.el7.centos            docker-ce-stable
#   Available Packages
# Step2 : 安装指定版本的Docker-CE: (VERSION 例如上面的 17.03.0.ce.1-1.el7.centos)
# sudo yum -y install docker-ce-[VERSION]
# 注意：在某些版本之后，docker-ce安装出现了其他依赖包，如果安装失败的话请关注错误信息。例如 docker-ce 17.03 之后，需要先安装 docker-ce-selinux。
# yum list docker-ce-selinux- --showduplicates | sort -r
# sudo yum -y install docker-ce-selinux-[VERSION]

# 通过经典网络、VPC网络内网安装时，用以下命令替换Step 2中的命令
# 经典网络：
# sudo yum-config-manager --add-repo http://mirrors.aliyuncs.com/docker-ce/linux/centos/docker-ce.repo
# VPC网络：
# sudo yum-config-manager --add-repo http://mirrors.could.aliyuncs.com/docker-ce/linux/centos/docker-ce.repo
</code></pre>
<h3 id="安装校验">安装校验</h3>
<pre><code class="language-shell">root@iZbp12adskpuoxodbkqzjfZ:$ docker version
Client:
 Version:      17.03.0-ce
 API version:  1.26
 Go version:   go1.7.5
 Git commit:   3a232c8
 Built:        Tue Feb 28 07:52:04 2017
 OS/Arch:      linux/amd64

Server:
 Version:      17.03.0-ce
 API version:  1.26 (minimum version 1.12)
 Go version:   go1.7.5
 Git commit:   3a232c8
 Built:        Tue Feb 28 07:52:04 2017
 OS/Arch:      linux/amd64
 Experimental: false
</code></pre>
<h3 id="常用命令">常用命令</h3>
<pre><code class="language-shell">#查看 Docker 版本
docker -v
sudo docker pull 仓库/镜像:版本（留空的话默认为 latest）
sudo docker run 加参数，用来创建容器
#查看运行容器
sudo docker ps
#查看所有下载的镜像
sudo docker images
#进入容器终端
sudo docker exec -i -t ha /bin/bash
#实时查看10行的 ha 日志
sudo docker logs -f -t --tail 10 ha
#重启 systemctl 守护进程
sudo systemctl daemon-reload
#设置 Docker 开机启动
sudo systemctl enable docker
#开启 Docker 服务
sudo systemctl start docker

#下载 Docker 图形化界面 portainer
sudo docker pull portainer/portainer
#创建 portainer 容器
sudo docker volume create portainer_data
#运行 portainer
sudo docker run -d -p 9000:9000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer
</code></pre>
<h3 id="参考资料">参考资料</h3>
<p>其他关于旧版本Docker卸载以及测试开发版本Docker安装的帮助，可以参考官方文档的说明进行安装</p>
<p><a href="https://docs.docker.com/engine/installation/linux/docker-ce/centos/?spm=a2c6h.12873639.0.0.1aba47efpIg1xo">CentOS帮助链接</a><br>
<a href="https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/?spm=a2c6h.12873639.0.0.1aba47efpIg1xo">Ubuntu帮助链接</a><br>
<a href="https://docs.docker.com/engine/installation/linux/docker-ce/debian/?spm=a2c6h.12873639.0.0.1aba47efpIg1xo">Debian帮助链接</a><br>
<a href="https://docs.docker.com/engine/installation/linux/docker-ce/fedora/?spm=a2c6h.12873639.0.0.1aba47efpIg1xo">Fedora帮助链接</a></p>
<p>转自：<a href="https://developer.aliyun.com/article/110806">阿里云开发社区</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[腾讯视频自动签到获得V力值]]></title>
        <id>https://imcm.xyz/qcloud-v/</id>
        <link href="https://imcm.xyz/qcloud-v/">
        </link>
        <updated>2020-08-16T15:27:47.000Z</updated>
        <summary type="html"><![CDATA[<p>本教程需要用到腾讯云的云函数SCF。没有腾讯云账户的请先申请账户，注册<a href="https://cloud.tencent.com/act/cps/redirect-all?redirect=10135&amp;opc_hash_key=XG7JfqCPIb8b1609">腾讯云</a>。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本教程需要用到腾讯云的云函数SCF。没有腾讯云账户的请先申请账户，注册<a href="https://cloud.tencent.com/act/cps/redirect-all?redirect=10135&amp;opc_hash_key=XG7JfqCPIb8b1609">腾讯云</a>。</p>
<!-- more -->
<h3 id="1-浏览器打开腾讯视频官网">1. 浏览器打开腾讯视频官网：</h3>
<p>https://v.qq.com/<br>
登录VIP账号</p>
<h3 id="2-vip账号登录成功后打开另一个地址">2. VIP账号登录成功后，打开另一个地址：</h3>
<p>https://vip.video.qq.com/fcgi-bin/comm_cgi?name=hierarchical_task_system&amp;cmd=2<br>
（没错这个就是签到地址。APP抓出来的。）</p>
<h3 id="3-在第二个地址按下快捷键ctrlshiftj">3. 在第二个地址，按下快捷键：CTRL+SHIFT+J</h3>
<p>在&gt;后面输入：</p>
<pre><code>document.cookie
</code></pre>
<p>回车，复制【引号里】的内容（脚本要用的cookies）：</p>
<p>用qq或者微信登录<a href="https://console.cloud.tencent.com/scf">腾讯云scf</a>(无服务器云函数)</p>
<p>函数服务=》（选择区域，上海，广州，成都，香港，北京）<br>
=》新建=》空白函数=》函数名称（随便写，比如txsp_qiandao）=》运行环境（python3.6）=》下一步</p>
<p>复制下面代码：</p>
<pre><code class="language-python"># -*- coding: utf8 -*-
 
import requests
import re
import time
from urllib.parse import quote
 
def start():
    try:
        s = requests.session()
 
        cookie1 = 'TXSP_COOKIE'
 
        this_time = int(round(time.time() * 1000))
 
        login_url = 'https://vip.video.qq.com/fcgi-bin/comm_cgi?name=hierarchical_task_system&amp;cmd=2&amp;_=' + str(this_time)
 
        headers={
            'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.204 Safari/537.36',
            'Cookie': cookie1
        }
 
        res =s.get(login_url,headers=headers).text
 
        print('访问结果：'+res)
 
        if 'Account Verify Error' in res:
            print('cookies失效，通知SERVER酱！')
            requests.get('https://sc.ftqq.com/SCKEY.send?text=' + quote('腾讯视频自动签到失败~'+time.strftime('%Y.%m.%d',time.localtime(time.time()))) +'&amp;desp='+quote('cookies失效，请更新！\n'))
        else:
            print('签到完成')
 
    except Exception as e:
        print(&quot;地址访问失败，通知SERVER酱！&quot;)
        requests.get('https://sc.ftqq.com/SCKEY.send?text=' + quote('腾讯视频自动签到失败~'+time.strftime('%Y.%m.%d',time.localtime(time.time()))) +'&amp;desp='+quote('异常代码：\n'+str(e)))
 
 
def main_handler(event, context):
    return start()
 
 
if __name__ == '__main__':
    start()
</code></pre>
<p>代码需要修改的地方3处，</p>
<ul>
<li>TXSP_COOKIE （一处，刚才获取的cookies字符串）</li>
<li>https://sc.ftqq.com/XXXX.send （两处，server酱的地址，申请地址：http://sc.ftqq.com/）</li>
</ul>
<p>完成。</p>
<h3 id="4-触发方式定时触发-名称txsp_timer-自定义触发周期0-0-3-保存">4. 触发方式=》定时触发 / 名称：txsp_timer / 自定义触发周期（0 0 3 * * * *）保存</h3>
<h3 id="5-函数代码测试如果日志显示checkin_score-5这个5就是获得的v力值签到过也会有中文提示">5. 函数代码=》测试（如果日志显示”checkin_score”: 5，这个5就是获得的V力值，签到过也会有中文提示）</h3>
<h3 id="其他说明">其他说明</h3>
<h4 id="1-如果日志里提示">1. 如果日志里提示：</h4>
<p>{“msg”:”Account Verify Error”,”ret”:-10006}说明COOKIES获取错误。</p>
<h4 id="2-cookie能用多久还不知道反正我挂了40多天了-验证失败了也会微信通知更新下cookies就行">2. COOKIE能用多久还不知道，，反正我挂了40多天了。。。验证失败了，也会微信通知，更新下COOKIES就行。</h4>
<h4 id="3签到分数不保证-现在大多是10分左右偶尔50分-这个腾讯的锅~就当腾讯云函数来背吧~">3.签到分数不保证。。现在大多是10分左右，偶尔50分+。。。这个腾讯的锅~<s>就当腾讯云函数来背吧</s>~</h4>
<p>来源(Source)：<a href="https://lsdlhlx.top/2019/10/%E8%85%BE%E8%AE%AF%E8%A7%86%E9%A2%91%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0%E8%8E%B7%E5%BE%97v%E5%8A%9B%E5%80%BC/">西瓜小窝</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ECMAScript 2015～2020 语法思维导图]]></title>
        <id>https://imcm.xyz/ecmascript/</id>
        <link href="https://imcm.xyz/ecmascript/">
        </link>
        <updated>2020-08-14T11:52:34.000Z</updated>
        <summary type="html"><![CDATA[<p>ECMAScript 2015～2020 思维导图</p>
]]></summary>
        <content type="html"><![CDATA[<p>ECMAScript 2015～2020 思维导图</p>
<!-- more -->
<p><img src="https://imcm.xyz/post-images/1597377198390.jpg" alt="" loading="lazy"><br>
<img src="https://imcm.xyz/post-images/1597377288128.jpg" alt="" loading="lazy"></p>
<p>转自：<a href="http://es.xiecheng.live/">XieCheng</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LinuxVPS 自建ZeroTier 的MOON根目录服务器]]></title>
        <id>https://imcm.xyz/linux-zerotier-moon/</id>
        <link href="https://imcm.xyz/linux-zerotier-moon/">
        </link>
        <updated>2020-08-12T12:20:39.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="说明">说明</h3>
<p>zerotier 可以作为一款 p2p 的 vlan 内网穿透工具，功能强大且易用，同类产品还有 frp和 LanProxy等。最近有个朋友有创建 p2p vlan 的需求，在简单调研之后决定使用 zerotier 作为基础工具。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="说明">说明</h3>
<p>zerotier 可以作为一款 p2p 的 vlan 内网穿透工具，功能强大且易用，同类产品还有 frp和 LanProxy等。最近有个朋友有创建 p2p vlan 的需求，在简单调研之后决定使用 zerotier 作为基础工具。</p>
<!-- more -->
<p>官方给出的使用方案比较简单。首先需要一个中心的节点用于两个内网节点的握手，该中心节点需要有一个公网 IP。zerotier 官网提供了中心节点相关服务，免费账户有一定的使用限制，但是由于其节点位于国外，延迟比较高，且可能还需要科学上网才能使用。除此之外，zerotier 也支持自己搭建中心节点服务器，也叫做 MOON 服务器。下面是它的搭建步骤。</p>
<h3 id="moon-服务器配置">MOON 服务器配置</h3>
<p>操作系统版本是 <code>Ubuntu 18.04, Zerotier One</code> 版本是 <code>v1.2.10</code>, 公网 (也就是 MOON 服务器) 地址是 1.1.1.1。</p>
<h4 id="1-通过官网文档根据不同操作系统选择不同的安装方式这里直接通过命令行安装">1. 通过<a href="https://www.zerotier.com/">官网</a>文档根据不同操作系统选择不同的安装方式，这里直接通过命令行安装</h4>
<pre><code class="language-shell">curl -s 'https://pgp.mit.edu/pks/lookup?op=get&amp;search=0x1657198823E52A61' | gpg --import &amp;&amp; \ if z=(curl -s 'https://install.zerotier.com/' | gpg); then echo &quot;z&quot; | sudo bash; fi
</code></pre>
<p>如果上述命令运行失败，那么使用下面命令(建议用这个)</p>
<pre><code class="language-shell">curl -s https://install.zerotier.com/ | sudo bash
</code></pre>
<h4 id="2-将-moon-服务器加入-zerotier-局域网">2. 将 MOON 服务器加入 Zerotier 局域网</h4>
<p>虽然搭建了 MOON 服务器，我们还是需要借助 <a href="https://my.zerotier.com/network">zerotier network</a>，也就是需要先通过 zerotier 官网创建一个 network，并且内网节点需要使用 <code>join</code> 命令加入该网络才能实现内网节点的互通，换句话说 MOON 节点只起到了加速的作用，虚拟网络的分配和管理还是需要 zerotier 服务端参与。</p>
<pre><code class="language-shell">zerotier-cli join &lt;network id&gt;
</code></pre>
<h4 id="3-生成配置文件">3. 生成配置文件</h4>
<pre><code class="language-shell">sudo chmod 777 /var/lib/zerotier-one # 这里为了有写入文件的权限
cd /var/lib/zerotier-one
sudo zerotier-idtool initmoon identity.public &gt; moon.json
</code></pre>
<h4 id="4-修改配置文件-moonjson主要是添加公网-ip修改内容如下9993-是默认端口">4. 修改配置文件 <code>moon.json</code>，主要是添加公网 IP，修改内容如下，<code>9993</code> 是默认端口</h4>
<pre><code class="language-shell">&quot;stableEndpoints&quot;: [ &quot;1.1.1.1/9993&quot; ] #修改为VPS公网IP/9993
</code></pre>
<p>还需要注意 <code>moon.json</code> 中的 id 值，它是 MOON 服务器的 ID，是一个 10 位的字符串，我的为 <code>efe9e9a259</code>，也可以用 <code>sudo zerotier-cli info</code> 查看，后面会用到。</p>
<h4 id="5-生成-moon-文件">5. 生成 moon 文件</h4>
<pre><code class="language-shell">sudo zerotier-idtool genmoon moon.json
</code></pre>
<h4 id="6-在-varlibzerotier-one-目录下新建-moonsd-文件夹中并将生成的-moon-文件放到该文件夹下我的-moon-文件名为-000000efe9e9a259moon">6. 在 <code>/var/lib/zerotier-one</code> 目录下新建 <code>moons.d</code> 文件夹中，并将生成的 moon 文件放到该文件夹下，我的 moon 文件名为 <code>000000efe9e9a259.moon</code></h4>
<pre><code class="language-shell">mv 000000efe9e9a259.moon moons.d/
</code></pre>
<h4 id="7-重启-zerotier-one">7. 重启 <code>zerotier-one</code></h4>
<pre><code class="language-shell">sudo systemctl restart zerotier-one.service
</code></pre>
<h3 id="内网节点配置本地设备">内网节点配置(本地设备)</h3>
<h4 id="1-在内网节点安装-zerotier安装方法和上面类似根据文档选择不同操作系统的方法进行安装即可-请参考文章zerotier-无公网-ip-实现内网穿透">1. 在内网节点安装 zerotier，安装方法和上面类似，根据<a href="https://www.moewah.com/go/aHR0cHM6Ly93d3cuemVyb3RpZXIuY29tL2Rvd25sb2FkLnNodG1s">文档</a>选择不同操作系统的方法进行安装即可。请参考文章<a href="https://www.moewah.com/archives/1474.html">《ZeroTier 无公网 IP 实现内网穿透》</a></h4>
<h4 id="2-将-moon-节点添加到常规节点">2. 将 MOON 节点添加到常规节点</h4>
<pre><code class="language-shell">sudo zerotier-cli orbit efe9e9a259 efe9e9a259 # 注意这里是两次根节点的ID
</code></pre>
<p>如果没返回 <code>200 orbit OK</code> 的话，需要手动拷贝生成的 moon 文件 <code>000000efe9e9a259.moon</code> 文件到常规节点的机器上，位置如下:</p>
<pre><code>Windows: C:\ProgramData\ZeroTier\One
Macintosh: /Library/Application Support/ZeroTier/One (在 Terminal 中应为 /Library/Application\ Support/ZeroTier/One)
Linux: /var/lib/zerotier-one
FreeBSD/OpenBSD: /var/db/zerotier-one
</code></pre>
<h4 id="3-然后重启-zerotier-one">3. 然后重启 zerotier-one</h4>
<p>查看节点列表，出现根服务器的 MOON 节点表示成功</p>
<pre><code class="language-shell"> ~ sudo zerotier-cli listpeers
200 listpeers     
200 listpeers 3dfa0fd16b - -1 - LEAF
200 listpeers 8841408a2e 45.32.248.87/9993;11749;11453 252 1.1.5 PLANET
200 listpeers 9d219039f3 128.199.197.217/9993;11749;11381 390 1.1.5 PLANET
200 listpeers abfd31bd47 178.128.240.145/35368;6238;14319 509 1.2.5 LEAF
200 listpeers efe9e9a259 1.1.1.1/9993;6238;1184 36 1.2.12 MOON
</code></pre>
<h4 id="4-我们再在内网节点上运行-ifconfigwindows-是-ipconfig可以看到-zerotier-vlan-分配给其的内网-ip">4. 我们再在内网节点上运行 ifconfig(windows 是 ipconfig)，可以看到 zerotier vlan 分配给其的内网 IP</h4>
<pre><code class="language-shell">zt0: flags=8843 metric 5000 mtu 2800
    ether 1a:42:9a:39:7d:3f
    inet 10.147.18.127 netmask 0xffffff00 broadcast 10.147.18.255
    inet6 fe80::1842:9aff:fe39:7d3f%zt0 prefixlen 64 scopeid 0xc
    inet6 fcec:2f1a:a769:487e:c00e::1 prefixlen 40
    nd6 options=201
    media: autoselect
    status: active
    open (pid 84214)
</code></pre>
<p>这里的 <code>10.147.18.127</code>就是其虚拟局域网的 IP，在另外一个局域网中通过上述过程配置另外一个节点，它的虚拟局域网 IP 为 <code>10.147.18.30</code>，两个节点通过 <code>ping</code> 可以互相通</p>
<p>转自：<a href="https://opt.gs/posts/56602/">vps侦探</a></p>
]]></content>
    </entry>
</feed>